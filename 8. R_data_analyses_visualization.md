# Part 1. Hg geochemistry plot
## THg, MeHg fluctuation overtime
```r
# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
Hg_data <- read.csv("data/gy21_geochemical/Hg_data.csv", header = TRUE)

# format the date variable in the dataframe
Hg_data$date <- factor(Hg_data$date, levels=unique(Hg_data$date))
Hg_data$date <- as.Date(Hg_data$date, format="%Y/%m/%d")

# set site order in the plot
Hg_data$site <- factor(Hg_data$site, levels = c("HX", "GX", "SK"))

# filter data
Hg_data_surface <- Hg_data %>%
  filter(type == 'Surface')

Hg_data_rhizosphere <- Hg_data %>%
  filter(type == 'Rhizosphere')


(p1 <- ggplot(Hg_data_surface, aes(y = MeHg, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "MeHg concentration \n (μg/kg)", color = "Site") +
  ylim(0, 5) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.2,se = TRUE, alpha = 0.25))


(p2 <- ggplot(Hg_data_rhizosphere, aes(y = MeHg, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 5) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.35,se = TRUE, alpha = 0.25))


combine1 <- p1 + p2 + plot_layout(widths = c(1.4, 1))

(p3 <- ggplot(Hg_data_surface, aes(y = THg.m, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "THg concentration \n (mg/kg)", color = "Site") +
  ylim(0, 120) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.6,se = TRUE, alpha = 0.25))

(p4 <- ggplot(Hg_data_rhizosphere, aes(y = THg.m, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 120) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.6,se = TRUE, alpha = 0.25))

combine2 <- p3 + p4 + plot_layout(widths = c(1.4, 1))

# load data
Hg_speciation_data <- read.csv("data/gy21_geochemical/Hg_speciation_data.csv", header = TRUE)

# format the date variable in the dataframe
Hg_speciation_data$date <- factor(Hg_speciation_data$date, levels=unique(Hg_speciation_data$date))
Hg_speciation_data$date <- as.Date(Hg_speciation_data$date, format="%Y/%m/%d")

# set site order in the plot
Hg_speciation_data$site <- factor(Hg_speciation_data$site, levels = c("HX", "GX", "SK"))

# filter data
Hg_speciation_data_surface <- Hg_speciation_data %>%
  filter(type == 'Surface')

Hg_speciation_data_rhizosphere <- Hg_speciation_data %>%
  filter(type == 'Rhizosphere')


(p5 <- ggplot(Hg_speciation_data_surface, aes(y = F1, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = " F1-fraction Hg \n(μg/kg) ", color = "Site") +
  ylim(0, 3) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


(p6 <- ggplot(Hg_speciation_data_rhizosphere, aes(y = F1, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 3) + 
  theme_minimal() + 
  theme(legend.position = "bottom",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


combine3 <- p5 + p6 + plot_layout(widths = c(1.4, 1))

# Remove all legends from individual plots  
p1 <- p1 + theme(legend.position = "none")  
p2 <- p2 + theme(legend.position = "none")  
p3 <- p3 + theme(legend.position = "none")  
p4 <- p4 + theme(legend.position = "none")  

# Add labels directly to the left plots  
p1 <- p1 + labs(subtitle = "B") + theme(plot.subtitle = element_text(hjust = 0, face = "bold", size = 12))  
p3 <- p3 + labs(subtitle = "A") + theme(plot.subtitle = element_text(hjust = 0, face = "bold", size = 12))  
p5 <- p5 + labs(subtitle = "C") + theme(plot.subtitle = element_text(hjust = 0, face = "bold", size = 12))  

# Recreate the combined plots  
combine1 <- p1 + p2 + plot_layout(widths = c(1.4, 1))  
combine2 <- p3 + p4 + plot_layout(widths = c(1.4, 1))  
combine3 <- p5 + p6 + plot_layout(widths = c(1.4, 1))  

# Create the final combined plot with a bottom legend and no automatic tags  
combined_plot <- (combine2 / combine1 / combine3) +  
  plot_layout(guides = "collect") +  
  plot_layout(heights = c(1, 1, 1)) &  
  theme(legend.position = "bottom")  
combined_plot

ggsave("output/Hg_data2.pdf", width = 20, height = 17, units = "cm")


# method = "loess", the default for small n, uses a smooth local regression (as described in ?loess). The wiggliness of the line is controlled by the span parameter, which ranges from 0 (exceedingly wiggly) to 1 (not so wiggly).

# make the figure for rhizosphere and MeHg to total ratio. 


(p1 <- ggplot(Hg_data_surface, aes(y = MeHg, x = day, color = site)) +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) +
  labs(x = "", y = "", color = "Site") +  # Remove y-axis label
  ylim(0, 5) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        text = element_text(color = "black"),
        panel.grid = element_blank(),
        panel.background = element_blank(),
        panel.border = element_blank(),
        axis.line = element_line(color = "black", size=1.5),
        axis.text = element_blank(),  # Remove axis numbers
        axis.ticks = element_blank()  # Remove axis tick marks
        ) + 
  geom_smooth(span = 0.2, se = FALSE, alpha = 1, size = 3))

ggsave("output/MeHg_biorender.png", width = 10, height = 10, units = "cm")


```

## THg, MeHg fluctuation overtime - 20250808
```r
# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
Hg_data <- read.csv("data/gy21_geochemical/Hg_data.csv", header = TRUE)

# format the date variable in the dataframe
Hg_data$date <- factor(Hg_data$date, levels=unique(Hg_data$date))
Hg_data$date <- as.Date(Hg_data$date, format="%Y/%m/%d")

# set site order in the plot
Hg_data$site <- factor(Hg_data$site, levels = c("HX", "GX", "SK"))

# filter data
Hg_data_surface <- Hg_data %>%
  filter(type == 'Surface')

Hg_data_rhizosphere <- Hg_data %>%
  filter(type == 'Rhizosphere')

# Custom theme with only x and y axis lines, no grid
custom_theme <- theme_minimal() + 
  theme(
    # Remove all grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    # Remove panel border (we'll add axis lines instead)
    panel.border = element_blank(),
    # Add only x and y axis lines
    axis.line.x = element_line(color = "black", size = 0.5),
    axis.line.y = element_line(color = "black", size = 0.5),
    # Ensure text is black
    text = element_text(color = "black"),
    axis.text = element_text(color = "black"),
    axis.title = element_text(color = "black")
  )

(p1 <- ggplot(Hg_data_surface, aes(y = MeHg, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) +
  labs(x = "", y = "MeHg concentration \n (μg/kg)", color = "Site") +
  ylim(0, 5) + 
  custom_theme + 
  theme(legend.position = "none") +
  geom_smooth(span = 0.2, se = TRUE, alpha = 0.25))

(p2 <- ggplot(Hg_data_rhizosphere, aes(y = MeHg, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) +
  labs(x = "", y = "", color = "Site") +
  ylim(0, 5) + 
  custom_theme + 
  theme(legend.position = "none") +
  geom_smooth(span = 0.35, se = TRUE, alpha = 0.25))

(p3 <- ggplot(Hg_data_surface, aes(y = THg.m, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) +
  labs(x = "", y = "THg concentration \n (mg/kg)", color = "Site") +
  ylim(0, 120) + 
  custom_theme + 
  theme(legend.position = "none") +
  geom_smooth(span = 0.6, se = TRUE, alpha = 0.25))

(p4 <- ggplot(Hg_data_rhizosphere, aes(y = THg.m, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) +
  labs(x = "", y = "", color = "Site") +
  ylim(0, 120) + 
  custom_theme + 
  theme(legend.position = "none") +
  geom_smooth(span = 0.6, se = TRUE, alpha = 0.25))

# load data
Hg_speciation_data <- read.csv("data/gy21_geochemical/Hg_speciation_data.csv", header = TRUE)

# format the date variable in the dataframe
Hg_speciation_data$date <- factor(Hg_speciation_data$date, levels=unique(Hg_speciation_data$date))
Hg_speciation_data$date <- as.Date(Hg_speciation_data$date, format="%Y/%m/%d")

# set site order in the plot
Hg_speciation_data$site <- factor(Hg_speciation_data$site, levels = c("HX", "GX", "SK"))

# filter data
Hg_speciation_data_surface <- Hg_speciation_data %>%
  filter(type == 'Surface')

Hg_speciation_data_rhizosphere <- Hg_speciation_data %>%
  filter(type == 'Rhizosphere')

(p5 <- ggplot(Hg_speciation_data_surface, aes(y = F1, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) +
  labs(x = "", y = " F1-fraction Hg \n(μg/kg) ", color = "Site") +
  ylim(0, 3) + 
  custom_theme + 
  theme(legend.position = "none") +
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.3))

(p6 <- ggplot(Hg_speciation_data_rhizosphere, aes(y = F1, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) +
  labs(x = "", y = "", color = "Site") +
  ylim(0, 3) + 
  custom_theme + 
  theme(legend.position = "none") +
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.3))

# Add labels directly to the left plots  
p1 <- p1 + labs(subtitle = "B") + theme(plot.subtitle = element_text(hjust = 0, face = "bold", size = 12))  
p3 <- p3 + labs(subtitle = "A") + theme(plot.subtitle = element_text(hjust = 0, face = "bold", size = 12))  
p5 <- p5 + labs(subtitle = "C") + theme(plot.subtitle = element_text(hjust = 0, face = "bold", size = 12))  

# Create the combined plots  
combine1 <- p1 + p2 + plot_layout(widths = c(1.4, 1))  
combine2 <- p3 + p4 + plot_layout(widths = c(1.4, 1))  
combine3 <- p5 + p6 + plot_layout(widths = c(1.4, 1))  

# Create the final combined plot with a bottom legend
combined_plot <- (combine2 / combine1 / combine3) +  
  plot_layout(guides = "collect") +  
  plot_layout(heights = c(1, 1, 1)) &  
  theme(legend.position = "bottom")  

combined_plot

ggsave("output/Hg_data2_20250808.pdf", width = 20, height = 17, units = "cm")


```


## pH fluctuation over time 
```r
# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
pH_data <- read.csv("data/gy21_geochemical/pH_data.csv", header = TRUE)

# format the date variable in the dataframe
pH_data$date <- factor(pH_data$date, levels=unique(pH_data$date))
pH_data$date <- as.Date(pH_data$date, format="%Y/%m/%d")

# set site order in the plot
pH_data$site <- factor(pH_data$site, levels = c("HX", "GX", "SK"))

# filter data
pH_data_surface <- pH_data %>%
  filter(type == 'Surface')

pH_data_rhizosphere <- pH_data %>%
  filter(type == 'Rhizosphere')

# Get average pH
averages_THg_surface <- pH_data_surface %>%
  group_by(date, site) %>%
  summarize(Average_pH = mean(pH, na.rm=TRUE)) %>%
  ungroup() %>%
  arrange(date) # Arrange the data frame by date

averages_THg_rhizosphere <- pH_data_rhizosphere %>%
  group_by(date, site) %>%
  summarize(Average_pH = mean(pH, na.rm=TRUE)) %>%
  ungroup() %>%
  arrange(date) # Arrange the data frame by date


(ph_p1 <- ggplot(pH_data_surface, aes(y = pH, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "pH", color = "Site") +
  ylim(6, 8) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.7,se = TRUE, alpha = 0.3))


(ph_p2 <- ggplot(pH_data_rhizosphere, aes(y = pH, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(6, 8) + 
  theme_minimal() + 
  theme(legend.position = "none",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.7,se = TRUE, alpha = 0.3))


ph_combine <- ph_p1 + ph_p2 + plot_layout(widths = c(1.4, 1))
ph_combine


ggsave("output/pH_data.pdf", width = 25, height = 8, units = "cm")

# method = "loess", the default for small n, uses a smooth local regression (as described in ?loess). The wiggliness of the line is controlled by the span parameter, which ranges from 0 (exceedingly wiggly) to 1 (not so wiggly).

# make the figure for rhizosphere and MeHg to total ratio. 

```

## DOM/SOM fluctuation over time 
```r
# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
OM_data <- read.csv("data/gy21_geochemical/OM_data.csv", header = TRUE)

# format the date variable in the dataframe
OM_data$date <- factor(OM_data$date, levels=unique(OM_data$date))
OM_data$date <- as.Date(OM_data$date, format="%Y/%m/%d")

# set site order in the plot
OM_data$site <- factor(OM_data$site, levels = c("HX", "GX", "SK"))

# Remove rows where type equals "bottom"  
OM_data <- OM_data[OM_data$type != "Bottom", ]  

# filter data
OM_data_surface <- OM_data %>%
  filter(type == 'Surface')
OM_data_rhizosphere <- OM_data %>%
  filter(type == 'Rhizosphere')

# remove rows where SUVA254 equals NA
SUVA_data_surface <- na.omit(OM_data_surface, cols = "DOM_SUVA254")  
SUVA_data_rhizosphere <- na.omit(OM_data_rhizosphere, cols = "DOM_SUVA254")  

# remove rows where SUVA254 equals NA
DOM_data_surface <- na.omit(OM_data_surface, cols = "DOM")  
DOM_data_rhizosphere <- na.omit(OM_data_rhizosphere, cols = "DOM")  



(som_p1 <- ggplot(SUVA_data_surface, aes(y = DOM_SUVA254, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "DOM SUVA254", color = "Site") +
  ylim(0.3, 4.5) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


(som_p2 <- ggplot(SUVA_data_rhizosphere, aes(y = DOM_SUVA254, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0.3, 4.5) + 
  theme_minimal() + 
  theme(legend.position = "none",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))

som_combine <- som_p1 + som_p2 + plot_layout(widths = c(1.4, 1))
som_combine

ggsave("output/SOM_data.pdf", width = 25, height = 8, units = "cm")


# filter data
OM_data_surface <- OM_data %>%
  filter(type == 'Surface')
OM_data_rhizosphere <- OM_data %>%
  filter(type == 'Rhizosphere')

# remove rows where SUVA254 equals NA
OM_data_surface <- na.omit(OM_data_surface, cols = "DOM")  
OM_data_rhizosphere <- na.omit(OM_data_rhizosphere, cols = "DOM")  

(dom_p3 <- ggplot(DOM_data_surface, aes(y = DOM, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "Dissolved organic \n matter (mg/g)", color = "Site") +
  ylim(0, 1.7) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.8,level = 0.95, se = TRUE, alpha = 0.3))


(dom_p4 <- ggplot(DOM_data_rhizosphere, aes(y = DOM, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 1.7) + 
  theme_minimal() + 
  theme(legend.position = "none",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8, level = 0.95, se = TRUE, alpha = 0.3))


dom_combine <- dom_p3 + dom_p4 + plot_layout(widths = c(1.4, 1))
dom_combine

ggsave("output/DOM_data.pdf", width = 25, height = 8, units = "cm")




# method = "loess", the default for small n, uses a smooth local regression (as described in ?loess). The wiggliness of the line is controlled by the span parameter, which ranges from 0 (exceedingly wiggly) to 1 (not so wiggly).

```

## sulfate & nitrate fluctuation over time 
```r
# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
SN_data <- read.csv("data/gy21_geochemical/sulfate_nitrate_data.csv", header = TRUE)

# format the date variable in the dataframe
SN_data$date <- factor(SN_data$date, levels=unique(SN_data$date))
SN_data$date <- as.Date(SN_data$date, format="%Y/%m/%d")

# set site order in the plot
SN_data$site <- factor(SN_data$site, levels = c("HX", "GX", "SK"))

# filter data
SN_data_surface <- SN_data %>%
  filter(type == 'Surface')

SN_data_rhizosphere <- SN_data %>%
  filter(type == 'Rhizosphere')


(nitrate_p1 <- ggplot(SN_data_surface, aes(y = nitrate, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "nitrate (mg/kg) ", color = "Site") +
  ylim(0, 25) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


(nitrate_p2 <- ggplot(SN_data_rhizosphere, aes(y = nitrate, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 25) + 
  theme_minimal() + 
  theme(legend.position = "none",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


nitrate_combine <- nitrate_p1 + nitrate_p2 + plot_layout(widths = c(1.4, 1))


ggsave("output/nitrate_data.pdf", width = 25, height = 8, units = "cm")


(sulfate_p3 <- ggplot(SN_data_surface, aes(y = sulfate, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "sulfate (mg/kg)", color = "Site") +
  ylim(0, 375) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.8,level = 0.95, se = TRUE, alpha = 0.3))


(sulfate_p4 <- ggplot(SN_data_rhizosphere, aes(y = sulfate, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 375) + 
  theme_minimal() + 
  theme(legend.position = "none",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8, level = 0.95, se = TRUE, alpha = 0.3))


sulfate_combine <- sulfate_p3 + sulfate_p4 + plot_layout(widths = c(1.4, 1))

ggsave("output/sulfate_data.pdf", width = 25, height = 8, units = "cm")

# method = "loess", the default for small n, uses a smooth local regression (as described in ?loess). The wiggliness of the line is controlled by the span parameter, which ranges from 0 (exceedingly wiggly) to 1 (not so wiggly).

```

## porewater/overlying water Fe2+/Fe3+/HS- fluctuation over time 
```r
# load package
library(dplyr)
library(ggplot2)
library(patchwork)
library(ggtext)


# load data
water_FeS <- read.csv("data/gy21_geochemical/water_FeS.csv", header = TRUE)

# format the date variable in the dataframe
water_FeS$date <- factor(water_FeS$date, levels=unique(water_FeS$date))
water_FeS$date <- as.Date(water_FeS$date, format="%Y/%m/%d")

# set site order in the plot
water_FeS$site <- factor(water_FeS$site, levels = c("HX", "GX", "SK"))

# filter data
water_FeS_surface <- water_FeS %>%
  filter(type == 'Porewater_surface')

water_FeS_subsurface <- water_FeS %>%
  filter(type == 'Porewater_subsurface')

water_FeS_overlying <- water_FeS %>%
  filter(type == 'Overlying_water')



(p1 <- ggplot(water_FeS_overlying, aes(y = Fe2, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "Fe2+ (uM) ", color = "Site") +
  ylim(0, 4) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


(p2 <- ggplot(water_FeS_surface, aes(y = Fe2, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 1000) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


(p3 <- ggplot(water_FeS_subsurface, aes(y = Fe2, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 1000) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))

combine1 <- p1 + p2 + p3 + plot_layout(widths = c(1, 1, 1))
combine1

ggsave("output/fe2_data.pdf", width = 25, height = 8, units = "cm")




(p4 <- ggplot(water_FeS_overlying, aes(y = Fe3, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "Fe3+ (uM) ", color = "Site") +
  ylim(0, 4) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


(p5 <- ggplot(water_FeS_surface, aes(y = Fe3, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 100) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


(p6 <- ggplot(water_FeS_subsurface, aes(y = Fe3, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 100) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))

combine2 <- p4 + p5 + p6 + plot_layout(widths = c(1, 1, 1))
combine2

ggsave("output/fe3_data.pdf", width = 25, height = 8, units = "cm")



(fe_p7 <- ggplot(water_FeS_overlying, aes(y = Fe2_totalFeRatio, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "Fe2+/Total Fe ratio ", color = "Site") +
  ylim(0, 1) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


(fe_p8 <- ggplot(water_FeS_surface, aes(y = Fe2_totalFeRatio, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 1) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


(fe_p9 <- ggplot(water_FeS_subsurface, aes(y = Fe2_totalFeRatio, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 1) + 
  theme_minimal() + 
  theme(legend.position = "none",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))

fe_combine <- fe_p7 + fe_p8 + fe_p9 + plot_layout(widths = c(1, 1, 1))
fe_combine

ggsave("output/fe2fe3_data.pdf", width = 25, height = 8, units = "cm")





(hs_p10 <- ggplot(water_FeS_overlying, aes(y = HS, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "HS- (uM) ", color = "Site") +
  ylim(0, 1) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


(hs_p11 <- ggplot(water_FeS_surface, aes(y = HS, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 5) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


(hs_p12 <- ggplot(water_FeS_subsurface, aes(y = HS, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 5) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))

hs_combine <- hs_p10 + hs_p11 + hs_p12 + plot_layout(widths = c(1, 1, 1))
hs_combine

ggsave("output/HS_data.pdf", width = 25, height = 8, units = "cm")


```

## overlying water ORP fluctuation over time
```r
# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
water_ORP <- read.csv("data/gy21_geochemical/ORP_data.csv", header = TRUE)

# format the date variable in the dataframe
water_ORP$date <- factor(water_ORP$date, levels=unique(water_ORP$date))
water_ORP$date <- as.Date(water_ORP$date, format="%Y/%m/%d")

# set site order in the plot
water_ORP$site <- factor(water_ORP$site, levels = c("HX", "GX", "SK"))


(orp_p1 <- ggplot(water_ORP, aes(y = ORP, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "ORP (mV) ", color = "Site") +
  ylim(-30, 150) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.9,se = FALSE, alpha = 0.3))



ggsave("output/ORP_data.pdf", width = 12, height = 8, units = "cm")

```

## combined_geochemical plot
```r
# Set a consistent base theme for all plots  
base_theme <- theme_minimal() +  
  theme(  
    text = element_text(size = 8, color = "black"),  
    panel.grid.major = element_line(color = "grey90"),  
    panel.grid.minor = element_blank(),  
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),  
    axis.title.x = element_blank() # Remove x-axis title  
  )  

# Define a consistent color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create a function to add sample type label to plots  
add_sample_label <- function(p, label) {  
  p + annotate("text", x = Inf, y = Inf, label = label,   
              hjust = 1.1, vjust = 1.5, size = 3, color="grey40")  
}  

# pH plots  
ph_p1 <- ggplot(pH_data_surface, aes(y = pH, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "pH", color = "Site") +  
  ylim(6, 8) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.2)  
ph_p1 <- add_sample_label(ph_p1, "Surface")  

ph_p2 <- ggplot(pH_data_rhizosphere, aes(y = pH, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "", color = "Site") +  
  ylim(6, 8) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.2)  
ph_p2 <- add_sample_label(ph_p2, "Rhizosphere")  

ph_combine <- ph_p1 + ph_p2 + plot_layout(widths = c(1.4, 1))  

# ORP plot  
orp_p1 <- ggplot(water_ORP, aes(y = ORP, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "ORP (mV)", color = "Site") +  
  ylim(-30, 150) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.2)  
orp_p1 <- add_sample_label(orp_p1, "Overlying water")  

# Soil organic matter plots  
som_p1 <- ggplot(SUVA_data_surface, aes(y = DOM_SUVA254, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "DOM \n SUVA254", color = "Site") +  
  ylim(0.3, 4.5) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.2)  
som_p1 <- add_sample_label(som_p1, "Surface")  

som_p2 <- ggplot(SUVA_data_rhizosphere, aes(y = DOM_SUVA254, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "", color = "Site") +  
  ylim(0.3, 4.5) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.2)  
som_p2 <- add_sample_label(som_p2, "Rhizosphere")  

som_combine <- som_p1 + som_p2 + plot_layout(widths = c(1.4, 1))  

# Dissolved organic matter plots  
dom_p3 <- ggplot(DOM_data_surface, aes(y = DOM, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "Dissolved organic\nmatter (mg/g)", color = "Site") +  
  ylim(0, 1.7) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, level = 0.8, se = TRUE, alpha = 0.2)  
dom_p3 <- add_sample_label(dom_p3, "Surface")  

dom_p4 <- ggplot(DOM_data_rhizosphere, aes(y = DOM, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "", color = "Site") +  
  ylim(0, 1.7) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, level = 0.8, se = TRUE, alpha = 0.2)  
dom_p4 <- add_sample_label(dom_p4, "Rhizosphere")  

dom_combine <- dom_p3 + dom_p4 + plot_layout(widths = c(1.4, 1))  

# Nitrate plots  
nitrate_p1 <- ggplot(SN_data_surface, aes(y = nitrate, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "Nitrate (mg/kg)", color = "Site") +  
  ylim(0, 25) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.2)  

nitrate_p1 <- add_sample_label(nitrate_p1, "Surface")  

nitrate_p2 <- ggplot(SN_data_rhizosphere, aes(y = nitrate, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "", color = "Site") +  
  ylim(0, 25) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.2)  
nitrate_p2 <- add_sample_label(nitrate_p2, "Rhizosphere")  

nitrate_combine <- nitrate_p1 + nitrate_p2 + plot_layout(widths = c(1.4, 1))  

# Sulfate plots  
sulfate_p3 <- ggplot(SN_data_surface, aes(y = sulfate, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "Sulfate (mg/kg)", color = "Site") +  
  ylim(0, 375) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, level = 0.95, se = TRUE, alpha = 0.3)  
sulfate_p3 <- add_sample_label(sulfate_p3, "Surface")  

sulfate_p4 <- ggplot(SN_data_rhizosphere, aes(y = sulfate, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "", color = "Site") +  
  ylim(0, 375) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, level = 0.95, se = TRUE, alpha = 0.2)  
sulfate_p4 <- add_sample_label(sulfate_p4, "Rhizosphere")  

sulfate_combine <- sulfate_p3 + sulfate_p4 + plot_layout(widths = c(1.4, 1))  

# Fe2+/Total Fe ratio plots  
fe_p7 <- ggplot(water_FeS_overlying, aes(y = Fe2_totalFeRatio, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "Fe²⁺/Total Fe ratio", color = "Site") +  
  ylim(0, 1) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.2)  
fe_p7 <- add_sample_label(fe_p7, "Overlying water")  

fe_p8 <- ggplot(water_FeS_surface, aes(y = Fe2_totalFeRatio, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "", color = "Site") +  
  ylim(0, 1) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.2)  
fe_p8 <- add_sample_label(fe_p8, "Surface porewater")  

fe_p9 <- ggplot(water_FeS_subsurface, aes(y = Fe2_totalFeRatio, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "", color = "Site") +  
  ylim(0, 1) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.2)  
fe_p9 <- add_sample_label(fe_p9, "Subsurface porewater")  

fe_combine <- fe_p7 + fe_p8 + fe_p9 + plot_layout(widths = c(1, 1, 1))  

# HS- plots  
hs_p10 <- ggplot(water_FeS_overlying, aes(y = HS, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "HS⁻ (μM)", color = "Site") +  
  ylim(0, 1) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.2)  
hs_p10 <- add_sample_label(hs_p10, "Overlying water")  

hs_p11 <- ggplot(water_FeS_surface, aes(y = HS, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "", color = "Site") +  
  ylim(0, 5) +   
  base_theme +   
  theme(legend.position = "none") +   
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.2)  
hs_p11 <- add_sample_label(hs_p11, "Surface porewater")  

hs_p12 <- ggplot(water_FeS_subsurface, aes(y = HS, x = day, color = site)) +  
  geom_point(size = 1.2) +  
  scale_color_manual(values = site_colors) +  
  labs(y = "", color = "Site") +  
  ylim(0, 5) +   
  base_theme +   
  theme(legend.position = "right") + # Keep legend only on the rightmost plot  
  geom_smooth(span = 0.8, se = TRUE, alpha = 0.2)  
hs_p12 <- add_sample_label(hs_p12, "Subsurface porewater")  

hs_combine <- hs_p10 + hs_p11 + hs_p12 + plot_layout(widths = c(1, 1, 1))  

# Final combined plot with improved layout and consistent spacing  
final_combined_plot <- (ph_combine | orp_p1) /   
                       (dom_combine | som_combine) /   
                       (sulfate_combine | nitrate_combine) /   
                       fe_combine /   
                       hs_combine +  
                       plot_annotation(  
                         theme = theme(plot.title = element_text(size = 12, face = "bold"))  
                       ) 

ggsave("output/geochemical_combined_fluctuation.pdf", width = 25, height = 17, units = "cm")

```

## Hg speciation fluctuation over time 
```r
# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
Hg_speciation_data <- read.csv("data/gy21_geochemical/Hg_speciation_data.csv", header = TRUE)

# format the date variable in the dataframe
Hg_speciation_data$date <- factor(Hg_speciation_data$date, levels=unique(Hg_speciation_data$date))
Hg_speciation_data$date <- as.Date(Hg_speciation_data$date, format="%Y/%m/%d")

# set site order in the plot
Hg_speciation_data$site <- factor(Hg_speciation_data$site, levels = c("HX", "GX", "SK"))

# filter data
Hg_speciation_data_surface <- Hg_speciation_data %>%
  filter(type == 'Surface')

Hg_speciation_data_rhizosphere <- Hg_speciation_data %>%
  filter(type == 'Rhizosphere')


(p1 <- ggplot(Hg_speciation_data_surface, aes(y = F1, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = " Hg F1 fraction water soluble (ng/g) ", color = "Site") +
  ylim(0, 3) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


(p2 <- ggplot(Hg_speciation_data_rhizosphere, aes(y = F1, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 3) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8,se = TRUE, alpha = 0.3))


combine1 <- p1 + p2 + plot_layout(widths = c(1.4, 1))
combine1

ggsave("output/F1_mercury_data.pdf", width = 25, height = 8, units = "cm")





(p3 <- ggplot(Hg_speciation_data_surface, aes(y = F2, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "Hg F2 fraction exchangeable mercury (ng/g)", color = "Site") +
  ylim(0, 1.3) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.8,level = 0.95, se = TRUE, alpha = 0.3))


(p4 <- ggplot(Hg_speciation_data_rhizosphere, aes(y = F2, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 1.3) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.8, level = 0.95, se = TRUE, alpha = 0.3))


combine2 <- p3 + p4 + plot_layout(widths = c(1.4, 1))
combine2


ggsave("output/F2_mercury_data.pdf", width = 25, height = 8, units = "cm")

# method = "loess", the default for small n, uses a smooth local regression (as described in ?loess). The wiggliness of the line is controlled by the span parameter, which ranges from 0 (exceedingly wiggly) to 1 (not so wiggly).

```

## correlation between MeHg and F1 between sites and type
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)  

# Read the CSV  
data <- read.csv("data/gy21_geochemical/F1_correlation.csv", header = TRUE)  

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))  
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))  

sum(!is.na(data$F1Hg[data$site == "GX" & data$type == "Surface"]))
sum(!is.na(data$F1Hg[data$site == "SK" & data$type == "Rhizosphere"]))


# Remove rows where "F1Hg" or "type" are NA or empty  
data <- data[data$F1Hg != "" & !is.na(data$F1Hg), ]   
data <- data[data$type != "" & !is.na(data$type), ]   

# Calculate correlation, handling potential missing combinations safely  
correlation_results <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Only calculate if we have at least 2 pairs of values  
    spearman_correlation = if(sum(complete.cases(MeHg, F1Hg)) >= 2) {  
      cor.test(MeHg, F1Hg, method = "spearman")$estimate  
    } else {  
      NA_real_  
    },  
    spearman_p_values = if(sum(complete.cases(MeHg, F1Hg)) >= 2) {  
      cor.test(MeHg, F1Hg, method = "spearman")$p.value  
    } else {  
      NA_real_  
    },  
    # Get max values safely  
    max_x = if(sum(!is.na(F1Hg)) > 0) max(F1Hg, na.rm = TRUE) else NA_real_,  
    max_y = if(sum(!is.na(MeHg)) > 0) max(MeHg, na.rm = TRUE) else NA_real_,  
    # Count number of complete cases  
    n_complete = sum(complete.cases(MeHg, F1Hg))  
  ) %>%  
  ungroup()  

# Print the correlation coefficient and significance  
print(correlation_results)  

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with text in bottom right corner  
F1Hg_p <- ggplot(data, aes(x = F1Hg, y = MeHg, color = site)) +   
  # Add points  
  geom_point(size = 3, alpha = 0.7) +   
  # Add regression lines   
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +   
  # Add correlation text at bottom right corner   
  geom_text(  
    data = correlation_results %>% filter(!is.na(spearman_correlation)),  
    aes(  
      # Use normalized coordinates (1=right, 0=bottom)  
      x = Inf,  
      y = -Inf,  
      label = paste("rho =", round(spearman_correlation, 4),  
                  "\np =", round(spearman_p_values, 4)),  
      color = "black"  
    ),  
    hjust = 2,  # Right-align the text  
    vjust = -0.3,  # Position slightly above the bottom  
    size = 3,  
    position = position_nudge(y = 0.05 * max(data$MeHg, na.rm = TRUE))  # Add a small nudge upward  
  )   +  
  # Create separate panels for each site and type combination  
  facet_grid(type ~ site, scales = "free") +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between F1-Hg and MeHg",  
    x = "F1Hg concentration (ng/g)",  
    y = "MeHg concentration (ng/g)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold")  
  )
# Display the plot  
F1Hg_p

# Save the plot  
```

## correlation between MeHg and DOM between sites and type
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)  

# Read the CSV  
data <- read.csv("data/gy21_geochemical/F1_correlation.csv", header = TRUE)  

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))  
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))  

# Remove rows where "F1Hg" or "type" are NA or empty  
data <- data[data$DOM != "" & !is.na(data$DOM), ]   
data <- data[data$type != "" & !is.na(data$type), ]   


# Calculate correlation, handling potential missing combinations safely  
correlation_results <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Only calculate if we have at least 2 pairs of values  
    spearman_correlation = if(sum(complete.cases(MeHg, DOM)) >= 2) {  
      cor.test(MeHg, DOM, method = "spearman")$estimate  
    } else {  
      NA_real_  
    },  
    spearman_p_values = if(sum(complete.cases(MeHg, DOM)) >= 2) {  
      cor.test(MeHg, DOM, method = "spearman")$p.value  
    } else {  
      NA_real_  
    },  
    # Get max values safely  
    max_x = if(sum(!is.na(DOM)) > 0) max(DOM, na.rm = TRUE) else NA_real_,  
    max_y = if(sum(!is.na(MeHg)) > 0) max(MeHg, na.rm = TRUE) else NA_real_,  
    # Count number of complete cases  
    n_complete = sum(complete.cases(MeHg, DOM))  
  ) %>%  
  ungroup()  

# Print the correlation coefficient and significance  
print(correlation_results)  

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with text in bottom right corner  
DOM_p <- ggplot(data, aes(x = DOM, y = MeHg, color = site)) +   
  # Add points  
  geom_point(size = 3, alpha = 0.7) +   
  # Add regression lines   
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +   
  # Add correlation text at bottom right corner   
  geom_text(  
    data = correlation_results %>% filter(!is.na(spearman_correlation)),  
    aes(  
      # Use normalized coordinates (1=right, 0=bottom)  
      x = Inf,  
      y = -Inf,  
      label = paste("rho =", round(spearman_correlation, 4),  
                  "\np =", round(spearman_p_values, 4)),  
      color = "black"  
    ),  
    hjust = 2,  # Right-align the text  
    vjust = -0.3,  # Position slightly above the bottom  
    size = 3,  
    position = position_nudge(y = 0.05 * max(data$MeHg, na.rm = TRUE))  # Add a small nudge upward  
  )   +  
  # Create separate panels for each site and type combination  
  facet_grid(type ~ site, scales = "free") +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between DOM and MeHg",  
    x = "DOM concentration (mg/g)",  
    y = "MeHg concentration (ng/g)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold")  
  )
# Display the plot  
DOM_p

# Save the plot  
```

## correlation between MeHg and DOM-suva254 between sites and type
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)  

# Read the CSV  
data <- read.csv("data/gy21_geochemical/F1_correlation.csv", header = TRUE)  

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))  
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))  

# Remove rows where "F1Hg" or "type" are NA or empty  
data <- data[data$SOM != "" & !is.na(data$DOM.SUVA254), ]   
data <- data[data$type != "" & !is.na(data$type), ]   


# Calculate correlation, handling potential missing combinations safely  
correlation_results <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Only calculate if we have at least 2 pairs of values  
    spearman_correlation = if(sum(complete.cases(MeHg, DOM.SUVA254)) >= 2) {  
      cor.test(MeHg, DOM.SUVA254, method = "spearman")$estimate  
    } else {  
      NA_real_  
    },  
    spearman_p_values = if(sum(complete.cases(MeHg, DOM.SUVA254)) >= 2) {  
      cor.test(MeHg, DOM.SUVA254, method = "spearman")$p.value  
    } else {  
      NA_real_  
    },  
    # Get max values safely  
    max_x = if(sum(!is.na(DOM.SUVA254)) > 0) max(DOM.SUVA254, na.rm = TRUE) else NA_real_,  
    max_y = if(sum(!is.na(MeHg)) > 0) max(MeHg, na.rm = TRUE) else NA_real_,  
    # Count number of complete cases  
    n_complete = sum(complete.cases(MeHg, DOM.SUVA254))  
  ) %>%  
  ungroup()  

# Print the correlation coefficient and significance  
print(correlation_results)  

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with text in bottom right corner  
DOM.SUVA254_p <- ggplot(data, aes(x = DOM.SUVA254, y = MeHg, color = site)) +   
  # Add points  
  geom_point(size = 3, alpha = 0.7) +   
  # Add regression lines   
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +   
  # Add correlation text at bottom right corner   
  geom_text(  
    data = correlation_results %>% filter(!is.na(spearman_correlation)),  
    aes(  
      # Use normalized coordinates (1=right, 0=bottom)  
      x = Inf,  
      y = -Inf,  
      label = paste("rho =", round(spearman_correlation, 4),  
                  "\np =", round(spearman_p_values, 4)),  
      color = "black"  
    ),  
    hjust = 2,  # Right-align the text  
    vjust = -0.3,  # Position slightly above the bottom  
    size = 3,  
    position = position_nudge(y = 0.05 * max(data$MeHg, na.rm = TRUE))  # Add a small nudge upward  
  )   +  
  # Create separate panels for each site and type combination  
  facet_grid(type ~ site, scales = "free") +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between DOM-SUVA254 and MeHg",  
    x = "DOM-SUVA254",  
    y = "MeHg concentration (ng/g)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold")  
  )
# Display the plot  
DOM.SUVA254_p

# Save the plot  
```

## composite figure of F1Hg, DOM, DOM.SUVA254 - MeHg correlation
```r

# Remove the legend from the top and middle plots  
F1Hg_p <- F1Hg_p + theme(legend.position = "none")  
DOM_p <- DOM_p + theme(legend.position = "none")  
# Keep the legend in the bottom plot  
DOM.SUVA254_p <- DOM.SUVA254_p + theme(legend.position = "bottom")  

# Create the composite figure with plots arranged in one column  
composite_figure <- F1Hg_p / DOM_p / DOM.SUVA254_p +  
  # Add common plot labels if needed  
  plot_annotation(  
    tag_levels = 'A'  # Add A, B, C labels to the plots  
  ) +  
  # Adjust the layout to give equal space to each plot  
  plot_layout(ncol = 1, heights = c(1, 1, 1.2))  # Slightly more height for bottom plot with legend  

# Print or save the composite figure  
print(composite_figure) 

ggsave("output/F1Hg_OM_MeHg_correlation.pdf", composite_figure, width = 8, height = 10,unit = "in")  


```


## main geochemical parameters comparison between sites (Figure S1)
```r
library(ggpubr)
library(reshape2)

# load data
geochemical_anova <- read.csv("data/gy21_geochemical/gy21_geochemical_anova.csv", header=TRUE, check.names = FALSE)

# melt based on geochemical variables
geochemical_anova.m = melt(geochemical_anova, id = c("Site"))

# colour pallete for sites
color = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")

# perform ANOVA
compare_means(pH ~ Site,  data = geochemical_anova, method = "kruskal.test")
# perform pairwise comparison
compare_means(pH ~ Site,  data = geochemical_anova)

# plotting pH
my_comparisons <- list( c("HX", "GX"), c("GX", "SK"), c("HX", "SK") )

# ggboxplot(geochemical_anova, x = "Site", y = "pH",
#         color = "Site", palette = color, add = "jitter")+ 
#  stat_compare_means(method = "kruskal.test")+
#  stat_compare_means(comparisons = my_comparisons,label = "p.signif",ref.group = ".all.",
#                     position = position_nudge(y = 15)) # Add pairwise comparisons p-value

ggboxplot(geochemical_anova.m, x = "Site", y = "value",
          color = "Site", palette = color, add = "jitter", short.panel.labs = FALSE) +
    facet_wrap(~ variable, scales = "free_y") + # This allows different y-axes
    stat_compare_means(method = "kruskal.test")+
    stat_compare_means(comparisons = my_comparisons,label = "p.signif",ref.group = ".all.") # Add pairwise comparisons p-value


# Adjusting ggboxplot for consistent line thickness
ggboxplot(geochemical_anova.m, x = "Site", y = "value",
               color = "Site", palette = c("#f35d36", "#ffba1b", "#60cfa1"), add = "jitter", short.panel.labs = FALSE) +
  facet_wrap(~ variable, scales = "free_y", ncol= 7) +  # Allows each variable to have its own Y-axis scale
  stat_compare_means(method = "kruskal.test",
                     label.x.npc = 1, # Position the global p-value label outside the plotting area
                     label.y.npc = 4) + # Position the global p-value label outside the plotting area
  stat_compare_means(comparisons = my_comparisons, label = "p.signif", ref.group = ".all.") +  # Pairwise comparisons
  theme(legend.position = "right",
        axis.line = element_line(size = 0.1),  # Ensure axis lines are the same thickness
        text = element_text(color = "black"),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        panel.border = element_rect(fill = NA, size = 1),  # Standard line size
        strip.background = element_rect(linetype = "solid", color = "black", size = 1))

ggsave("output/geochemical_anova.pdf", width = 36, height = 26, units = "cm")


```



# Part 2. Marker gene fluctuation over time.
## total hgcA
```r
# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
total_hgcA <- read.csv("data/gy21_geochemical/total_hgcA_data.csv", header = TRUE)

# format the date variable in the dataframe
total_hgcA$date <- factor(total_hgcA$date, levels=unique(total_hgcA$date))
total_hgcA$date <- as.Date(total_hgcA$date, format="%Y/%m/%d")

# set site order in the plot
total_hgcA$site <- factor(total_hgcA$site, levels = c("HX", "GX", "SK"))

# filter data
total_hgcA_surface <- total_hgcA %>%
  filter(type == 'Surface')

total_hgcA_rhizosphere <- total_hgcA %>%
  filter(type == 'Rhizosphere')

# get the maximum value
max(total_hgcA$overall)

# plot overall fluctuation
(p1 <- ggplot(total_hgcA_surface, aes(y = overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "total hgcA (% of total reads \n normalized by HMM length)", color = "Site") +
  ylim(0, 1.5E-7) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


(p2 <- ggplot(total_hgcA_rhizosphere, aes(y = overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 1.5E-7) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))

# get the maximum value
max(total_hgcA$overall * total_hgcA$library_correction_value)

# plot overall fluctuation
(p1 <- ggplot(total_hgcA_surface, aes(y = overall * library_correction_value, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "total hgcA (% of total reads \n normalized by HMM length)", color = "Site") +
  ylim(0, 1.2e-08) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


(p2 <- ggplot(total_hgcA_rhizosphere, aes(y = overall * library_correction_value, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 1.2e-08) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))

combine1 <- p1 + p2 + plot_layout(widths = c(1.4, 1))
combine1


ggsave("output/total_hgcA.pdf", width = 25, height = 8, units = "cm")
```

## total hgcA taxonomic distribution (outdated)
```r
library(tidyr)  
library(reshape2)  


# Read data  
total_hgcA <- read.csv("data/gy21_geochemical/total_hgcA_data.csv", header = TRUE)  

# Remove specified columns  
total_hgcA_taxonomic <- total_hgcA[, -c(1, 3, 5, 7, 8)]  

total_hgcA$site <- factor(total_hgcA$site, levels = c("HX", "GX", "SK"))
total_hgcA$type <- factor(total_hgcA$type, levels = c("Surface", "Rhizosphere"))

# melt
total_hgcA_taxonomic.m <- total_hgcA_taxonomic %>%  
  pivot_longer(  
    cols = -c(day, site, type),  # All columns except these  
    names_to = "variable",   
    values_to = "value"  
  )  

# Factor ordering (more concise method)  
total_hgcA_taxonomic.m <- total_hgcA_taxonomic.m %>%  
  mutate(  
    day = factor(day, levels = unique(day)),  
    site = factor(site, levels = unique(site)),  
    variable = factor(variable, levels = unique(variable))  ,
    type = factor(type, levels = c("Surface", "Rhizosphere"))
  )  



# define colors
color_map <- total_hgcA_taxonomic.m %>%  
  distinct(variable) %>%  
  mutate(  
    color = case_when(  
      variable %in% c("Desulfobacterota.F") ~ "#008000",  
      variable %in% c("Desulfobacterota.E") ~ "#38b000",  
      variable %in% c("Desulfobacterota") ~ "#70e000",  
      variable %in% c("Desulfobacterota.G") ~ "#9ef01a",  
      variable %in% c("Desulfobacterota.C") ~ "#ccff33",  
      variable %in% c("Halobacteriota") ~ "#f95738",  
      TRUE ~ "grey90"  
    )  
  )  

# Create color vector  
color_vector <- setNames(color_map$color, color_map$variable)  


# Enhanced ggplot with more customization  
gy21_hgcA_barplot <-   
  ggplot(total_hgcA_taxonomic.m, aes(x = day, fill = variable, y = value)) +   
  geom_bar(stat = "identity",   
           color = "black",  # Black border for all bars  
           width = 0.75,   
           size = 0.3) +  
  scale_fill_manual(values = color_vector) +  
  theme_minimal() +  
  theme(  
    axis.text.x = element_text(  
      angle = 90,   
      size = 10,   
      colour = "black",   
      vjust = 0.5,   
      hjust = 0.5  
    ),   
    axis.title.x = element_text(size = 12),   
    axis.title.y = element_text(size = 12, face = "bold"),   
    legend.title = element_text(size = 9, face = "bold"),   
    legend.text = element_text(size = 10, colour = "black"),   
    axis.text.y = element_text(colour = "black", size = 10),  
    legend.key.size = unit(0.3, 'cm'),  
    strip.text.x = element_blank(),  
    legend.position = "right"  
  ) +  
  labs(  
    y = "% total reads normalised by HMM length",   
    x = "",   
    fill = "Phylum"  
  ) +   
  facet_grid(site ~ type, space = "free_x", scales = "free_x") +   
  guides(fill = guide_legend(ncol = 1))  


# Modify the strip labels to show 'Site' only once
gy21_hgcA_barplot <- gy21_hgcA_barplot + 
  theme(strip.text.x = element_text(face = "bold"),
        strip.text.y = element_text(face = "bold"),
        strip.background = element_rect(colour = "white", fill = "white"))


gy21_hgcA_barplot

ggsave("output/hgcA_taxonomy_barplot.pdf", width = 7, height=6, units = "in")


```

## total hgcA taxonomic distribution - modified
###  modified means the taxonmy is classified to family level, and SRB, IRB, methanogens reclassified. 
```r
library(tidyr)  
library(reshape2)  

# Read data  
total_hgcA <- read.csv("data/gy21_geochemical/total_hgcA_data_modified.csv", header = TRUE)  

# Remove specified columns  
total_hgcA_taxonomic <- total_hgcA[, -c(1, 3, 5, 7)]  

total_hgcA$site <- factor(total_hgcA$site, levels = c("HX", "GX", "SK"))
total_hgcA$type <- factor(total_hgcA$type, levels = c("Surface", "Rhizosphere"))

# melt
total_hgcA_taxonomic.m <- total_hgcA_taxonomic %>%  
  pivot_longer(  
    cols = -c(day, site, type),  # All columns except these  
    names_to = "variable",   
    values_to = "value"  
  )  

# Factor ordering (more concise method)  
total_hgcA_taxonomic.m <- total_hgcA_taxonomic.m %>%  
  mutate(  
    day = factor(day, levels = unique(day)),  
    site = factor(site, levels = unique(site)),  
    variable = factor(variable, levels = unique(variable))  ,
    type = factor(type, levels = c("Surface", "Rhizosphere"))
  )  


# define colors
# IRB Group (Cool Blues)  
colors <- c(  
  # IRB
  "Deferrimicrobiaceae" = "skyblue",   
  "Geoalkalibacteraceae" = "royalblue",   
  "Geobacteraceae" = "steelblue",
  # SRB
"Desulfatiglandaceae" = "darkgreen",   
  "Desulfobulbaceae" = "forestgreen",   
  "Desulfocapsaceae" = "limegreen",   
  "Desulfomonilaceae" = "seagreen",   
  "Desulfosalsimonadaceae" = "mediumseagreen",   
  "Desulfovibrionaceae" = "olivedrab",   
  "Desulfurivibrionaceae" = "yellowgreen",

  # Methanogens Group (Warm Oranges/Reds)  
  "Methanocellaceae" = "coral",   
  "Methanomassiliicoccaceae" = "tomato",   
  "Methanomicrobiaceae" = "orangered",   
  "Methanoperedenaceae" = "darkorange",   
  "Methanoregulaceae" = "salmon",   
  "Methanosarcinaceae" = "indianred",   
  "Methanosphaerulaceae" = "lightcoral",   
  "Methanospirillaceae" = "firebrick",

  # Syntrophs Group (Purples)  
  "Smithellaceae" = "mediumpurple",   
  "Syntrophaceae" = "purple",   
  "Syntrophobacteraceae" = "darkorchid",
  
  # Others
  "Others" = "grey80"
)  

# Enhanced ggplot with more customization  
gy21_hgcA_barplot <-   
  ggplot(total_hgcA_taxonomic.m, aes(x = day, fill = variable, y = value)) +   
  geom_bar(stat = "identity",   
           color = "transparent",  # Black border for all bars  
           width = 0.75,   
           size = 0.3) +  
  scale_fill_manual(values = colors) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),   # Remove major grid lines  
    axis.text.x = element_text(  
      angle = 90,   
      size = 10,   
      colour = "black",   
      vjust = 0.5,   
      hjust = 0.5  
    ),   
    axis.title.x = element_text(size = 10),   
    axis.title.y = element_text(size = 10),   
    legend.title = element_text(size = 10, face="bold"),   
    legend.text = element_text(size = 10, colour = "black"),   
    axis.text.y = element_text(colour = "black", size = 10),  
    legend.key.size = unit(0.25, 'cm'),  
    strip.text.x = element_text(size = 10),  # Instead, add this to style type labels  
    strip.text.y = element_text(size = 10),  # Style site labels     
    legend.position = "bottom"  
  ) +  
  labs(  
    y = "% total reads normalised by HMM length",   
    x = "Days after rice planting",   
    fill = "Family"  
  ) +   
  facet_grid(site ~ type, space = "free_x", scales = "free_x") +   
  guides(fill = guide_legend(ncol = 3))  


# Modify the strip labels to show 'Site' only once
gy21_hgcA_barplot <- gy21_hgcA_barplot + 
  theme(strip.background = element_rect(colour = "white", fill = "white"))


gy21_hgcA_barplot

ggsave("output/hgcA_taxonomy_barplot-modified.pdf", width = 5, height=8, units = "in")


```

### hgcA taxoomic distribution - modified 20250808
```r
library(tidyr)  
library(reshape2)  
library(ggplot2)  # Add this if not already loaded

# Read data  
total_hgcA <- read.csv("data/gy21_geochemical/total_hgcA_data_modified.csv", header = TRUE)  

# Set factor levels FIRST
total_hgcA$site <- factor(total_hgcA$site, levels = c("HX", "GX", "SK"))
total_hgcA$type <- factor(total_hgcA$type, levels = c("Surface", "Rhizosphere"))

# Remove columns 1, 3, 5, 7 and the last 4 columns
# Get total number of columns
ncol_total <- ncol(total_hgcA)
cols_to_remove <- c(1, 3, 5, 7, (ncol_total-4):ncol_total)
total_hgcA_taxonomic <- total_hgcA[, -cols_to_remove]

# melt
total_hgcA_taxonomic.m <- total_hgcA_taxonomic %>%  
  pivot_longer(  
    cols = -c(day, site, type),  # All columns except these  
    names_to = "variable",   
    values_to = "value"  
  )  

# Factor ordering (preserve the original levels)  
total_hgcA_taxonomic.m <- total_hgcA_taxonomic.m %>%  
  mutate(  
    day = factor(day, levels = unique(day)),  
    variable = factor(variable, levels = unique(variable))
    # site and type already properly factored above
  )  

# define colors
colors <- c(  
  # IRB
  "Deferrimicrobiaceae" = "skyblue",   
  "Geoalkalibacteraceae" = "royalblue",   
  "Geobacteraceae" = "steelblue",
  # SRB
  "Desulfatiglandaceae" = "darkgreen",   
  "Desulfobulbaceae" = "forestgreen",   
  "Desulfocapsaceae" = "limegreen",   
  "Desulfomonilaceae" = "seagreen",   
  "Desulfosalsimonadaceae" = "mediumseagreen",   
  "Desulfovibrionaceae" = "olivedrab",   
  "Desulfurivibrionaceae" = "yellowgreen",
  # Methanogens Group (Warm Oranges/Reds)  
  "Methanocellaceae" = "coral",   
  "Methanomassiliicoccaceae" = "tomato",   
  "Methanomicrobiaceae" = "orangered",   
  "Methanoperedenaceae" = "darkorange",   
  "Methanoregulaceae" = "salmon",   
  "Methanosarcinaceae" = "indianred",   
  "Methanosphaerulaceae" = "lightcoral",   
  "Methanospirillaceae" = "firebrick",
  # Syntrophs Group (Purples)  
  "Smithellaceae" = "mediumpurple",   
  "Syntrophaceae" = "purple",   
  "Syntrophobacteraceae" = "darkorchid"
  # Others
)  

# Enhanced ggplot with corrected settings  
gy21_hgcA_barplot <-   
  ggplot(total_hgcA_taxonomic.m, aes(x = day, fill = variable, y = value)) +   
  geom_bar(stat = "identity",   
           color = "transparent",  
           width = 0.75,   
           size = 0.3) +  
  scale_fill_manual(values = colors) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),   # Remove major grid lines  
    panel.grid.minor = element_blank(),   # Remove minor grid lines  
    axis.text.x = element_text(  
      angle = 90,   
      size = 10,   
      colour = "black",   
      vjust = 0.5,   
      hjust = 0.5  
    ),   
    axis.title.x = element_text(size = 10),   
    axis.title.y = element_text(size = 10),   
    legend.title = element_text(size = 10, face="bold"),   
    legend.text = element_text(size = 11, colour = "black"),   # Fixed size from 100 to 10
    axis.text.y = element_text(colour = "black", size = 10),  
    legend.key.size = unit(0.25, 'cm'),  
    strip.text.x = element_text(size = 10),    
    strip.text.y = element_text(size = 10),     
    strip.background = element_rect(colour = "white", fill = "white"),
    legend.position = "bottom"  
  ) +  
  labs(  
    y = "% total reads normalised by HMM length",   
    x = "Days after rice planting",   
    fill = "Family"  
  ) +   
  facet_grid(site ~ type, space = "free_x", scales = "free_x") +   
  guides(fill = guide_legend(ncol = 3))  

gy21_hgcA_barplot


```


## mean hgcA and sd across sites
```r
total_hgcA <- read.csv("data/gy21_geochemical/total_hgcA_data_modified.csv", header = TRUE)  

# Remove specified columns  
total_hgcA_taxonomic <- total_hgcA[, -c(1, 3, 5, 7)]  

total_hgcA$site <- factor(total_hgcA$site, levels = c("HX", "GX", "SK"))
total_hgcA$type <- factor(total_hgcA$type, levels = c("Surface", "Rhizosphere"))

# Calculate average overall_hgcA and sd value at each site  
average_hgcA <- total_hgcA %>%  
  group_by(site) %>%              # Group by site  
  summarise(  
    mean_overall_hgcA = mean(Overall, na.rm = TRUE),  # Calculate mean  
    sd_overall_hgcA = sd(Overall, na.rm = TRUE),      # Calculate standard deviation  
    sample_size = n()
  )  
average_hgcA

```

## mean mcrA and pmoA/mmoX and sd across sites
```r
total_methane <- read.csv("data/gy21_geochemical/methanogen_methanotroph_data.csv", header = TRUE)  

# Remove specified columns  

total_methane$site <- factor(total_methane$site, levels = c("HX", "GX", "SK"))
total_methane$type <- factor(total_methane$type, levels = c("Surface", "Rhizosphere"))

# Calculate average overall_mcrA and sd value at each site  
average_mcrA <- total_methane %>%  
  group_by(site) %>%              # Group by site  
  summarise(  
    mean_overall_mcrA = mean(methanogen_overall, na.rm = TRUE),  # Calculate mean  
    sd_overall_mcrA = sd(methanogen_overall, na.rm = TRUE),      # Calculate standard deviation  
    sample_size = n()
  )  
average_mcrA

# Calculate average overall_pmoA/mmoX and sd value at each site  
average_pmoAmmoX <- total_methane %>%  
  group_by(site) %>%              # Group by site  
  summarise(  
    mean_overall_pmoAmmoX = mean(aerobic_methanotroph_overall, na.rm = TRUE),  # Calculate mean  
    sd_overall_pmoAmmoX = sd(aerobic_methanotroph_overall, na.rm = TRUE),      # Calculate standard deviation  
    sample_size = n()
  )  
average_pmoAmmoX

# Combine the two summary data frames by site  
summary_table <- average_mcrA %>%  
  inner_join(average_pmoAmmoX, by = "site") %>%  
  select(  
    site,  
    mean_overall_mcrA,  
    sd_overall_mcrA,  
    mean_overall_pmoAmmoX,  
    sd_overall_pmoAmmoX,  
  )  

# Print the summary table  
print(summary_table)  


```

## mean mbnT and sd across sites
```r
total_mbnT <- read.csv("data/gy21_geochemical/methanotroph_mbnT.csv", header = TRUE)  

# Remove specified columns  

total_mbnT$site <- factor(total_mbnT$site, levels = c("HX", "GX", "SK"))
total_mbnT$type <- factor(total_mbnT$type, levels = c("Surface", "Rhizosphere"))

# Calculate average overall_hgcA and sd value at each site  
average_mbnT <- total_mbnT %>%  
  group_by(site) %>%              # Group by site  
  summarise(  
    mean_overall_hgcA = mean(overall, na.rm = TRUE),  # Calculate mean  
    sd_overall_hgcA = sd(overall, na.rm = TRUE),      # Calculate standard deviation  
    sample_size = n()
  )  
average_mbnT

```

## methanogen hgcA
```r

# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
methanogen_hgcA <- read.csv("data/gy21_geochemical/methanogen_hgcA_data.csv", header = TRUE)

# format the date variable in the dataframe
methanogen_hgcA$date <- factor(methanogen_hgcA$date, levels=unique(methanogen_hgcA$date))
methanogen_hgcA$date <- as.Date(methanogen_hgcA$date, format="%Y/%m/%d")

# set site order in the plot
methanogen_hgcA$site <- factor(methanogen_hgcA$site, levels = c("HX", "GX", "SK"))

# filter data
methanogen_hgcA_surface <- methanogen_hgcA %>%
  filter(type == 'Surface')

methanogen_hgcA_rhizosphere <- methanogen_hgcA %>%
  filter(type == 'Rhizosphere')

# plot overall fluctuation
(p1 <- ggplot(methanogen_hgcA_surface, aes(y = overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "methanogen hgcA (% of total reads \n normalized by HMM length)", color = "Site") +
  ylim(0, 3E-8) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


(p2 <- ggplot(methanogen_hgcA_rhizosphere, aes(y = overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 3E-8) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


combine1 <- p1 + p2 + plot_layout(widths = c(1.4, 1))
combine1


ggsave("output/methanogen_hgcA.pdf", width = 25, height = 8, units = "cm")

```

## SRB hgcA 
```r
# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
total_hgcA <- read.csv("data/gy21_geochemical/total_hgcA_data.csv", header = TRUE)

# format the date variable in the dataframe
total_hgcA$date <- factor(total_hgcA$date, levels=unique(total_hgcA$date))
total_hgcA$date <- as.Date(total_hgcA$date, format="%Y/%m/%d")

# set site order in the plot
total_hgcA$site <- factor(total_hgcA$site, levels = c("HX", "GX", "SK"))

# filter data
total_hgcA_surface <- total_hgcA %>%
  filter(type == 'Surface')

total_hgcA_rhizosphere <- total_hgcA %>%
  filter(type == 'Rhizosphere')

# plot overall fluctuation
(p1 <- ggplot(total_hgcA_surface, aes(y = overall_SRB, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "total hgcA (% of total reads \n normalized by HMM length)", color = "Site") +
  ylim(0, 9E-8) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


(p2 <- ggplot(total_hgcA_rhizosphere, aes(y = overall_SRB, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 9E-8) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


combine1 <- p1 + p2 + plot_layout(widths = c(1.4, 1))
combine1


ggsave("output/SRB_hgcA.pdf", width = 25, height = 8, units = "cm")
```

## total merB
```r

# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
total_merB <- read.csv("data/gy21_geochemical/total_merB_data.csv", header = TRUE)

# format the date variable in the dataframe
total_merB$date <- factor(total_merB$date, levels=unique(total_merB$date))
total_merB$date <- as.Date(total_merB$date, format="%Y/%m/%d")

# set site order in the plot
total_merB$site <- factor(total_merB$site, levels = c("HX", "GX", "SK"))

# filter data
total_merB_surface <- total_merB %>%
  filter(type == 'Surface')

total_merB_rhizosphere <- total_merB %>%
  filter(type == 'Rhizosphere')

# plot overall fluctuation
(p1 <- ggplot(total_merB_surface, aes(y = overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "total merB (% of total reads \n normalized by HMM length)", color = "Site") +
  ylim(0, 6E-7) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


(p2 <- ggplot(total_merB_rhizosphere, aes(y = overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 6E-7) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


combine1 <- p1 + p2 + plot_layout(widths = c(1.4, 1))
combine1


ggsave("output/total_merB.pdf", width = 25, height = 8, units = "cm")

```

## mean merB and sd across sites
```r
total_merB <- read.csv("data/gy21_geochemical/total_merB_data.csv", header = TRUE)

total_merB$site <- factor(total_merB$site, levels = c("HX", "GX", "SK"))
total_merB$type <- factor(total_merB$type, levels = c("Surface", "Rhizosphere"))

# Calculate average overall_hgcA and sd value at each site  
average_merB <- total_merB %>%  
  group_by(site, type) %>%              # Group by site  
  summarise(  
    mean_overall_merB = mean(overall, na.rm = TRUE),  # Calculate mean  
    sd_overall_merB = sd(overall, na.rm = TRUE),      # Calculate standard deviation  
    sample_size = n()
  )  
average_merB

```

## methanotroph mbnT
```r

# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
methanotroph_mbnT <- read.csv("data/gy21_geochemical/methanotroph_mbnT.csv", header = TRUE)

# format the date variable in the dataframe
methanotroph_mbnT$date <- factor(methanotroph_mbnT$date, levels=unique(methanotroph_mbnT$date))
methanotroph_mbnT$date <- as.Date(methanotroph_mbnT$date, format="%Y/%m/%d")

# set site order in the plot
methanotroph_mbnT$site <- factor(methanotroph_mbnT$site, levels = c("HX", "GX", "SK"))

# filter data
methanotroph_mbnT_surface <- methanotroph_mbnT %>%
  filter(type == 'Surface')

methanotroph_mbnT_rhizosphere <- methanotroph_mbnT %>%
  filter(type == 'Rhizosphere')

# plot overall fluctuation
(p1 <- ggplot(methanotroph_mbnT_surface, aes(y = overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "methanotroph mbnT (% of total reads \n normalized by HMM length)", color = "Site") +
  ylim(0, 2E-8) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


(p2 <- ggplot(methanotroph_mbnT_rhizosphere, aes(y = overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 2E-8) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


combine1 <- p1 + p2 + plot_layout(widths = c(1.4, 1))
combine1


ggsave("output/methanotroph_mbnT.pdf", width = 25, height = 8, units = "cm")

```

## methanogen mcrA
```r

# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
methanotroph_mbnT <- read.csv("data/gy21_geochemical/methanotroph_mbnT.csv", header = TRUE)

# format the date variable in the dataframe
methanotroph_mbnT$date <- factor(methanotroph_mbnT$date, levels=unique(methanotroph_mbnT$date))
methanotroph_mbnT$date <- as.Date(methanotroph_mbnT$date, format="%Y/%m/%d")

# set site order in the plot
methanotroph_mbnT$site <- factor(methanotroph_mbnT$site, levels = c("HX", "GX", "SK"))

# filter data
methanotroph_mbnT_surface <- methanotroph_mbnT %>%
  filter(type == 'Surface')

methanotroph_mbnT_rhizosphere <- methanotroph_mbnT %>%
  filter(type == 'Rhizosphere')

# plot overall fluctuation
(p1 <- ggplot(methanotroph_mbnT_surface, aes(y = overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "methanotroph mbnT (% of total reads \n normalized by HMM length)", color = "Site") +
  ylim(0, 2E-8) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


(p2 <- ggplot(methanotroph_mbnT_rhizosphere, aes(y = overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 2E-8) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


combine1 <- p1 + p2 + plot_layout(widths = c(1.4, 1))
combine1


ggsave("output/methanotroph_mbnT.pdf", width = 25, height = 8, units = "cm")

```

## ANME methanotroph mcrA
```r

# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
ANME <- read.csv("data/gy21_geochemical/methanogen_methanotroph_data.csv", header = TRUE)

# format the date variable in the dataframe
ANME$date <- factor(ANME$date, levels=unique(ANME$date))
ANME$date <- as.Date(ANME$date, format="%Y/%m/%d")

# set site order in the plot
ANME$site <- factor(ANME$site, levels = c("HX", "GX", "SK"))

# filter data
ANME_surface <- ANME %>%
  filter(type == 'Surface')

ANME_rhizosphere <- ANME %>%
  filter(type == 'Rhizosphere')

# plot overall fluctuation
(ANME_p1 <- ggplot(ANME_surface, aes(y = Methanoperedenaceae, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "Methanoperedenaceae mcrA (% of total reads \n normalized by HMM length)", color = "Site") +
  ylim(0, 2E-8) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


(ANME_p2 <- ggplot(ANME_rhizosphere, aes(y = Methanoperedenaceae, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 2E-8) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


ANME_combine1 <- ANME_p1 + ANME_p2 + plot_layout(widths = c(1.4, 1))

ANME_combine1

ggsave("output/Methanoperedenaceae_mcrA.pdf", width = 25, height = 8, units = "cm")

```

## methanogen and methanotroph fluctuation data
```r

# load package
library(dplyr)
library(ggplot2)
library(patchwork)

# load data
methane_cycling_taxa <- read.csv("data/gy21_geochemical/methanogen_methanotroph_data.csv", header = TRUE)

# format the date variable in the dataframe
methane_cycling_taxa$date <- factor(methane_cycling_taxa$date, levels=unique(methane_cycling_taxa$date))
methane_cycling_taxa$date <- as.Date(methane_cycling_taxa$date, format="%Y/%m/%d")

# set site order in the plot
methane_cycling_taxa$site <- factor(methane_cycling_taxa$site, levels = c("HX", "GX", "SK"))

# filter data
methane_cycling_taxa_surface <- methane_cycling_taxa %>%
  filter(type == 'Surface')

methane_cycling_taxa_rhizosphere <- methane_cycling_taxa %>%
  filter(type == 'Rhizosphere')

# plot overall fluctuation
(p1 <- ggplot(methane_cycling_taxa_surface, aes(y = aerobic_methanotroph_overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = "aerobic methanotroph pmoA/mmoX (% of total \n reads normalized by HMM length)", color = "Site") +
  ylim(0, 3.5E-8) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


(p2 <- ggplot(methane_cycling_taxa_rhizosphere, aes(y = aerobic_methanotroph_overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 3.5E-8) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


combine1 <- p1 + p2 + plot_layout(widths = c(1.4, 1))
combine1


ggsave("output/aerobic_methanotroph.pdf", width = 25, height = 8, units = "cm")



# plot overall fluctuation
(p3 <- ggplot(methane_cycling_taxa_surface, aes(y = methanogen_overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")) + # Corrected line
  labs(x = "", y = " methanogen mcrA (% of total reads \n normalized by HMM length)", color = "Site") +
  ylim(0, 2.5E-7) + 
  theme_minimal() + 
  theme(legend.position = "NA",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black"),
        ) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


(p4 <- ggplot(methane_cycling_taxa_rhizosphere, aes(y = methanogen_overall, x = day, color = site)) +
  geom_point() +
  scale_color_manual(values = c("#f35d36", "#ffba1b", "#60cfa1")) + # Change colors as needed
  labs(x = "", y = "", color = "Site") +
  ylim(0, 2.5E-7) + 
  theme_minimal() + 
  theme(legend.position = "right",
        panel.border = element_rect(linetype = "solid", color = "black", fill="NA", size = 1),
        text = element_text(color = "black")) + 
  geom_smooth(span = 0.7,se = FALSE, alpha = 0.3))


combine2 <- p3 + p4 + plot_layout(widths = c(1.4, 1))
combine2


ggsave("output/methanogen.pdf", width = 25, height = 8, units = "cm")

```

## methanogen taxonomic distribution
```r
library(tidyr)  
library(reshape2)  

# Read data  
methanogen_taxonomic <- read.csv("data/gy21_geochemical/methanogen_methanotroph_data.csv", header = TRUE)  

# Remove specified columns  
methanogen_taxonomic <- methanogen_taxonomic[, -c(1, 3, 5, 7:15)]  

methanogen_taxonomic$site <- factor(methanogen_taxonomic$site, levels = c("HX", "GX", "SK"))
methanogen_taxonomic$type <- factor(methanogen_taxonomic$type, levels = c("Surface", "Rhizosphere"))

# melt
methanogen_taxonomic.m <- methanogen_taxonomic %>%  
  pivot_longer(  
    cols = -c(day, site, type),  # All columns except these  
    names_to = "variable",   
    values_to = "value"  
  )  

# Factor ordering (more concise method)  
methanogen_taxonomic.m <- methanogen_taxonomic.m %>%  
  mutate(  
    day = factor(day, levels = unique(day)),  
    site = factor(site, levels = unique(site)),  
    variable = factor(variable, levels = unique(variable))  ,
    type = factor(type, levels = c("Surface", "Rhizosphere"))
  )  


# define colors
colors <- c(  
  "Methanoregulaceae"        = "#e1a5c7",  # Light purple  
  "Methanotrichaceae"        = "#cbb5d5",  
  "Methanosphaerulaceae"     = "#b4c4e3",  
  "Methanobacteriaceae"      = "#9cd3f0",  
  "Methanocellaceae"         = "#83c0e6",  
  "Methanosarcinaceae"       = "#6baed6",  
  "uc_Methanomicrobiales"    = "#5893d0",  
  "Methanocorpusculaceae"    = "#447ab7",  
  "Methanomassiliicoccaceae" = "#30619e",  
  "Methanofastidiosaceae"    = "#1c4884",  
  "Methanofollaceae"         = "#08306b"   # Darkest blue  
)  

# Enhanced ggplot with more customization  
gy21_methanogen_barplot <-   
  ggplot(methanogen_taxonomic.m, aes(x = day, fill = variable, y = value)) +   
  geom_bar(stat = "identity",   
           color = "transparent",  # Black border for all bars  
           width = 0.75,   
           size = 0.3) +  
  geom_smooth(  
    data = methanogen_taxonomic.m %>%   
      group_by(day, site, type) %>%   
      summarize(total = sum(value), .groups = "drop"),  
    aes(x = day, y = total, group = interaction(site, type)),  
    inherit.aes = FALSE,  
    method = "loess", # or "lm" for a straight line  
    se = FALSE,       # no confidence interval  
    color = "grey60",  # black trend line  
    linewidth = 0.6,  # slightly thicker line  
    linetype = "solid"  
  ) +
  scale_fill_manual(values = colors) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),   # Remove major grid lines  
    axis.text.x = element_text(  
      angle = 90,   
      size = 10,   
      colour = "black",   
      vjust = 0.5,   
      hjust = 0.5  
    ),   
    axis.title.x = element_text(size = 10),   
    axis.title.y = element_text(size = 10),   
    legend.title = element_text(size = 7, face="bold"),   
    legend.text = element_text(size = 7, colour = "black"),   
    axis.text.y = element_text(colour = "black", size = 10),  
    legend.key.size = unit(0.25, 'cm'),  
    strip.text.x = element_text(size = 10),  # Instead, add this to style type labels  
    strip.text.y = element_text(size = 10),  # Style site labels     
    legend.position = "bottom"  
  ) +  
  labs(  
    y = "% total reads normalised by HMM length",   
    x = "Days post rice plantation",   
    fill = "Family"  
  ) +   
  facet_grid(site ~ type, space = "free_x", scales = "free_x") +   
  guides(fill = guide_legend(ncol = 3))  


gy21_methanogen_barplot

# Modify the strip labels to show 'Site' only once
gy21_methanogen_barplot <- gy21_methanogen_barplot + 
  theme(strip.background = element_rect(colour = "white", fill = "white"))

ggsave("output/methanogen_taxonomy_barplot.pdf", width = 5, height=8, units = "in")
```

## methanogen taxonomic distribution - 20250806
```r

library(tidyr)  
library(reshape2)  

# Read data  
methanogen_taxonomic <- read.csv("data/gy21_geochemical/methanogen_methanotroph_data.csv", header = TRUE)  

# Remove specified columns  
methanogen_taxonomic <- methanogen_taxonomic[, -c(1, 3, 5, 7:15)]  

methanogen_taxonomic$site <- factor(methanogen_taxonomic$site, levels = c("HX", "GX", "SK"))
methanogen_taxonomic$type <- factor(methanogen_taxonomic$type, levels = c("Surface", "Rhizosphere"))

# melt
methanogen_taxonomic.m <- methanogen_taxonomic %>%  
  pivot_longer(  
    cols = -c(day, site, type),  # All columns except these  
    names_to = "variable",   
    values_to = "value"  
  )  

# Factor ordering (more concise method)  
methanogen_taxonomic.m <- methanogen_taxonomic.m %>%  
  mutate(  
    day = factor(day, levels = unique(day)),  
    site = factor(site, levels = unique(site)),  
    variable = factor(variable, levels = unique(variable)) ,
    type = factor(type, levels = c("Surface", "Rhizosphere"))
  )  

# define colors
colors <- c(  
  "Methanoregulaceae"        = "#e1a5c7",  # Light purple  
  "Methanotrichaceae"        = "#cbb5d5",  
  "Methanosphaerulaceae"     = "#b4c4e3",  
  "Methanobacteriaceae"      = "#9cd3f0",  
  "Methanocellaceae"         = "#83c0e6",  
  "Methanosarcinaceae"       = "#6baed6",  
  "uc_Methanomicrobiales"    = "#5893d0",  
  "Methanocorpusculaceae"    = "#447ab7",  
  "Methanomassiliicoccaceae" = "#30619e",  
  "Methanofastidiosaceae"    = "#1c4884",  
  "Methanofollaceae"         = "#08306b"   # Darkest blue  
)  

# Enhanced ggplot with more customization  
gy21_methanogen_barplot <-   
  ggplot(methanogen_taxonomic.m, aes(x = day, fill = variable, y = value)) +   
  geom_bar(stat = "identity",   
           color = "transparent",  # Black border for all bars  
           width = 0.75,   
           size = 0.3) +  
  geom_smooth(  
    data = methanogen_taxonomic.m %>%   
      group_by(day, site, type) %>%   
      summarize(total = sum(value), .groups = "drop"),  
    aes(x = day, y = total, group = interaction(site, type)),  
    inherit.aes = FALSE,  
    method = "loess", # or "lm" for a straight line  
    se = FALSE,       # no confidence interval  
    color = "grey60",  # black trend line  
    linewidth = 0.6,  # slightly thicker line  
    linetype = "solid"  
  ) +
  scale_fill_manual(values = colors) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),   # Remove major grid lines  
    axis.text.x = element_text(  
      angle = 90,   
      size = 10,   
      colour = "black",   
      vjust = 0.5,   
      hjust = 0.5  
    ),   
    axis.title.x = element_text(size = 10),   
    axis.title.y = element_text(size = 10),   
    legend.title = element_text(size = 12, face="bold"),   # Increased from 7 to 12
    legend.text = element_text(size = 10, colour = "black"),   # Increased from 7 to 10
    axis.text.y = element_text(colour = "black", size = 10),  
    legend.key.size = unit(0.5, 'cm'),  # Increased from 0.25 to 0.5
    strip.text.x = element_text(size = 10),  # Instead, add this to style type labels  
    strip.text.y = element_text(size = 10),  # Style site labels     
    legend.position = "bottom",
    strip.background = element_rect(colour = "white", fill = "white")  # Moved here
  ) +  
  labs(  
    y = "% total reads normalised by HMM length",   
    x = "Days post rice plantation", 
    fill = NULL
  ) +   
  facet_grid(site ~ type, space = "free_x", scales = "free_x") +   
  guides(fill = guide_legend(ncol = 2))  # Changed from 3 to 2 columns

gy21_methanogen_barplot

ggsave("output/methanogen_taxonomy_barplot_20250806.pdf", width = 5, height=8, units = "in")

```

## methanotroph taxonomic distribution
```r
library(tidyr)  
library(reshape2)  

# Read data  
methanotroph_taxonomic <- read.csv("data/gy21_geochemical/methanogen_methanotroph_data.csv", header = TRUE)  

# Remove specified columns  
methanotroph_taxonomic <- methanotroph_taxonomic[, -c(1, 3, 5, 7,8,15:26)]  

methanotroph_taxonomic$site <- factor(methanotroph_taxonomic$site, levels = c("HX", "GX", "SK"))
methanotroph_taxonomic$type <- factor(methanotroph_taxonomic$type, levels = c("Surface", "Rhizosphere"))

# melt
methanotroph_taxonomic.m <- methanotroph_taxonomic %>%  
  pivot_longer(  
    cols = -c(day, site, type),  # All columns except these  
    names_to = "variable",   
    values_to = "value"  
  )  

# Factor ordering (more concise method)  
methanotroph_taxonomic.m <- methanotroph_taxonomic.m %>%  
  mutate(  
    day = factor(day, levels = unique(day)),  
    site = factor(site, levels = unique(site)),  
    variable = factor(variable, levels = unique(variable))  ,
    type = factor(type, levels = c("Surface", "Rhizosphere"))
  )  


methylotroph_colors <- c(  
  "Methylomonadaceae"   = "#c7eae5",  # Light gray-white  
  "Beijerinckiaceae"    = "#80cdc1",  
  "Methylococcaceae"    = "#35978f",  
  "Methyloligellaceae"  = "#01665e",  
  "Burkholderiaceae.B"  = "#003c30",  
  "Methylophilaceae"    = "#001a15"   # Darkest teal  
)  


# Enhanced ggplot with more customization  
gy21_methanotroph_barplot <-   
  ggplot(methanotroph_taxonomic.m, aes(x = day, fill = variable, y = value)) +   
  geom_bar(stat = "identity",   
           color = "transparent",  # Black border for all bars  
           width = 0.75,   
           size = 0.3) +  
  geom_smooth(  
    data = methanotroph_taxonomic.m %>%   
      group_by(day, site, type) %>%   
      summarize(total = sum(value), .groups = "drop"),  
    aes(x = day, y = total, group = interaction(site, type)),  
    inherit.aes = FALSE,  
    method = "loess", # or "lm" for a straight line  
    se = FALSE,       # no confidence interval  
    color = "grey60",  # black trend line  
    linewidth = 0.6,  # slightly thicker line  
    linetype = "solid"  
  ) +
  scale_fill_manual(values = methylotroph_colors) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),   # Remove major grid lines  
    axis.text.x = element_text(  
      angle = 90,   
      size = 10,   
      colour = "black",   
      vjust = 0.5,   
      hjust = 0.5  
    ),   
    axis.title.x = element_text(size = 10),   
    axis.title.y = element_text(size = 10),   
    legend.title = element_text(size = 7, face="bold"),   
    legend.text = element_text(size = 7, colour = "black"),   
    axis.text.y = element_text(colour = "black", size = 10),  
    legend.key.size = unit(0.25, 'cm'),  
    strip.text.x = element_text(size = 10),  # Instead, add this to style type labels  
    strip.text.y = element_text(size = 10),  # Style site labels     
    legend.position = "bottom"  
  ) +  
  labs(  
    y = "% total reads normalised by HMM length",   
    x = "Days post rice plantation",   
    fill = "Family"  
  ) +   
  facet_grid(site ~ type, space = "free_x", scales = "free_x") +   
  guides(fill = guide_legend(ncol = 2))  


# Modify the strip labels to show 'Site' only once
gy21_methanotroph_barplot <- gy21_methanotroph_barplot + 
  theme(strip.background = element_rect(colour = "white", fill = "white"))

ggsave("output/methanotroph_taxonomy_barplot.pdf", width = 5, height=8, units = "in")
```

## methanotroph taxonomic distribution - 20250806
```r
library(tidyr)  
library(reshape2)  

# Read data  
methanotroph_taxonomic <- read.csv("data/gy21_geochemical/methanogen_methanotroph_data.csv", header = TRUE)  

# Remove specified columns  
methanotroph_taxonomic <- methanotroph_taxonomic[, -c(1, 3, 5, 7,8,15:26)]  

methanotroph_taxonomic$site <- factor(methanotroph_taxonomic$site, levels = c("HX", "GX", "SK"))
methanotroph_taxonomic$type <- factor(methanotroph_taxonomic$type, levels = c("Surface", "Rhizosphere"))

# melt
methanotroph_taxonomic.m <- methanotroph_taxonomic %>%  
  pivot_longer(  
    cols = -c(day, site, type),  # All columns except these  
    names_to = "variable",   
    values_to = "value"  
  )  

# Factor ordering (more concise method)  
methanotroph_taxonomic.m <- methanotroph_taxonomic.m %>%  
  mutate(  
    day = factor(day, levels = unique(day)),  
    site = factor(site, levels = unique(site)),  
    variable = factor(variable, levels = unique(variable)) ,
    type = factor(type, levels = c("Surface", "Rhizosphere"))
  )  

methylotroph_colors <- c(  
  "Methylomonadaceae"   = "#c7eae5",  # Light gray-white  
  "Beijerinckiaceae"    = "#80cdc1",  
  "Methylococcaceae"    = "#35978f",  
  "Methyloligellaceae"  = "#01665e",  
  "Burkholderiaceae.B"  = "#003c30",  
  "Methylophilaceae"    = "#001a15"   # Darkest teal  
)  

# Enhanced ggplot with more customization  
gy21_methanotroph_barplot <-   
  ggplot(methanotroph_taxonomic.m, aes(x = day, fill = variable, y = value)) +   
  geom_bar(stat = "identity",   
           color = "transparent",  # Black border for all bars  
           width = 0.75,   
           size = 0.3) +  
  geom_smooth(  
    data = methanotroph_taxonomic.m %>%   
      group_by(day, site, type) %>%   
      summarize(total = sum(value), .groups = "drop"),  
    aes(x = day, y = total, group = interaction(site, type)),  
    inherit.aes = FALSE,  
    method = "loess", # or "lm" for a straight line  
    se = FALSE,       # no confidence interval  
    color = "grey60",  # black trend line  
    linewidth = 0.6,  # slightly thicker line  
    linetype = "solid"  
  ) +
  scale_fill_manual(values = methylotroph_colors) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),   # Remove major grid lines  
    axis.text.x = element_text(  
      angle = 90,   
      size = 10,   
      colour = "black",   
      vjust = 0.5,   
      hjust = 0.5  
    ),   
    axis.title.x = element_text(size = 10),   
    axis.title.y = element_text(size = 10),   
    legend.title = element_text(size = 12, face="bold"),   # Increased from 7 to 12
    legend.text = element_text(size = 10, colour = "black"),   # Increased from 7 to 10
    axis.text.y = element_text(colour = "black", size = 10),  
    legend.key.size = unit(0.5, 'cm'),  # Increased from 0.25 to 0.5
    strip.text.x = element_text(size = 10),  # Instead, add this to style type labels  
    strip.text.y = element_text(size = 10),  # Style site labels     
    legend.position = "bottom",
    strip.background = element_rect(colour = "white", fill = "white")  # Moved here
  ) +  
  labs(  
    y = "% total reads normalised by HMM length",   
    x = "Days post rice plantation",   
    fill = NULL  
  ) +   
  facet_grid(site ~ type, space = "free_x", scales = "free_x") +   
  guides(fill = guide_legend(ncol = 2))  

gy21_methanotroph_barplot

ggsave("output/methanotroph_taxonomy_barplot_20250806.pdf", width = 5, height=8, units = "in")
```

## methanotroph mbnT taxonomic distribution
```r
library(tidyr)  
library(reshape2)  

# Read data  
methanotroph_mbnT_taxonomic <- read.csv("data/gy21_geochemical/methanotroph_mbnT.csv", header = TRUE)  

# Remove specified columns  
methanotroph_mbnT_taxonomic <- methanotroph_mbnT_taxonomic[, -c(1, 3, 5, 13)]  

methanotroph_mbnT_taxonomic$site <- factor(methanotroph_mbnT_taxonomic$site, levels = c("HX", "GX", "SK"))
methanotroph_mbnT_taxonomic$type <- factor(methanotroph_mbnT_taxonomic$type, levels = c("Surface", "Rhizosphere"))

# melt
methanotroph_mbnT_taxonomic.m <- methanotroph_mbnT_taxonomic %>%  
  pivot_longer(  
    cols = -c(day, site, type),  # All columns except these  
    names_to = "variable",   
    values_to = "value"  
  )  

# Factor ordering (more concise method)  
methanotroph_mbnT_taxonomic.m <- methanotroph_mbnT_taxonomic.m %>%  
  mutate(  
    day = factor(day, levels = unique(day)),  
    site = factor(site, levels = unique(site)),  
    variable = factor(variable, levels = unique(variable))  ,
    type = factor(type, levels = c("Surface", "Rhizosphere"))
  )  


methylotroph_colors <- c(  
  "Methylomonadaceae"   = "#c7eae5",  
  "Beijerinckiaceae"    = "#80cdc1",  
  "Methylococcaceae"    = "#35978f",  
  "Methyloligellaceae"  = "#01665e",  
  "Burkholderiaceae.B"  = "#003c30",  
  "Methylophilaceae"    = "#9eecb2",
  "Methylopilaceae"     = "#14743b",
  "Methylomirabilaceae" = "#349e31"
)  


# Enhanced ggplot with more customization  
gy21_methanotroph_barplot <-   
  ggplot(methanotroph_mbnT_taxonomic.m, aes(x = day, fill = variable, y = value)) +   
  geom_bar(stat = "identity",   
           color = "transparent",  # Black border for all bars  
           width = 0.75,   
           size = 0.3) +  
  geom_smooth(  
    data = methanotroph_mbnT_taxonomic.m %>%   
      group_by(day, site, type) %>%   
      summarize(total = sum(value), .groups = "drop"),  
    aes(x = day, y = total, group = interaction(site, type)),  
    inherit.aes = FALSE,  
    method = "loess", # or "lm" for a straight line  
    se = FALSE,       # no confidence interval  
    color = "grey60",  # black trend line  
    linewidth = 0.6,  # slightly thicker line  
    linetype = "solid"  
  ) +
  scale_fill_manual(values = methylotroph_colors) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),   # Remove major grid lines  
    axis.text.x = element_text(  
      angle = 90,   
      size = 10,   
      colour = "black",   
      vjust = 0.5,   
      hjust = 0.5  
    ),   
    axis.title.x = element_text(size = 10),   
    axis.title.y = element_text(size = 10),   
    legend.title = element_text(size = 7, face="bold"),   
    legend.text = element_text(size = 10, colour = "black"),   
    axis.text.y = element_text(colour = "black", size = 10),  
    legend.key.size = unit(0.25, 'cm'),  
    strip.text.x = element_text(size = 10),  # Instead, add this to style type labels  
    strip.text.y = element_text(size = 10),  # Style site labels     
    legend.position = "bottom"  
  ) +  
  labs(  
    y = "% total reads normalised by HMM length",   
    x = "Days post rice plantation",   
    fill = "Family"  
  ) +   
  facet_grid(site ~ type, space = "free_x", scales = "free_x") +   
  guides(fill = guide_legend(ncol = 2))  


# Modify the strip labels to show 'Site' only once
gy21_methanotroph_barplot <- gy21_methanotroph_barplot + 
  theme(strip.background = element_rect(colour = "white", fill = "white"))

ggsave("output/methanotroph_mbnT_taxonomy_barplot.pdf", width = 5, height=5, units = "in")
```

## methanotroph mbnT (TIBRFAM) taxonomic distribution
```r
library(tidyr)  
library(reshape2)  

# Read data  
methanotroph_mbnT_taxonomic <- read.csv("data/gy21_geochemical/methanotroph_mbnT_TIGRFAM.csv", header = TRUE)  

# Remove specified columns  
methanotroph_mbnT_taxonomic <- methanotroph_mbnT_taxonomic[, -c(1, 3, 5, 12)]  

methanotroph_mbnT_taxonomic$site <- factor(methanotroph_mbnT_taxonomic$site, levels = c("HX", "GX", "SK"))
methanotroph_mbnT_taxonomic$type <- factor(methanotroph_mbnT_taxonomic$type, levels = c("Surface", "Rhizosphere"))

# melt
methanotroph_mbnT_taxonomic.m <- methanotroph_mbnT_taxonomic %>%  
  pivot_longer(  
    cols = -c(day, site, type),  # All columns except these  
    names_to = "variable",   
    values_to = "value"  
  )  

# Factor ordering (more concise method)  
methanotroph_mbnT_taxonomic.m <- methanotroph_mbnT_taxonomic.m %>%  
  mutate(  
    day = factor(day, levels = unique(day)),  
    site = factor(site, levels = unique(site)),  
    variable = factor(variable, levels = unique(variable))  ,
    type = factor(type, levels = c("Surface", "Rhizosphere"))
  )  


methylotroph_colors <- c(  
  "Methylomonadaceae"   = "#c7eae5",  
  "Beijerinckiaceae"    = "#80cdc1",  
  "Methylococcaceae"    = "#35978f",  
  "Methylophilaceae"    = "#9eecb2",
  "Other" = "#349e31"
)  


# Enhanced ggplot with more customization  
gy21_methanotroph_barplot <-   
  ggplot(methanotroph_mbnT_taxonomic.m, aes(x = day, fill = variable, y = value)) +   
  geom_bar(stat = "identity",   
           color = "transparent",  # Black border for all bars  
           width = 0.75,   
           size = 0.3) +  
  geom_smooth(  
    data = methanotroph_mbnT_taxonomic.m %>%   
      group_by(day, site, type) %>%   
      summarize(total = sum(value), .groups = "drop"),  
    aes(x = day, y = total, group = interaction(site, type)),  
    inherit.aes = FALSE,  
    method = "loess", # or "lm" for a straight line  
    se = FALSE,       # no confidence interval  
    color = "grey60",  # black trend line  
    linewidth = 0.6,  # slightly thicker line  
    linetype = "solid"  
  ) +
  scale_fill_manual(values = methylotroph_colors) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),   # Remove major grid lines  
    axis.text.x = element_text(  
      angle = 90,   
      size = 10,   
      colour = "black",   
      vjust = 0.5,   
      hjust = 0.5  
    ),   
    axis.title.x = element_text(size = 10),   
    axis.title.y = element_text(size = 10),   
    legend.title = element_text(size = 7, face="bold"),   
    legend.text = element_text(size = 10, colour = "black"),   
    axis.text.y = element_text(colour = "black", size = 10),  
    legend.key.size = unit(0.25, 'cm'),  
    strip.text.x = element_text(size = 10),  # Instead, add this to style type labels  
    strip.text.y = element_text(size = 10),  # Style site labels     
    legend.position = "bottom"  
  ) +  
  labs(  
    y = "% total reads normalised by HMM length",   
    x = "Days post rice plantation",   
    fill = "Family"  
  ) +   
  facet_grid(site ~ type, space = "free_x", scales = "free_x") +   
  guides(fill = guide_legend(ncol = 2))  


# Modify the strip labels to show 'Site' only once
gy21_methanotroph_barplot <- gy21_methanotroph_barplot + 
  theme(strip.background = element_rect(colour = "white", fill = "white"))

ggsave("output/methanotroph_mbnT_TIGRFAM_taxonomy_barplot.pdf", width = 6, height=5, units = "in")
```

## methanogen db-RDA
```r
library(vegan)
library(ggplot2)
library(dplyr)

# 1. Read and prepare data  
# Load environmental data  
env <- read.csv("data/lineplot/gy21_geochemical.csv", header = TRUE, check.names = FALSE)  

# Remove specified columns (metadata, SOM, fluorine and chlorine)  
env <- env[, -c(2:4, 9, 10, 12, 13)]  

# Load methanogen data  
methanogen_dbRDA <- read.csv("data/lineplot/methanogen_dbRDA.csv", header = TRUE, check.names = FALSE)  

# Remove metadata columns  
methanogen_dbRDA1 <- methanogen_dbRDA[, -c(1:3)]  

# Replace zero with a small value  
methanogen_dbRDA1[methanogen_dbRDA1 == "0"] <- 1e-100  

# 2. Perform db-RDA  
# Calculate Bray-Curtis distance matrix  
methanogen_dist <- vegdist(methanogen_dbRDA1, method = "bray")  

# Perform db-RDA  
dbrda_result <- capscale(methanogen_dist ~ THg + MeHg + pH + DOM + DOM_SUVA254 + nitrate + sulfate, data = env)  

# 3. Analyze db-RDA significance  
# Assess overall significance of the model  
overall_test <- anova.cca(dbrda_result)  
print(overall_test)  

# Assess significance of individual environmental variables  
variable_test <- anova.cca(dbrda_result, by = "terms")  
print(variable_test)  

# 4. Plot db-RDA  
# Fit environmental variables to the ordination  
env_subset <- env[, c("THg", "MeHg", "pH", "DOM", "DOM_SUVA254", "nitrate", "sulfate")]

methanogen_env_fit <- envfit(dbrda_result, env_subset, permutations = 999)  

# Extract the scores for sites and species  
site_scores <- scores(dbrda_result, display = "sites")  
species_scores <- scores(dbrda_result, display = "species")  

# Convert to data frames for ggplot2  
site_scores_df <- as.data.frame(site_scores)  
species_scores_df <- as.data.frame(species_scores)  

# Add sample labels  
site_scores_df$Site_ID <- methanogen_dbRDA$ID  
site_scores_df$Site <- methanogen_dbRDA$site  

# Extract the fitted environmental vectors  
methanogen_env_vectors <- as.data.frame(scores(methanogen_env_fit, display = "vectors"))  
methanogen_env_vectors$EnvVar <- rownames(methanogen_env_vectors)  

# Scale the loadings for better visibility  
scaling_factor <- 5  # Adjust this factor as needed  
methanogen_env_vectors$CAP1 <- methanogen_env_vectors$CAP1 * scaling_factor  
methanogen_env_vectors$CAP2 <- methanogen_env_vectors$CAP2 * scaling_factor  

# Set site colors  
site_scores_df$Site <- factor(site_scores_df$Site, levels = c("HX", "GX", "SK"))  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  


# Calculate variance explained  
s <- summary(dbrda_result)  

# Extract the importance of the constrained axes  
# Check the structure of the returned value to know which indices to use  
importance_constrained_fitted <- s$concont$importance  
importance_constrained_total <- s$cont$importance  

# The Eigenvalues (the second row in the importance table)  
eigenvalues_fitted <- importance_constrained_fitted[2, ]  
eigenvalues_total <- importance_constrained_total[2, ]  

# Calculate percentage of variance explained by each axis  
percentage_variance_fitted <- (eigenvalues_fitted / sum(eigenvalues)) * 100  
percentage_variance_total  <- (eigenvalues_total / sum(eigenvalues)) * 100  

# Obtained the fitted and total value 
cap1_variance <- percentage_variance_fitted[1]  
cap2_variance <- percentage_variance_fitted[2]  

cap1_variance_total <- percentage_variance_total[1]  
cap2_variance_total <- percentage_variance_total[2]  

# Add variance information to axis labels  
x_label <- paste("RDA1 (", round(cap1_variance, 1), "% of fitted, ",   
                round(cap1_variance_total, 1), "% of total)", sep = "")  
  
y_label <- paste("RDA2 (", round(cap2_variance, 1), "% of fitted, ",   
                round(cap2_variance_total, 1), "% of total)", sep = "")  

# Create the ggplot  
methanogen_p <- ggplot() +  
  geom_point(data = site_scores_df, aes(x = CAP1, y = CAP2, color = Site), size = 3) +  
  geom_segment(data = methanogen_env_vectors, aes(x = 0, y = 0, xend = CAP1, yend = CAP2),  
               arrow = arrow(length = unit(0.3, "cm")), color = 'black', size = 0.2) +  
  geom_text(data = methanogen_env_vectors, aes(x = CAP1, y = CAP2, label = EnvVar),   
            vjust = -1.5, color = 'black', size = 2.5) +  
  labs(title = NULL, x = x_label, y = y_label) +  
  theme_minimal() +  
  scale_color_manual(name = "Site", values = site_colors) +   
  theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
         legend.position = "none") +  
  annotate("text", label = paste("Variance explained by \n constrained axes: 27.67%", sep = ""),  
           x = Inf, y = -Inf, hjust = 1.1, vjust = -0.5, size = 3, color = "black", parse = FALSE)  
methanogen_p
# Save the plot to a file  
ggsave("output/gy21_methanogen_dbRDA_20250806.pdf", plot = methanogen_p, width = 14, height = 12.5, units = "cm")

```

## testing code
```r
library(vegan)
library(ggplot2)
library(dplyr)

# 1. Read and prepare data  
# Load environmental data  
env <- read.csv("data/lineplot/gy21_geochemical.csv", header = TRUE, check.names = FALSE)  

# Remove specified columns (metadata, SOM, fluorine and chlorine)  
env <- env[, -c(2:4, 9, 10, 12, 13)]  

# Load methanogen data  
methanogen_dbRDA <- read.csv("data/lineplot/methanogen_dbRDA.csv", header = TRUE, check.names = FALSE)  

# Remove metadata columns  
methanogen_dbRDA1 <- methanogen_dbRDA[, -c(1:3)]  

# Replace zero with a small value  
methanogen_dbRDA1[methanogen_dbRDA1 == "0"] <- 1e-100  

# 2. Perform db-RDA  
# Calculate Bray-Curtis distance matrix  
methanogen_dist <- vegdist(methanogen_dbRDA1, method = "bray")  

# Perform db-RDA  
dbrda_result <- capscale(methanogen_dist ~ THg + MeHg + pH + DOM + DOM_SUVA254 + nitrate + sulfate, data = env)  

dbrda_result

# 3. Analyze db-RDA significance  
# Assess overall significance of the model  
overall_test <- anova.cca(dbrda_result)  
print(overall_test)  

# Assess significance of individual environmental variables  
variable_test <- anova.cca(dbrda_result, by = "terms")  
print(variable_test)  

# 4. Plot db-RDA  
# Fit environmental variables to the ordination  
methanogen_env_fit <- envfit(dbrda_result, env, permutations = 999)  
methanogen_env_fit

# get R2 and P values of the variables
r2_values <- methanogen_env_fit$vectors$r
r2_values
pvals <- methanogen_env_fit$vectors$pvals
pvals

# run a VIF analyses to determine collinear variables
library(car)
env_model <- env[, c("THg", "MeHg", "pH", "DOM", "DOM_SUVA254", "nitrate", "sulfate")]

vif_results <- vif(lm(THg~ ., data = env_model))
vif_results

# Extract the scores for sites and species  
site_scores <- scores(dbrda_result, display = "sites")  
species_scores <- scores(dbrda_result, display = "species")  

# Convert to data frames for ggplot2  
site_scores_df <- as.data.frame(site_scores)  
species_scores_df <- as.data.frame(species_scores)  

# Add sample labels  
site_scores_df$Site_ID <- methanogen_dbRDA$ID  
site_scores_df$Site <- methanogen_dbRDA$site  

# Extract the fitted environmental vectors  
methanogen_env_vectors <- as.data.frame(scores(methanogen_env_fit, display = "vectors"))  
methanogen_env_vectors$EnvVar <- rownames(methanogen_env_vectors)  

# Scale the loadings for better visibility  
scaling_factor <- 5  # Adjust this factor as needed  
methanogen_env_vectors$CAP1 <- methanogen_env_vectors$CAP1 * scaling_factor  
methanogen_env_vectors$CAP2 <- methanogen_env_vectors$CAP2 * scaling_factor  

# Set site colors  
site_scores_df$Site <- factor(site_scores_df$Site, levels = c("HX", "GX", "SK"))  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  


# Calculate variance explained  
s <- summary(dbrda_result)  

# Extract the importance of the constrained axes  
# Check the structure of the returned value to know which indices to use  
importance_constrained_fitted <- s$concont$importance  
importance_constrained_total <- s$cont$importance  

# The Eigenvalues (the second row in the importance table)  
eigenvalues_fitted <- importance_constrained_fitted[2, ]  
eigenvalues_total <- importance_constrained_total[2, ]  

# Calculate percentage of variance explained by each axis  
percentage_variance_fitted <- (eigenvalues_fitted / sum(eigenvalues)) * 100  
percentage_variance_total  <- (eigenvalues_total / sum(eigenvalues)) * 100  

# Obtained the fitted and total value 
cap1_variance <- percentage_variance_fitted[1]  
cap2_variance <- percentage_variance_fitted[2]  

cap1_variance_total <- percentage_variance_total[1]  
cap2_variance_total <- percentage_variance_total[2]  

# Add variance information to axis labels  
x_label <- paste("RDA1 (", round(cap1_variance, 1), "% of fitted, ",   
                round(cap1_variance_total, 1), "% of total)", sep = "")  
  
y_label <- paste("RDA2 (", round(cap2_variance, 1), "% of fitted, ",   
                round(cap2_variance_total, 1), "% of total)", sep = "")  

# Create the ggplot  
methanogen_p <- ggplot() +  
  geom_point(data = site_scores_df, aes(x = CAP1, y = CAP2, color = Site), size = 3) +  
  geom_segment(data = methanogen_env_vectors, aes(x = 0, y = 0, xend = CAP1, yend = CAP2),  
               arrow = arrow(length = unit(0.3, "cm")), color = 'black', size = 0.2) +  
  geom_text(data = methanogen_env_vectors, aes(x = CAP1, y = CAP2, label = EnvVar),   
            vjust = -1.5, color = 'black', size = 2.5) +  
  labs(title = NULL, x = x_label, y = y_label) +  
  theme_minimal() +  
  scale_color_manual(name = "Site", values = site_colors) +   
  theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
         legend.position = "none") +  
  annotate("text", label = paste("Variance explained by \n constrained axes: 27.67%", sep = ""),  
           x = Inf, y = -Inf, hjust = 1.1, vjust = -0.5, size = 3, color = "black", parse = FALSE)  
methanogen_p
# Save the plot to a file  
ggsave("output/gy21_methanogen_dbRDA_test.pdf", plot = methanogen_p, width = 14, height = 12.5, units = "cm")

```

## aerobic methanotroph db-RDA
```r
library(vegan)
library(ggplot2)
library(dplyr)

# 1. Read and prepare data  
# Load environmental data  
env <- read.csv("data/lineplot/gy21_geochemical.csv", header = TRUE, check.names = FALSE)  

# Remove specified columns (metadata, SOM, fluorine and chlorine)  
env <- env[, -c(2:4, 9, 10, 12, 13)]  

# Load methanotroph data  
methanotroph_dbRDA <- read.csv("data/lineplot/methanotroph_dbRDA.csv", header = TRUE, check.names = FALSE)  

# Remove metadata columns and ANME
methanotroph_dbRDA1 <- methanotroph_dbRDA[, -c(1:3,10)]  

# Replace zero with a small value  
methanotroph_dbRDA1[methanotroph_dbRDA1 == "0"] <- 1e-100  

# 2. Perform db-RDA  
# Calculate Bray-Curtis distance matrix  
methanotroph_dist <- vegdist(methanotroph_dbRDA1, method = "bray")  

# Perform db-RDA  
dbrda_result <- capscale(methanotroph_dist ~ THg + MeHg + pH + DOM + DOM_SUVA254 + nitrate + sulfate, data = env)  

dbrda_result

# 3. Analyze db-RDA significance  
# Assess overall significance of the model  
overall_test <- anova.cca(dbrda_result)  
print(overall_test)  

# Assess significance of individual environmental variables  
variable_test <- anova.cca(dbrda_result, by = "terms")  
print(variable_test)  

# 4. Plot db-RDA  
# Fit environmental variables to the ordination  
env_subset <- env[, c("THg", "MeHg", "pH", "DOM", "DOM_SUVA254", "nitrate", "sulfate")]

methanotroph_env_fit <- envfit(dbrda_result, env_subset, permutations = 999)  

# Extract the scores for sites and species  
site_scores <- scores(dbrda_result, display = "sites")  
species_scores <- scores(dbrda_result, display = "species")  

# Convert to data frames for ggplot2  
site_scores_df <- as.data.frame(site_scores)  
species_scores_df <- as.data.frame(species_scores)  

# Add sample labels  
site_scores_df$Site_ID <- methanotroph_dbRDA$ID  
site_scores_df$Site <- methanotroph_dbRDA$site  

# Extract the fitted environmental vectors  
methanotroph_env_vectors <- as.data.frame(scores(methanotroph_env_fit, display = "vectors"))  
methanotroph_env_vectors$EnvVar <- rownames(methanotroph_env_vectors)  

# Scale the loadings for better visibility  
scaling_factor <- 5  # Adjust this factor as needed  
methanotroph_env_vectors$CAP1 <- methanotroph_env_vectors$CAP1 * scaling_factor  
methanotroph_env_vectors$CAP2 <- methanotroph_env_vectors$CAP2 * scaling_factor  

# Set site colors  
site_scores_df$Site <- factor(site_scores_df$Site, levels = c("HX", "GX", "SK"))  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  


# Calculate variance explained  
s <- summary(dbrda_result)  

# Extract the importance of the constrained axes  
# Check the structure of the returned value to know which indices to use  
importance_constrained_fitted <- s$concont$importance  
importance_constrained_total <- s$cont$importance  

# The Eigenvalues (the second row in the importance table)  
eigenvalues_fitted <- importance_constrained_fitted[2, ]  
eigenvalues_total <- importance_constrained_total[2, ]  

# Calculate percentage of variance explained by each axis  
percentage_variance_fitted <- (eigenvalues_fitted / sum(eigenvalues)) * 100  
percentage_variance_total  <- (eigenvalues_total / sum(eigenvalues)) * 100  

# Obtained the fitted and total value 
cap1_variance <- percentage_variance_fitted[1]  
cap2_variance <- percentage_variance_fitted[2]  

cap1_variance_total <- percentage_variance_total[1]  
cap2_variance_total <- percentage_variance_total[2]  

# Add variance information to axis labels  
x_label <- paste("RDA1 (", round(cap1_variance, 1), "% of fitted, ",   
                round(cap1_variance_total, 1), "% of total)", sep = "")  
  
y_label <- paste("RDA2 (", round(cap2_variance, 1), "% of fitted, ",   
                round(cap2_variance_total, 1), "% of total)", sep = "")  

# Create the ggplot  
methanotroph_p <- ggplot() +  
  geom_point(data = site_scores_df, aes(x = CAP1, y = CAP2, color = Site), size = 3) +  
  geom_segment(data = methanotroph_env_vectors, aes(x = 0, y = 0, xend = CAP1, yend = CAP2),  
               arrow = arrow(length = unit(0.3, "cm")), color = 'black', size = 0.2) +  
  geom_text(data = methanotroph_env_vectors, aes(x = CAP1, y = CAP2, label = EnvVar),   
            vjust = -1.5, color = 'black', size = 2.5) +  
  labs(x = x_label, y = y_label, title = NULL) + 
  theme_minimal() +  
  scale_color_manual(name = "Site", values = site_colors) +   
  theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                      legend.text = element_text(size = 8, colour = "black"),   
                      legend.key.size = unit(0.25, 'cm'),  
                      legend.position = "bottom") +  
  annotate("text", label = paste("Variance explained by \n constrained axes: 22.14%", sep = ""),  
           x = Inf, y = -Inf, hjust = 1.1, vjust = -0.5, size = 3, color = "black", parse = FALSE)  
methanotroph_p
# Save the plot to a file  
ggsave("output/gy21_methanotroph_dbRDA_20250806.pdf", plot = methanotroph_p, width = 14, height = 12.5, units = "cm")


```

## methanogens, methanotrophs taxonomy and db-RDA combined plots
```r
# Combine plots vertically (top/bottom)  
db_rda_combined <- methanogen_p / methanotroph_p  

methane_cycling_bar_db_rda_combined <- gy21_methanogen_barplot +   
                                      gy21_methanotroph_barplot + 
                                      db_rda_combined  

# Add plot annotations with tags and ensure equal heights  
methane_cycling_bar_db_rda_combined <- methane_cycling_bar_db_rda_combined +   
                                      plot_layout(ncol = 3, width = c(1.1, 1.1, 1.4)) +  
                                      plot_annotation(tag_levels = 'A')  

ggsave("output/methane_cycling_bar_db_rda_combined.pdf", width = 12, height=9, units = "in")


```

## methanogen db-RDA - 20250806
```r
library(vegan)
library(ggplot2)
library(dplyr)

# 1. Read and prepare data  
# Load environmental data  
env <- read.csv("data/lineplot/gy21_geochemical.csv", header = TRUE, check.names = FALSE)  

# Remove specified columns (metadata, SOM, fluorine and chlorine)  
env <- env[, -c(2:4, 9, 10, 12, 13)]  

# Load methanogen data  
methanogen_dbRDA <- read.csv("data/lineplot/methanogen_dbRDA.csv", header = TRUE, check.names = FALSE)  

# Remove metadata columns  
methanogen_dbRDA1 <- methanogen_dbRDA[, -c(1:3)]  

# Error checking
if(nrow(env) != nrow(methanogen_dbRDA)) {
  stop("Environmental and community data have different number of samples")
}

# Replace zero with a small value  
methanogen_dbRDA1[methanogen_dbRDA1 == "0"] <- 1e-100  

# 2. Perform db-RDA  
# Calculate Bray-Curtis distance matrix  
methanogen_dist <- vegdist(methanogen_dbRDA1, method = "bray")  

# Perform db-RDA  
dbrda_result <- capscale(methanogen_dist ~ THg + MeHg + pH + DOM + DOM_SUVA254 + nitrate + sulfate, data = env)  

# 3. Analyze db-RDA significance  
# Assess overall significance of the model  
overall_test <- anova.cca(dbrda_result)  
print(overall_test)  

# Assess significance of individual environmental variables  
variable_test <- anova.cca(dbrda_result, by = "terms")  
print(variable_test)  

# 4. Plot db-RDA  
# Fit environmental variables to the ordination  
env_subset <- env[, c("THg", "MeHg", "pH", "DOM", "DOM_SUVA254", "nitrate", "sulfate")]

methanogen_env_fit <- envfit(dbrda_result, env_subset, permutations = 999)  
print(methanogen_env_fit)

# Extract the scores for sites  
site_scores <- scores(dbrda_result, display = "sites")  

# Convert to data frames for ggplot2  
site_scores_df <- as.data.frame(site_scores)  

# Add sample labels  
site_scores_df$Site_ID <- methanogen_dbRDA$ID  
site_scores_df$Site <- methanogen_dbRDA$site  

# Extract the fitted environmental vectors  
methanogen_env_vectors <- as.data.frame(scores(methanogen_env_fit, display = "vectors"))  
methanogen_env_vectors$EnvVar <- rownames(methanogen_env_vectors)  

# Scale the loadings for better visibility  
scaling_factor <- 5  # Adjust this factor as needed  
methanogen_env_vectors$CAP1 <- methanogen_env_vectors$CAP1 * scaling_factor  
methanogen_env_vectors$CAP2 <- methanogen_env_vectors$CAP2 * scaling_factor  

# Set site colors  
site_scores_df$Site <- factor(site_scores_df$Site, levels = c("HX", "GX", "SK"))  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Calculate variance explained  
s <- summary(dbrda_result)  

# Extract the importance of the constrained axes  
importance_constrained_fitted <- s$concont$importance  
importance_constrained_total <- s$cont$importance  

# The Eigenvalues (the second row in the importance table)  
eigenvalues_fitted <- importance_constrained_fitted[2, ]  * 100
eigenvalues_total <- importance_constrained_total[2, ]  * 100

# Get the variance for CAP1 and CAP2
cap1_variance <- eigenvalues_fitted[1]  
cap2_variance <- eigenvalues_fitted[2]  

cap1_variance_total <- eigenvalues_total[1]  
cap2_variance_total <- eigenvalues_total[2] 

# Calculate total constrained variance dynamically
total_constrained_variance <- sum(eigenvalues_total[1:7])

# Add variance information to axis labels  
x_label <- paste("RDA1 (", round(cap1_variance, 2), "% of fitted, ",   
                round(cap1_variance_total, 2), "% of total)", sep = "")  
  
y_label <- paste("RDA2 (", round(cap2_variance, 2), "% of fitted, ",   
                round(cap2_variance_total, 2), "% of total)", sep = "")  

# Create the ggplot  
methanogen_p <- ggplot() +  
  geom_point(data = site_scores_df, aes(x = CAP1, y = CAP2, color = Site), size = 3) +  
  geom_segment(data = methanogen_env_vectors, aes(x = 0, y = 0, xend = CAP1, yend = CAP2),  
               arrow = arrow(length = unit(0.3, "cm")), color = 'black', linewidth = 0.2) +  
  geom_text(data = methanogen_env_vectors, aes(x = CAP1, y = CAP2, label = EnvVar),   
            vjust = -1.5, color = 'grey40', size = 4) +  
  labs(title = NULL, x = x_label, y = y_label) +  
  theme_minimal() +  
  scale_color_manual(name = "Site", values = site_colors) +   
  theme(panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
         legend.position = "none") +  
  annotate("text", label = paste("Variance explained by \nconstrained axes: ", round(total_constrained_variance, 2), "%", sep = ""),  
           x = Inf, y = -Inf, hjust = 1.1, vjust = -0.5, size = 3, color = "black", parse = FALSE)  

methanogen_p

# Save the plot to a file  
ggsave("output/gy21_methanogen_dbRDA_20250806.pdf", plot = methanogen_p, width = 14, height = 12.5, units = "cm")

```

## aerobic methanotroph db-RDA - 20250806
```r
library(vegan)
library(ggplot2)
library(dplyr)

# 1. Read and prepare data  
# Load environmental data  
env <- read.csv("data/lineplot/gy21_geochemical.csv", header = TRUE, check.names = FALSE)  

# Remove specified columns (metadata, SOM, fluorine and chlorine)  
env <- env[, -c(2:4, 9, 10, 12, 13)]  

# Load methanotroph data  
methanotroph_dbRDA <- read.csv("data/lineplot/methanotroph_dbRDA.csv", header = TRUE, check.names = FALSE)  

# Remove metadata columns and ANME
methanotroph_dbRDA1 <- methanotroph_dbRDA[, -c(1:3,10)]  

# Error checking
if(nrow(env) != nrow(methanotroph_dbRDA)) {
  stop("Environmental and community data have different number of samples")
}

# Replace zero with a small value  
methanotroph_dbRDA1[methanotroph_dbRDA1 == "0"] <- 1e-100  

# 2. Perform db-RDA  
# Calculate Bray-Curtis distance matrix  
methanotroph_dist <- vegdist(methanotroph_dbRDA1, method = "bray")  

# Perform db-RDA  
dbrda_result <- capscale(methanotroph_dist ~ THg + MeHg + pH + DOM + DOM_SUVA254 + nitrate + sulfate, data = env)  

# 3. Analyze db-RDA significance  
# Assess overall significance of the model  
overall_test <- anova.cca(dbrda_result)  
print(overall_test)  

# Assess significance of individual environmental variables  
variable_test <- anova.cca(dbrda_result, by = "terms")  
print(variable_test)  

# 4. Plot db-RDA  
# Fit environmental variables to the ordination  
env_subset <- env[, c("THg", "MeHg", "pH", "DOM", "DOM_SUVA254", "nitrate", "sulfate")]

methanotroph_env_fit <- envfit(dbrda_result, env_subset, permutations = 999)  
print(methanotroph_env_fit)

# Extract the scores for sites  
site_scores <- scores(dbrda_result, display = "sites")  

# Convert to data frames for ggplot2  
site_scores_df <- as.data.frame(site_scores)  

# Add sample labels  
site_scores_df$Site_ID <- methanotroph_dbRDA$ID  
site_scores_df$Site <- methanotroph_dbRDA$site  

# Extract the fitted environmental vectors  
methanotroph_env_vectors <- as.data.frame(scores(methanotroph_env_fit, display = "vectors"))  
methanotroph_env_vectors$EnvVar <- rownames(methanotroph_env_vectors)  

# Scale the loadings for better visibility  
scaling_factor <- 5  # Adjust this factor as needed  
methanotroph_env_vectors$CAP1 <- methanotroph_env_vectors$CAP1 * scaling_factor  
methanotroph_env_vectors$CAP2 <- methanotroph_env_vectors$CAP2 * scaling_factor  

# Set site colors  
site_scores_df$Site <- factor(site_scores_df$Site, levels = c("HX", "GX", "SK"))  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Calculate variance explained  
s <- summary(dbrda_result)  

# Extract the importance of the constrained axes  
importance_constrained_fitted <- s$concont$importance  
importance_constrained_total <- s$cont$importance  

# The Eigenvalues (the second row in the importance table)  
eigenvalues_fitted <- importance_constrained_fitted[2, ] * 100
eigenvalues_total <- importance_constrained_total[2, ] * 100

# Get the variance for CAP1 and CAP2
cap1_variance <- eigenvalues_fitted[1]  
cap2_variance <- eigenvalues_fitted[2]  

cap1_variance_total <- eigenvalues_total[1]  
cap2_variance_total <- eigenvalues_total[2] 

# Calculate total constrained variance dynamically
total_constrained_variance <- sum(eigenvalues_total[1:7])

# Add variance information to axis labels  
x_label <- paste("RDA1 (", round(cap1_variance, 2), "% of fitted, ",   
                round(cap1_variance_total, 2), "% of total)", sep = "")  
  
y_label <- paste("RDA2 (", round(cap2_variance, 2), "% of fitted, ",   
                round(cap2_variance_total, 2), "% of total)", sep = "")  

# Create the ggplot  
methanotroph_p <- ggplot() +  
  geom_point(data = site_scores_df, aes(x = CAP1, y = CAP2, color = Site), size = 3) +  
  geom_segment(data = methanotroph_env_vectors, aes(x = 0, y = 0, xend = CAP1, yend = CAP2),  
               arrow = arrow(length = unit(0.3, "cm")), color = 'black', linewidth = 0.2) +  
  geom_text(data = methanotroph_env_vectors, aes(x = CAP1, y = CAP2, label = EnvVar),   
            vjust = -1.5, color = 'grey40', size = 4) +  
  labs(x = x_label, y = y_label, title = NULL) + 
  theme_minimal() +  
  scale_color_manual(name = "Site", values = site_colors) +   
  theme(panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
        legend.text = element_text(size = 12, colour = "black"),   
        legend.key.size = unit(0.8, 'cm'),  
        legend.position = "bottom") +  
  annotate("text", label = paste("Variance explained by \nconstrained axes: ", round(total_constrained_variance, 2), "%", sep = ""),  
           x = Inf, y = -Inf, hjust = 1.1, vjust = -0.5, size = 3, color = "black", parse = FALSE)  

methanotroph_p

# Save the plot to a file  
ggsave("output/gy21_methanotroph_dbRDA_20250806.pdf", plot = methanotroph_p, width = 14, height = 12.5, units = "cm")


```

## methanogens, methanotrophs taxonomy and db-RDA combined plots - 20250806
```r
library(patchwork)

# Combine plots vertically (top/bottom)  
db_rda_combined <- methanogen_p / methanotroph_p  

methane_cycling_bar_db_rda_combined <- gy21_methanogen_barplot +   
                                      gy21_methanotroph_barplot + 
                                      db_rda_combined  

# Add plot annotations with tags and ensure equal heights  
methane_cycling_bar_db_rda_combined <- methane_cycling_bar_db_rda_combined +   
                                      plot_layout(ncol = 3, width = c(1.1, 1.1, 1.4)) +  
                                      plot_annotation(tag_levels = 'A')  

ggsave("output/methane_cycling_bar_db_rda_combined_20250806.pdf", width = 12, height=9, units = "in")


```



# part 3 - correlation analyses between gene marker and MeHg. 
## correlation between MeHg and hgcA between sites and type
```r

# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))


# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and overall_hgcA  
    spearman_correlation = cor.test(  
      MeHg,   # Dependent variable (Mercury concentration)  
      overall_hgcA,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg,   
      overall_hgcA,   
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 
```

## correlation between MeHg/THg ratio and hgcA between sites and type
```r

# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses_modified2.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))


# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and overall_hgcA  
    spearman_correlation = cor.test(  
      MeHg_THg_ratio,   # Dependent variable (Mercury concentration)  
      overall_hgcA,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_THg_ratio,   
      overall_hgcA,   
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 
```

## correlation between MeHg and hgcA between sites and flooding status
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$water <- factor(data$water, levels = c("Flooded", "Dried"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))


# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, water) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and overall_hgcA  
    spearman_correlation = cor.test(  
      MeHg,   # Dependent variable (Mercury concentration)  
      overall_hgcA,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg,   
      overall_hgcA,   
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 
```

## correlation between MeHg and methanogen between sites and type (z-score transformation)
```r

# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Create standardized variables using z-scores
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_z = scale(MeHg),  
    methanogen_z = scale(overall_methanogen)  
  ) %>%  
  ungroup()

# Perform correlation using standardized variables
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%
  summarise(  
    # Spearman correlation for standardized variables
    spearman_correlation = cor.test(  
      MeHg_z,
      methanogen_z,
      method = "spearman"  
    )$estimate,
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_z,
      methanogen_z,
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables
mcrA_MeHg_plot <- ggplot(data, aes(x = methanogen_z, y = MeHg_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = comprehensive_correlations %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,
      y = -Inf,
      label = paste("rho =", round(spearman_correlation, 3),  
                    "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1,
    vjust = -0.5,
    size = 3  
  ) +  
  # Create separate panels for each site and type combination
  # Remove scales="free" since z-scores are standardized  
  facet_grid(type ~ site) +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized Methanogen mcrA and MeHg",
    x = "Methanogen mcrA abundance (z-score)",  
    y = "MeHg concentration (z-score)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90")
  )  

# Display the plot  
print(mcrA_MeHg_plot)

# Save the plot
# ggsave("output/mcrA_MeHg_standardized_plot.pdf", mcrA_MeHg_plot, width = 8, height = 4, unit = "in")
```

## correlation between MeHg and methanogen between sites and type (z-score transformation) flooded period only
```r

# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

# maintain only flooded datapoints
data <- data[data$water == "Flooded", ]


data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Create standardized variables using z-scores
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_z = scale(MeHg),  
    methanogen_z = scale(overall_methanogen)  
  ) %>%  
  ungroup()

# Perform correlation using standardized variables
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%
  summarise(  
    # Spearman correlation for standardized variables
    spearman_correlation = cor.test(  
      MeHg_z,
      methanogen_z,
      method = "spearman"  
    )$estimate,
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_z,
      methanogen_z,
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables
mcrA_MeHg_plot_flooded <- ggplot(data, aes(x = methanogen_z, y = MeHg_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = comprehensive_correlations %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,
      y = -Inf,
      label = paste("rho =", round(spearman_correlation, 3),  
                    "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1,
    vjust = -0.5,
    size = 3  
  ) +  
  # Create separate panels for each site and type combination
  # Remove scales="free" since z-scores are standardized  
  facet_grid(type ~ site) +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized Methanogen mcrA and MeHg",
    x = "Methanogen mcrA abundance (z-score)",  
    y = "MeHg concentration (z-score)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90")
  )  

# Display the plot  
print(mcrA_MeHg_plot_flooded)

# Save the plot
# ggsave("output/mcrA_MeHg_standardized_plot_flooded.pdf", mcrA_MeHg_plot_flooded, width = 8, height = 4, unit = "in")
```

## correlation between MeHg/THg ratio and methanogen between sites and type (z-score transformation)
```r

# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses_modified2.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Create standardized variables using z-scores
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_THg_ratio_z = scale(MeHg_THg_ratio),  
    methanogen_z = scale(overall_methanogen)  
  ) %>%  
  ungroup()

# Perform correlation using standardized variables
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%
  summarise(  
    # Spearman correlation for standardized variables
    spearman_correlation = cor.test(  
      MeHg_THg_ratio_z,
      methanogen_z,
      method = "spearman"  
    )$estimate,
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_THg_ratio_z,
      methanogen_z,
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables
mcrA_MeHg_ratio_plot <- ggplot(data, aes(x = methanogen_z, y = MeHg_THg_ratio_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = comprehensive_correlations %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,
      y = -Inf,
      label = paste("rho =", round(spearman_correlation, 3),  
                    "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1,
    vjust = -0.5,
    size = 3  
  ) +  
  # Create separate panels for each site and type combination
  # Remove scales="free" since z-scores are standardized  
  facet_grid(type ~ site) +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized Methanogen mcrA and MeHg/THg ratio",
    x = "Methanogen mcrA abundance (z-score)",  
    y = "MeHg/THg ratio (z-score)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90")
  )  

# Display the plot  
print(mcrA_MeHg_ratio_plot)

# Save the plot
# ggsave("output/mcrA_MeHg_ratio_standardized_plot.pdf", mcrA_MeHg_ratio_plot, width = 8, height = 4, unit = "in")
```

## correlation between MeHg and specific methanogen families between sites and type (z-score transformation)
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)
library(gridExtra)  # For combining plots

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses_modified2.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Define the methanogen taxa of interest
methanogen_taxa <- c("Methanoregulaceae", "Methanotrichaceae", "Methanosphaerulaceae", 
                     "Methanobacteriaceae", "Methanocellaceae", "Methanosarcinaceae")

# Create standardized variables for MeHg and all methanogen taxa
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_z = scale(MeHg),  
    Methanoregulaceae_z = scale(Methanoregulaceae),
    Methanotrichaceae_z = scale(Methanotrichaceae),
    Methanosphaerulaceae_z = scale(Methanosphaerulaceae),
    Methanobacteriaceae_z = scale(Methanobacteriaceae),
    Methanocellaceae_z = scale(Methanocellaceae),
    Methanosarcinaceae_z = scale(Methanosarcinaceae)
  ) %>%  
  ungroup()

# Initialize empty dataframe for all correlations
all_correlations <- data.frame()

# Loop through each taxon and calculate correlations with error handling
for(taxon in methanogen_taxa) {
  taxon_z_col <- paste0(taxon, "_z")
  
  # Calculate correlations for this taxon
  taxon_correlations <- data %>%  
    group_by(site, type) %>%
    summarise(  
      taxon = taxon,
      # Count valid observations
      n_valid = sum(!is.na(MeHg_z) & !is.na(!!sym(taxon_z_col)) & 
                    is.finite(MeHg_z) & is.finite(!!sym(taxon_z_col))),
      
      # Spearman correlation for standardized variables (with error handling)
      spearman_correlation = if(n_valid >= 3) {
        tryCatch({
          cor.test(MeHg_z, !!sym(taxon_z_col), method = "spearman")$estimate
        }, error = function(e) NA)
      } else {
        NA
      },
      
      # P-value for the same correlation (with error handling)
      spearman_p_values = if(n_valid >= 3) {
        tryCatch({
          cor.test(MeHg_z, !!sym(taxon_z_col), method = "spearman")$p.value
        }, error = function(e) NA)
      } else {
        NA
      },
      .groups = "drop"
    )
  
  # Add to overall results
  all_correlations <- rbind(all_correlations, taxon_correlations)
}

# Print all correlations
print("Correlation results for all methanogen taxa:")
print(all_correlations)

# Print summary of data availability
print("\nData availability summary:")
all_correlations %>%
  group_by(taxon) %>%
  summarise(
    groups_with_data = sum(n_valid >= 3),
    groups_without_data = sum(n_valid < 3),
    total_groups = n()
  ) %>%
  print()

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Function to create individual plots for each taxon
create_taxon_plot <- function(taxon_name) {
  taxon_z_col <- paste0(taxon_name, "_z")
  
  # Get correlations for this taxon (only those with valid data)
  taxon_correlations <- all_correlations[all_correlations$taxon == taxon_name & 
                                         !is.na(all_correlations$spearman_correlation), ]
  
  # Create the plot
  p <- ggplot(data, aes_string(x = taxon_z_col, y = "MeHg_z", color = "site")) +  
    # Add points  
    geom_point(size = 2, alpha = 0.7) +  
    # Add regression lines  
    geom_smooth(method = "lm", se = FALSE, linetype = "dashed", size = 0.8) +  
    # Add correlation text at bottom right corner (only for valid correlations)
    {if(nrow(taxon_correlations) > 0) {
      geom_text(  
        data = taxon_correlations,  
        aes(  
          x = Inf,
          y = -Inf,
          label = paste("ρ =", round(spearman_correlation, 3),  
                        "\np =", round(spearman_p_values, 3)),  
          color = "black"  
        ),  
        hjust = 1,
        vjust = -0.5,
        size = 2.5,
        show.legend = FALSE,
        inherit.aes = FALSE
      )
    }} +
    # Create separate panels for each site and type combination
    facet_grid(type ~ site) +  
    # Apply your custom color scheme  
    scale_color_manual(values = site_colors) +  
    # Add labels and theming  
    labs(  
      title = paste("MeHg vs", taxon_name),
      x = paste(taxon_name, "abundance (z-score)"),  
      y = "MeHg concentration (z-score)",  
      color = "Site"  
    ) +  
    theme_minimal() +  
    theme(  
      panel.border = element_rect(colour = "black", fill = NA, size = 0.8),  
      legend.position = "bottom",  
      strip.background = element_rect(fill = "lightgray", color = "black"),  
      strip.text = element_text(face = "bold", size = 8),
      panel.grid.minor = element_blank(),
      panel.grid.major = element_line(color = "gray90"),
      plot.title = element_text(size = 10, face = "bold"),
      axis.title = element_text(size = 9),
      axis.text = element_text(size = 8),
      legend.text = element_text(size = 8),
      legend.title = element_text(size = 9)
    )
  
  return(p)
}

# Create individual plots for each taxon
individual_plots <- list()
for(i in seq_along(methanogen_taxa)) {
  individual_plots[[i]] <- create_taxon_plot(methanogen_taxa[i])
}
names(individual_plots) <- methanogen_taxa

# Display individual plots
for(i in seq_along(individual_plots)) {
  print(individual_plots[[i]])
}

# Create a combined plot using grid.arrange
combined_plot <- do.call(grid.arrange, c(individual_plots, ncol = 2))

# Save individual plots
for(taxon in methanogen_taxa) {
  filename <- paste0("output/MeHg_", gsub("[^A-Za-z0-9]", "_", taxon), "_correlation.pdf")
  ggsave(filename, individual_plots[[taxon]], width = 8, height = 4, units = "in")
}

# Save the combined plot
ggsave("output/MeHg_methanogen_taxa_combined.pdf", combined_plot, width = 16, height = 12, units = "in")

# Create a summary table of correlations (only valid ones)
correlation_summary <- all_correlations[!is.na(all_correlations$spearman_correlation), ]

if(nrow(correlation_summary) > 0) {
  correlation_summary$correlation_strength <- ifelse(abs(correlation_summary$spearman_correlation) >= 0.7, "Strong",
                                            ifelse(abs(correlation_summary$spearman_correlation) >= 0.5, "Moderate",
                                            ifelse(abs(correlation_summary$spearman_correlation) >= 0.3, "Weak", "Very weak")))
  
  correlation_summary$significance <- ifelse(correlation_summary$spearman_p_values < 0.001, "***",
                                   ifelse(correlation_summary$spearman_p_values < 0.01, "**",
                                   ifelse(correlation_summary$spearman_p_values < 0.05, "*", "ns")))
  
  correlation_summary <- correlation_summary[order(correlation_summary$taxon, correlation_summary$site, correlation_summary$type), ]
  
  print("Summary of valid correlations:")
  print(correlation_summary)
  
  # Save correlation summary
  write.csv(correlation_summary, "output/methanogen_MeHg_correlation_summary.csv", row.names = FALSE)
} else {
  print("No valid correlations found!")
}
```

## correlation between MeHg and methanogen hgcA between sites and type
```r

# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))


# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and overall_hgcA  
    spearman_correlation = cor.test(  
      MeHg,   # Dependent variable (Mercury concentration)  
      overall_methanogen_hgcA,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg,   
      overall_methanogen_hgcA,   
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 
```

## correlation between MeHg and merB between sites and type
```r

# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and overall_hgcA  
    spearman_correlation = cor.test(  
      MeHg,   # Dependent variable (Mercury concentration)  
      overall_merB,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg,   
      overall_merB,   
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Calculate correlation, handling potential missing combinations safely  
merB_correlation_results <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Only calculate if we have at least 2 pairs of values  
    spearman_correlation = if(sum(complete.cases(MeHg, overall_merB)) >= 2) {  
      cor.test(MeHg, overall_merB, method = "spearman")$estimate  
    } else {  
      NA_real_  
    },  
    spearman_p_values = if(sum(complete.cases(MeHg, overall_merB)) >= 2) {  
      cor.test(MeHg, overall_merB, method = "spearman")$p.value  
    } else {  
      NA_real_  
    },  
    # Get max values safely  
    max_x = if(sum(!is.na(overall_merB)) > 0) max(overall_merB, na.rm = TRUE) else NA_real_,  
    max_y = if(sum(!is.na(MeHg)) > 0) max(MeHg, na.rm = TRUE) else NA_real_,  
    # Count number of complete cases  
    n_complete = sum(complete.cases(MeHg, overall_merB))  
  ) %>%  
  ungroup()  

# Print the correlation coefficient and significance  
print(merB_correlation_results)  

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with text in bottom right corner  
merB_MeHg_plot <- ggplot(data, aes(x = overall_merB, y = MeHg, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = merB_correlation_results %>% filter(!is.na(spearman_correlation)),  
    aes(  
      # Use normalized coordinates (1=right, 0=bottom)  
      x = Inf,  
      y = -Inf,  
      label = paste("rho =", round(spearman_correlation, 3),  
                   "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1.1,  # Right-align the text  
    vjust = -0.5,  # Position slightly above the bottom  
    size = 3,  
    position = position_nudge(y = 0.05 * max(data$MeHg, na.rm = TRUE))  # Add a small nudge upward  
  ) +  
  # Create separate panels for each site and type combination  
  facet_grid(type ~ site, scales = "free") +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between merB Gene Abundance and MeHg",  
    x = "merB Gene Abundance",  
    y = "MeHg concentration (ng/g)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),  
    panel.grid.minor = element_blank(),  # Remove minor grid lines  
    panel.grid.major = element_line(color = "gray90")  # Lighten major grid lines  
  )  

# Display the plot  

ggsave("output/merB_MeHg_plot.pdf", merB_MeHg_plot, width = 8, height = 4,unit = "in")  

```

## correlation between MeHg and merB between sites and type (z-score transformation)
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)  # Add this since you're using ggplot  

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses_modified2.csv", header = TRUE)  

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))  
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))  

# Create standardized variables using z-scores  
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_z = scale(MeHg),  
    overall_merB_z = scale(overall_merB)  
  ) %>%  
  ungroup()  

# Perform correlation using standardized variables  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Spearman correlation for standardized variables  
    spearman_correlation = cor.test(  
      MeHg_z,  
      overall_merB_z,  
      method = "spearman"  
    )$estimate,  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_z,  
      overall_merB_z,  
      method = "spearman"  
    )$p.value  
  )  

# Print the correlation coefficient and significance  
print(comprehensive_correlations)  

# Calculate correlation with standardized variables, handling potential missing combinations  
merB_correlation_results <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Only calculate if we have at least 2 pairs of values  
    spearman_correlation = if(sum(complete.cases(MeHg_z, overall_merB_z)) >= 2) {  
      cor.test(MeHg_z, overall_merB_z, method = "spearman")$estimate  
    } else {  
      NA_real_  
    },  
    spearman_p_values = if(sum(complete.cases(MeHg_z, overall_merB_z)) >= 2) {  
      cor.test(MeHg_z, overall_merB_z, method = "spearman")$p.value  
    } else {  
      NA_real_  
    },  
    # Get max values safely  
    max_x = if(sum(!is.na(overall_merB_z)) > 0) max(overall_merB_z, na.rm = TRUE) else NA_real_,  
    max_y = if(sum(!is.na(MeHg_z)) > 0) max(MeHg_z, na.rm = TRUE) else NA_real_,  
    # Count number of complete cases  
    n_complete = sum(complete.cases(MeHg_z, overall_merB_z))  
  ) %>%  
  ungroup()  

# Print the correlation results  
print(merB_correlation_results)  

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables  
merB_MeHg_plot <- ggplot(data, aes(x = overall_merB_z, y = MeHg_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = merB_correlation_results %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,  
      y = -Inf,  
      label = paste("rho =", round(spearman_correlation, 3),  
                  "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1.1,  
    vjust = -0.5,  
    size = 3,  
    position = position_nudge(y = 0.05 * max(data$MeHg_z, na.rm = TRUE))  
  ) +  
  # Create separate panels for each site and type combination  
  facet_grid(type ~ site) +  # removed 'scales = "free"' since z-scores are standardized  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized merB Gene Abundance and MeHg",  
    x = "merB Gene Abundance (z-score)",  
    y = "MeHg concentration (z-score)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),  
    panel.grid.minor = element_blank(),  
    panel.grid.major = element_line(color = "gray90")  
  )  

merB_MeHg_plot

# Display the plot  
ggsave("output/merB_MeHg_standardized_plot.pdf", merB_MeHg_plot, width = 8, height = 4, unit = "in")
```

## correlation between MeHg/THg ratio and merB between sites and type (z-score transformation)
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)  # Ensure ggplot2 library is loaded  

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses_modified2.csv", header = TRUE)  

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))  
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))  

# Create standardized variables using z-scores  
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_THg_ratio_z = scale(MeHg_THg_ratio),
    overall_merB_z = scale(overall_merB)  
  ) %>%  
  ungroup()  


# Perform correlation using standardized variables  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Spearman correlation for standardized variables  
    spearman_correlation = cor.test(  
      MeHg_THg_ratio_z,  # Update to new variable
      overall_merB_z,  
      method = "spearman"  
    )$estimate,  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_THg_ratio_z,  # Update to new variable
      overall_merB_z,  
      method = "spearman"  
    )$p.value  
  )  

# Print the correlation coefficient and significance  
print(comprehensive_correlations)  

# Calculate correlation with standardized variables, handling potential missing combinations  
merB_correlation_results <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Only calculate if we have at least 2 pairs of values  
    spearman_correlation = if(sum(complete.cases(MeHg_THg_ratio_z, overall_merB_z)) >= 2) {  
      cor.test(MeHg_THg_ratio_z, overall_merB_z, method = "spearman")$estimate  
    } else {  
      NA_real_  
    },  
    spearman_p_values = if(sum(complete.cases(MeHg_THg_ratio_z, overall_merB_z)) >= 2) {  
      cor.test(MeHg_THg_ratio_z, overall_merB_z, method = "spearman")$p.value  
    } else {  
      NA_real_  
    },  
    # Get max values safely  
    max_x = if(sum(!is.na(overall_merB_z)) > 0) max(overall_merB_z, na.rm = TRUE) else NA_real_,  
    max_y = if(sum(!is.na(MeHg_THg_ratio_z)) > 0) max(MeHg_THg_ratio_z, na.rm = TRUE) else NA_real_,  
    # Count number of complete cases  
    n_complete = sum(complete.cases(MeHg_THg_ratio_z, overall_merB_z))  
  ) %>%  
  ungroup()  

# Print the correlation results  
print(merB_correlation_results)  

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables  
merB_MeHg_plot <- ggplot(data, aes(x = overall_merB_z, y = MeHg_THg_ratio_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = merB_correlation_results %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,  
      y = -Inf,  
      label = paste("rho =", round(spearman_correlation, 3),  
                    "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1.1,  
    vjust = -0.5,  
    size = 3,  
    position = position_nudge(y = 0.05 * max(data$MeHg_THg_ratio_z_z, na.rm = TRUE))  
  ) +  
  # Create separate panels for each site and type combination  
  facet_grid(type ~ site) +  # removed 'scales = "free"' since z-scores are standardized  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized merB Gene Abundance and MeHg_THg Ratio",  # Update title
    x = "merB Gene Abundance (z-score)",  
    y = "MeHg/THg Ratio (z-score)",  # Update Y-axis label
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),  
    panel.grid.minor = element_blank(),  
    panel.grid.major = element_line(color = "gray90")  
  )  

# Display the plot  
print(merB_MeHg_plot)  

# Save the plot  
ggsave("output/merB_MeHg_THg_standardized_plot.pdf", merB_MeHg_plot, width = 8, height = 4, unit = "in")  # Update file name

```

## correlation between MeHg and merB/hgcA ratio
```r

# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

data <- data %>%   
  filter(overall_merB != 0)  

data$hgcA_merB_ratio <- data$overall_merB / data$overall_hgcA
data$hgcA_merB_ratio <- data$overall_hgcA / data$overall_merB


# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and overall_hgcA  
    spearman_correlation = cor.test(  
      MeHg,   # Dependent variable (Mercury concentration)  
      hgcA_merB_ratio,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg,   
      hgcA_merB_ratio,   
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Calculate correlation, handling potential missing combinations safely  
merB_correlation_results <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Only calculate if we have at least 2 pairs of values  
    spearman_correlation = if(sum(complete.cases(MeHg, overall_merB)) >= 2) {  
      cor.test(MeHg, overall_merB, method = "spearman")$estimate  
    } else {  
      NA_real_  
    },  
    spearman_p_values = if(sum(complete.cases(MeHg, overall_merB)) >= 2) {  
      cor.test(MeHg, overall_merB, method = "spearman")$p.value  
    } else {  
      NA_real_  
    },  
    # Get max values safely  
    max_x = if(sum(!is.na(overall_merB)) > 0) max(overall_merB, na.rm = TRUE) else NA_real_,  
    max_y = if(sum(!is.na(MeHg)) > 0) max(MeHg, na.rm = TRUE) else NA_real_,  
    # Count number of complete cases  
    n_complete = sum(complete.cases(MeHg, overall_merB))  
  ) %>%  
  ungroup()  

# Print the correlation coefficient and significance  
print(merB_correlation_results)  

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with text in bottom right corner  
merB_MeHg_plot <- ggplot(data, aes(x = overall_merB, y = MeHg, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = merB_correlation_results %>% filter(!is.na(spearman_correlation)),  
    aes(  
      # Use normalized coordinates (1=right, 0=bottom)  
      x = Inf,  
      y = -Inf,  
      label = paste("rho =", round(spearman_correlation, 3),  
                   "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1.1,  # Right-align the text  
    vjust = -0.5,  # Position slightly above the bottom  
    size = 3,  
    position = position_nudge(y = 0.05 * max(data$MeHg, na.rm = TRUE))  # Add a small nudge upward  
  ) +  
  # Create separate panels for each site and type combination  
  facet_grid(type ~ site, scales = "free") +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between merB Gene Abundance and MeHg",  
    x = "merB Gene Abundance",  
    y = "MeHg concentration (ng/g)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),  
    panel.grid.minor = element_blank(),  # Remove minor grid lines  
    panel.grid.major = element_line(color = "gray90")  # Lighten major grid lines  
  )  

# Display the plot  

ggsave("output/merB_MeHg_plot.pdf", merB_MeHg_plot, width = 8, height = 4,unit = "in")  


```

## correlation between MeHg and aerobic methanotroph between sites and type (z-score transformation)
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Create standardized variables using z-scores
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_z = scale(MeHg),  
    aerobic_methanotroph_z = scale(overall_aerobic_methanotroph)  
  ) %>%  
  ungroup()

# Perform correlation using standardized variables  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Spearman correlation for standardized variables
    spearman_correlation = cor.test(  
      MeHg_z,   
      aerobic_methanotroph_z,   
      method = "spearman"  
    )$estimate,
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_z,   
      aerobic_methanotroph_z,   
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables
pmoA_MeHg_plot <- ggplot(data, aes(x = aerobic_methanotroph_z, y = MeHg_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = comprehensive_correlations %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,  
      y = -Inf,  
      label = paste("rho =", round(spearman_correlation, 3),  
                    "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1,  
    vjust = -0.5,  
    size = 3  
  ) +  
  # Create separate panels for each site and type combination
  # Remove 'scales = "free"' since z-scores are already standardized
  facet_grid(type ~ site) +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized Methanotroph Abundance and MeHg",
    x = "Aerobic methanotroph abundance (z-score)",  
    y = "MeHg concentration (z-score)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90")
  )  

# Display the plot  
print(pmoA_MeHg_plot)

# Save the plot
# ggsave("output/pmoA_MeHg_standardized_plot.pdf", pmoA_MeHg_plot, width = 8, height = 4, unit = "in")

```

## correlation between MeHg and aerobic methanotroph between sites and type (z-score transformation) flooded period only
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

data <- data[data$water == "Flooded", ]

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Create standardized variables using z-scores
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_z = scale(MeHg),  
    aerobic_methanotroph_z = scale(overall_aerobic_methanotroph)  
  ) %>%  
  ungroup()

# Perform correlation using standardized variables  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Spearman correlation for standardized variables
    spearman_correlation = cor.test(  
      MeHg_z,   
      aerobic_methanotroph_z,   
      method = "spearman"  
    )$estimate,
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_z,   
      aerobic_methanotroph_z,   
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables
pmoA_MeHg_plot_flooded <- ggplot(data, aes(x = aerobic_methanotroph_z, y = MeHg_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = comprehensive_correlations %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,  
      y = -Inf,  
      label = paste("rho =", round(spearman_correlation, 3),  
                    "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1,  
    vjust = -0.5,  
    size = 3  
  ) +  
  # Create separate panels for each site and type combination
  # Remove 'scales = "free"' since z-scores are already standardized
  facet_grid(type ~ site) +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized Methanotroph Abundance and MeHg",
    x = "Aerobic methanotroph abundance (z-score)",  
    y = "MeHg concentration (z-score)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90")
  )  

# Display the plot  
print(pmoA_MeHg_plot_flooded)

# Save the plot
# ggsave("output/pmoA_MeHg_standardized_plot_flooded.pdf", pmoA_MeHg_plot_flooded, width = 8, height = 4, unit = "in")

```

## correlation between MeHg/THg ratio and aerobic methanotroph between sites and type (z-score transformation)
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses_modified2.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Create standardized variables using z-scores
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_THg_ratio_z = scale(MeHg_THg_ratio),  
    aerobic_methanotroph_z = scale(overall_aerobic_methanotroph)  
  ) %>%  
  ungroup()

# Perform correlation using standardized variables  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Spearman correlation for standardized variables
    spearman_correlation = cor.test(  
      MeHg_THg_ratio_z,   
      aerobic_methanotroph_z,   
      method = "spearman"  
    )$estimate,
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_THg_ratio_z,   
      aerobic_methanotroph_z,   
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables
pmoA_MeHg_ratio_plot <- ggplot(data, aes(x = aerobic_methanotroph_z, y = MeHg_THg_ratio_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = comprehensive_correlations %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,  
      y = -Inf,  
      label = paste("rho =", round(spearman_correlation, 3),  
                    "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1,  
    vjust = -0.5,  
    size = 3  
  ) +  
  # Create separate panels for each site and type combination
  # Remove 'scales = "free"' since z-scores are already standardized
  facet_grid(type ~ site) +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized Methanotroph Abundance and MeHg/THg ratio",
    x = "Aerobic methanotroph abundance (z-score)",  
    y = "MeHg/THg ratio (z-score)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90")
  )  

# Display the plot  
print(pmoA_MeHg_ratio_plot)

# Save the plot
# ggsave("output/pmoA_MeHg_ratio_standardized_plot.pdf", pmoA_MeHg_ratio_plot, width = 8, height = 4, unit = "in")

```

## correlation between MeHg and specific aerobic methanotroph families between sites and type (z-score transformation)
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)
library(gridExtra)  # For combining plots

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses_modified2.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Define the methanotroph taxa of interest
methanotroph_taxa <- c("Methanoperedenaceae", "Methylomonadaceae", "Beijerinckiaceae", "Methylococcaceae")

# Create standardized variables for MeHg and all methanotroph taxa
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_z = scale(MeHg),  
    Methanoperedenaceae_z = scale(Methanoperedenaceae),
    Methylomonadaceae_z = scale(Methylomonadaceae),
    Beijerinckiaceae_z = scale(Beijerinckiaceae),
    Methylococcaceae_z = scale(Methylococcaceae)
  ) %>%  
  ungroup()

# Initialize empty dataframe for all correlations
all_correlations <- data.frame()

# Loop through each taxon and calculate correlations with error handling
for(taxon in methanotroph_taxa) {
  taxon_z_col <- paste0(taxon, "_z")
  
  # Calculate correlations for this taxon
  taxon_correlations <- data %>%  
    group_by(site, type) %>%
    summarise(  
      taxon = taxon,
      # Count valid observations
      n_valid = sum(!is.na(MeHg_z) & !is.na(!!sym(taxon_z_col)) & 
                    is.finite(MeHg_z) & is.finite(!!sym(taxon_z_col))),
      
      # Spearman correlation for standardized variables (with error handling)
      spearman_correlation = if(n_valid >= 3) {
        tryCatch({
          cor.test(MeHg_z, !!sym(taxon_z_col), method = "spearman")$estimate
        }, error = function(e) NA)
      } else {
        NA
      },
      
      # P-value for the same correlation (with error handling)
      spearman_p_values = if(n_valid >= 3) {
        tryCatch({
          cor.test(MeHg_z, !!sym(taxon_z_col), method = "spearman")$p.value
        }, error = function(e) NA)
      } else {
        NA
      },
      .groups = "drop"
    )
  
  # Add to overall results
  all_correlations <- rbind(all_correlations, taxon_correlations)
}

# Print all correlations
print("Correlation results for all methanotroph taxa:")
print(all_correlations)

# Print summary of data availability
print("\nData availability summary:")
all_correlations %>%
  group_by(taxon) %>%
  summarise(
    groups_with_data = sum(n_valid >= 3),
    groups_without_data = sum(n_valid < 3),
    total_groups = n()
  ) %>%
  print()

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Function to create individual plots for each taxon
create_taxon_plot <- function(taxon_name) {
  taxon_z_col <- paste0(taxon_name, "_z")
  
  # Get correlations for this taxon (only those with valid data)
  taxon_correlations <- all_correlations[all_correlations$taxon == taxon_name & 
                                         !is.na(all_correlations$spearman_correlation), ]
  
  # Create the plot
  p <- ggplot(data, aes_string(x = taxon_z_col, y = "MeHg_z", color = "site")) +  
    # Add points  
    geom_point(size = 2, alpha = 0.7) +  
    # Add regression lines  
    geom_smooth(method = "lm", se = FALSE, linetype = "dashed", size = 0.8) +  
    # Add correlation text at bottom right corner (only for valid correlations)
    {if(nrow(taxon_correlations) > 0) {
      geom_text(  
        data = taxon_correlations,  
        aes(  
          x = Inf,
          y = -Inf,
          label = paste("ρ =", round(spearman_correlation, 3),  
                        "\np =", round(spearman_p_values, 3)),  
          color = "black"  
        ),  
        hjust = 1,
        vjust = -0.5,
        size = 2.5,
        show.legend = FALSE,
        inherit.aes = FALSE
      )
    }} +
    # Create separate panels for each site and type combination
    facet_grid(type ~ site) +  
    # Apply your custom color scheme  
    scale_color_manual(values = site_colors) +  
    # Add labels and theming  
    labs(  
      title = paste("MeHg vs", taxon_name),
      x = paste(taxon_name, "abundance (z-score)"),  
      y = "MeHg concentration (z-score)",  
      color = "Site"  
    ) +  
    theme_minimal() +  
    theme(  
      panel.border = element_rect(colour = "black", fill = NA, size = 0.8),  
      legend.position = "bottom",  
      strip.background = element_rect(fill = "lightgray", color = "black"),  
      strip.text = element_text(face = "bold", size = 8),
      panel.grid.minor = element_blank(),
      panel.grid.major = element_line(color = "gray90"),
      plot.title = element_text(size = 10, face = "bold"),
      axis.title = element_text(size = 9),
      axis.text = element_text(size = 8),
      legend.text = element_text(size = 8),
      legend.title = element_text(size = 9)
    )
  
  return(p)
}

# Create individual plots for each taxon
individual_plots <- list()
for(i in seq_along(methanotroph_taxa)) {
  individual_plots[[i]] <- create_taxon_plot(methanotroph_taxa[i])
}
names(individual_plots) <- methanotroph_taxa

# Display individual plots
for(i in seq_along(individual_plots)) {
  print(individual_plots[[i]])
}

# Create a combined plot using grid.arrange
combined_plot <- do.call(grid.arrange, c(individual_plots, ncol = 2))

# Save individual plots
for(taxon in methanotroph_taxa) {
  filename <- paste0("output/MeHg_", gsub("[^A-Za-z0-9]", "_", taxon), "_correlation.pdf")
  ggsave(filename, individual_plots[[taxon]], width = 8, height = 4, units = "in")
}

# Save the combined plot
ggsave("output/MeHg_methanotroph_taxa_combined.pdf", combined_plot, width = 16, height = 12, units = "in")

# Create a summary table of correlations (only valid ones)
correlation_summary <- all_correlations[!is.na(all_correlations$spearman_correlation), ]

if(nrow(correlation_summary) > 0) {
  correlation_summary$correlation_strength <- ifelse(abs(correlation_summary$spearman_correlation) >= 0.7, "Strong",
                                            ifelse(abs(correlation_summary$spearman_correlation) >= 0.5, "Moderate",
                                            ifelse(abs(correlation_summary$spearman_correlation) >= 0.3, "Weak", "Very weak")))
  
  correlation_summary$significance <- ifelse(correlation_summary$spearman_p_values < 0.001, "***",
                                   ifelse(correlation_summary$spearman_p_values < 0.01, "**",
                                   ifelse(correlation_summary$spearman_p_values < 0.05, "*", "ns")))
  
  correlation_summary <- correlation_summary[order(correlation_summary$taxon, correlation_summary$site, correlation_summary$type), ]
  
  print("Summary of valid correlations:")
  print(correlation_summary)
  
  # Save correlation summary
  write.csv(correlation_summary, "output/methanotroph_MeHg_correlation_summary.csv", row.names = FALSE)
} else {
  print("No valid correlations found!")
}
```

## correlation between MeHg and specific aerobic methanotroph families between sites and type (z-score transformation) flooded period only
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)
library(gridExtra)  # For combining plots

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses_modified2.csv", header = TRUE)

data <- data[data$water == "Flooded", ]

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Define the methanotroph taxa of interest
methanotroph_taxa <- c("Methanoperedenaceae", "Methylomonadaceae", "Beijerinckiaceae", "Methylococcaceae")

# Create standardized variables for MeHg and all methanotroph taxa
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_z = scale(MeHg),  
    Methanoperedenaceae_z = scale(Methanoperedenaceae),
    Methylomonadaceae_z = scale(Methylomonadaceae),
    Beijerinckiaceae_z = scale(Beijerinckiaceae),
    Methylococcaceae_z = scale(Methylococcaceae)
  ) %>%  
  ungroup()

# Initialize empty dataframe for all correlations
all_correlations <- data.frame()

# Loop through each taxon and calculate correlations with error handling
for(taxon in methanotroph_taxa) {
  taxon_z_col <- paste0(taxon, "_z")
  
  # Calculate correlations for this taxon
  taxon_correlations <- data %>%  
    group_by(site, type) %>%
    summarise(  
      taxon = taxon,
      # Count valid observations
      n_valid = sum(!is.na(MeHg_z) & !is.na(!!sym(taxon_z_col)) & 
                    is.finite(MeHg_z) & is.finite(!!sym(taxon_z_col))),
      
      # Spearman correlation for standardized variables (with error handling)
      spearman_correlation = if(n_valid >= 3) {
        tryCatch({
          cor.test(MeHg_z, !!sym(taxon_z_col), method = "spearman")$estimate
        }, error = function(e) NA)
      } else {
        NA
      },
      
      # P-value for the same correlation (with error handling)
      spearman_p_values = if(n_valid >= 3) {
        tryCatch({
          cor.test(MeHg_z, !!sym(taxon_z_col), method = "spearman")$p.value
        }, error = function(e) NA)
      } else {
        NA
      },
      .groups = "drop"
    )
  
  # Add to overall results
  all_correlations <- rbind(all_correlations, taxon_correlations)
}

# Print all correlations
print("Correlation results for all methanotroph taxa:")
print(all_correlations)

# Print summary of data availability
print("\nData availability summary:")
all_correlations %>%
  group_by(taxon) %>%
  summarise(
    groups_with_data = sum(n_valid >= 3),
    groups_without_data = sum(n_valid < 3),
    total_groups = n()
  ) %>%
  print()

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Function to create individual plots for each taxon
create_taxon_plot <- function(taxon_name) {
  taxon_z_col <- paste0(taxon_name, "_z")
  
  # Get correlations for this taxon (only those with valid data)
  taxon_correlations <- all_correlations[all_correlations$taxon == taxon_name & 
                                         !is.na(all_correlations$spearman_correlation), ]
  
  # Create the plot
  p <- ggplot(data, aes_string(x = taxon_z_col, y = "MeHg_z", color = "site")) +  
    # Add points  
    geom_point(size = 2, alpha = 0.7) +  
    # Add regression lines  
    geom_smooth(method = "lm", se = FALSE, linetype = "dashed", size = 0.8) +  
    # Add correlation text at bottom right corner (only for valid correlations)
    {if(nrow(taxon_correlations) > 0) {
      geom_text(  
        data = taxon_correlations,  
        aes(  
          x = Inf,
          y = -Inf,
          label = paste("ρ =", round(spearman_correlation, 3),  
                        "\np =", round(spearman_p_values, 3)),  
          color = "black"  
        ),  
        hjust = 1,
        vjust = -0.5,
        size = 2.5,
        show.legend = FALSE,
        inherit.aes = FALSE
      )
    }} +
    # Create separate panels for each site and type combination
    facet_grid(type ~ site) +  
    # Apply your custom color scheme  
    scale_color_manual(values = site_colors) +  
    # Add labels and theming  
    labs(  
      title = paste("MeHg vs", taxon_name),
      x = paste(taxon_name, "abundance (z-score)"),  
      y = "MeHg concentration (z-score)",  
      color = "Site"  
    ) +  
    theme_minimal() +  
    theme(  
      panel.border = element_rect(colour = "black", fill = NA, size = 0.8),  
      legend.position = "bottom",  
      strip.background = element_rect(fill = "lightgray", color = "black"),  
      strip.text = element_text(face = "bold", size = 8),
      panel.grid.minor = element_blank(),
      panel.grid.major = element_line(color = "gray90"),
      plot.title = element_text(size = 10, face = "bold"),
      axis.title = element_text(size = 9),
      axis.text = element_text(size = 8),
      legend.text = element_text(size = 8),
      legend.title = element_text(size = 9)
    )
  
  return(p)
}

# Create individual plots for each taxon
individual_plots <- list()
for(i in seq_along(methanotroph_taxa)) {
  individual_plots[[i]] <- create_taxon_plot(methanotroph_taxa[i])
}
names(individual_plots) <- methanotroph_taxa

# Display individual plots
for(i in seq_along(individual_plots)) {
  print(individual_plots[[i]])
}

# Create a combined plot using grid.arrange
combined_plot <- do.call(grid.arrange, c(individual_plots, ncol = 2))

# Save individual plots
for(taxon in methanotroph_taxa) {
  filename <- paste0("output/MeHg_", gsub("[^A-Za-z0-9]", "_", taxon), "_correlation.pdf")
  ggsave(filename, individual_plots[[taxon]], width = 8, height = 4, units = "in")
}

# Save the combined plot
ggsave("output/MeHg_methanotroph_taxa_combined.pdf", combined_plot, width = 16, height = 12, units = "in")

# Create a summary table of correlations (only valid ones)
correlation_summary <- all_correlations[!is.na(all_correlations$spearman_correlation), ]

if(nrow(correlation_summary) > 0) {
  correlation_summary$correlation_strength <- ifelse(abs(correlation_summary$spearman_correlation) >= 0.7, "Strong",
                                            ifelse(abs(correlation_summary$spearman_correlation) >= 0.5, "Moderate",
                                            ifelse(abs(correlation_summary$spearman_correlation) >= 0.3, "Weak", "Very weak")))
  
  correlation_summary$significance <- ifelse(correlation_summary$spearman_p_values < 0.001, "***",
                                   ifelse(correlation_summary$spearman_p_values < 0.01, "**",
                                   ifelse(correlation_summary$spearman_p_values < 0.05, "*", "ns")))
  
  correlation_summary <- correlation_summary[order(correlation_summary$taxon, correlation_summary$site, correlation_summary$type), ]
  
  print("Summary of valid correlations:")
  print(correlation_summary)
  
  # Save correlation summary
  write.csv(correlation_summary, "output/methanotroph_MeHg_correlation_summary.csv", row.names = FALSE)
} else {
  print("No valid correlations found!")
}
```

## correlation between MeHg and aerobic methanotroph mbnT between sites and type (z-score transformation)
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Create standardized variables using z-scores
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_z = scale(MeHg),  
    mbnT_z = scale(overall_aerobic_methanotroph_mbnT)  
  ) %>%  
  ungroup()

# Perform correlation using standardized variables
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Spearman correlation for standardized variables
    spearman_correlation = cor.test(  
      MeHg_z,
      mbnT_z,
      method = "spearman"  
    )$estimate,
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_z,
      mbnT_z,
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables
mbnT_MeHg_plot <- ggplot(data, aes(x = mbnT_z, y = MeHg_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = comprehensive_correlations %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,
      y = -Inf,
      label = paste("rho =", round(spearman_correlation, 3),  
                    "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1,
    vjust = -0.5,
    size = 3  
  ) +  
  # Create separate panels for each site and type combination  
  # Remove scales="free" since z-scores are standardized
  facet_grid(type ~ site) +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized Methanotroph mbnT and MeHg",
    x = "Aerobic methanotroph mbnT abundance (z-score)",  
    y = "MeHg concentration (z-score)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90")
  )  

# Display the plot  
print(mbnT_MeHg_plot)

# Save the plot
ggsave("output/mbnT_MeHg_standardized_plot.pdf", mbnT_MeHg_plot, width = 8, height = 4, unit = "in")

```

## correlation between MeHg and aerobic methanotroph mbnT (TIGRFAM) between sites and type (z-score transformation)
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Create standardized variables using z-scores
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_z = scale(MeHg),  
    mbnT_z = scale(overall_mbnT_TIGRFAM)  
  ) %>%  
  ungroup()

# Perform correlation using standardized variables
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Spearman correlation for standardized variables
    spearman_correlation = cor.test(  
      MeHg_z,
      mbnT_z,
      method = "spearman"  
    )$estimate, 
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_z,
      mbnT_z,
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables
mbnT_MeHg_plot <- ggplot(data, aes(x = mbnT_z, y = MeHg_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = comprehensive_correlations %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,
      y = -Inf,
      label = paste("rho =", round(spearman_correlation, 3),  
                    "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1,
    vjust = -0.5,
    size = 3  
  ) +  
  # Create separate panels for each site and type combination  
  # Remove scales="free" since z-scores are standardized
  facet_grid(type ~ site) +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized Methanotroph mbnT and MeHg",
    x = "Aerobic methanotroph mbnT abundance (z-score)",  
    y = "MeHg concentration (z-score)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90")
  )  

# Display the plot  
print(mbnT_MeHg_plot)

# Save the plot
# ggsave("output/mbnT_TIGRFAM_MeHg_standardized_plot.pdf", mbnT_MeHg_plot, width = 8, height = 4, unit = "in")

```

## correlation between MeHg and aerobic methanotroph mbnT between sites and type (z-score transformation) flooded period only
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

data <- data[data$water == "Flooded", ]

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Create standardized variables using z-scores
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_z = scale(MeHg),  
    mbnT_z = scale(overall_aerobic_methanotroph_mbnT)  
  ) %>%  
  ungroup()

# Perform correlation using standardized variables
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Spearman correlation for standardized variables
    spearman_correlation = cor.test(  
      MeHg_z,
      mbnT_z,
      method = "spearman"  
    )$estimate,
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_z,
      mbnT_z,
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables
mbnT_MeHg_plot_flooded <- ggplot(data, aes(x = mbnT_z, y = MeHg_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = comprehensive_correlations %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,
      y = -Inf,
      label = paste("rho =", round(spearman_correlation, 3),  
                    "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1,
    vjust = -0.5,
    size = 3  
  ) +  
  # Create separate panels for each site and type combination  
  # Remove scales="free" since z-scores are standardized
  facet_grid(type ~ site) +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized Methanotroph mbnT and MeHg",
    x = "Aerobic methanotroph mbnT abundance (z-score)",  
    y = "MeHg concentration (z-score)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90")
  )  

# Display the plot  
print(mbnT_MeHg_plot_flooded)

# Save the plot
ggsave("output/mbnT_MeHg_standardized_plot_flooded.pdf", mbnT_MeHg_plot_flooded, width = 8, height = 4, unit = "in")

```

## correlation between MeHg and aerobic methanotroph mbnT (TIGRFAM) between sites and type (z-score transformation) flooded period only
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

data <- data[data$water == "Flooded", ]

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Create standardized variables using z-scores
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_z = scale(MeHg),  
    mbnT_z = scale(overall_mbnT_TIGRFAM)  
  ) %>%  
  ungroup()

# Perform correlation using standardized variables
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Spearman correlation for standardized variables
    spearman_correlation = cor.test(  
      MeHg_z,
      mbnT_z,
      method = "spearman"  
    )$estimate,
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_z,
      mbnT_z,
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables
mbnT_MeHg_plot_flooded <- ggplot(data, aes(x = mbnT_z, y = MeHg_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = comprehensive_correlations %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,
      y = -Inf,
      label = paste("rho =", round(spearman_correlation, 3),  
                    "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1,
    vjust = -0.5,
    size = 3  
  ) +  
  # Create separate panels for each site and type combination  
  # Remove scales="free" since z-scores are standardized
  facet_grid(type ~ site) +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized Methanotroph mbnT and MeHg",
    x = "Aerobic methanotroph mbnT abundance (z-score)",  
    y = "MeHg concentration (z-score)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90")
  )  

# Display the plot  
print(mbnT_MeHg_plot_flooded)

# Save the plot
# ggsave("output/mbnT_TIGRFAM_MeHg_standardized_plot_flooded.pdf", mbnT_MeHg_plot_flooded, width = 8, height = 4, unit = "in")

```

## correlation between MeHg and taxa-specific aerobic methanotroph mbnT between sites and type (z-score transformation)
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)
library(gridExtra)  # For combining plots

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses_modified2.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Define the methanotroph taxa with mbnT of interest
methanotroph_mbnT_taxa <- c("Beijerinckiaceae_mbnT", "Methylococcaceae_mbnT", "Methylomirabilaceae_mbnT", 
                            "Methylomonadaceae_mbnT", "Methyloligellaceae_mbnT", "Methylopilaceae_mbnT")

# Create standardized variables for MeHg and all methanotroph mbnT taxa
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_z = scale(MeHg),  
    Beijerinckiaceae_mbnT_z = scale(Beijerinckiaceae_mbnT),
    Methylococcaceae_mbnT_z = scale(Methylococcaceae_mbnT),
    Methylomirabilaceae_mbnT_z = scale(Methylomirabilaceae_mbnT),
    Methylomonadaceae_mbnT_z = scale(Methylomonadaceae_mbnT),
    Methyloligellaceae_mbnT_z = scale(Methyloligellaceae_mbnT),
    Methylopilaceae_mbnT_z = scale(Methylopilaceae_mbnT)
  ) %>%  
  ungroup()

# Initialize empty dataframe for all correlations
all_correlations <- data.frame()

# Loop through each taxon and calculate correlations with error handling
for(taxon in methanotroph_mbnT_taxa) {
  taxon_z_col <- paste0(taxon, "_z")
  
  # Calculate correlations for this taxon
  taxon_correlations <- data %>%  
    group_by(site, type) %>%
    summarise(  
      taxon = taxon,
      # Count valid observations
      n_valid = sum(!is.na(MeHg_z) & !is.na(!!sym(taxon_z_col)) & 
                    is.finite(MeHg_z) & is.finite(!!sym(taxon_z_col))),
      
      # Spearman correlation for standardized variables (with error handling)
      spearman_correlation = if(n_valid >= 3) {
        tryCatch({
          cor.test(MeHg_z, !!sym(taxon_z_col), method = "spearman")$estimate
        }, error = function(e) NA)
      } else {
        NA
      },
      
      # P-value for the same correlation (with error handling)
      spearman_p_values = if(n_valid >= 3) {
        tryCatch({
          cor.test(MeHg_z, !!sym(taxon_z_col), method = "spearman")$p.value
        }, error = function(e) NA)
      } else {
        NA
      },
      .groups = "drop"
    )
  
  # Add to overall results
  all_correlations <- rbind(all_correlations, taxon_correlations)
}

# Print all correlations
print("Correlation results for all methanotroph mbnT taxa:")
print(all_correlations)

# Print summary of data availability
print("\nData availability summary:")
all_correlations %>%
  group_by(taxon) %>%
  summarise(
    groups_with_data = sum(n_valid >= 3),
    groups_without_data = sum(n_valid < 3),
    total_groups = n()
  ) %>%
  print()

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Function to create individual plots for each taxon
create_taxon_plot <- function(taxon_name) {
  taxon_z_col <- paste0(taxon_name, "_z")
  
  # Get correlations for this taxon (only those with valid data)
  taxon_correlations <- all_correlations[all_correlations$taxon == taxon_name & 
                                         !is.na(all_correlations$spearman_correlation), ]
  
  # Create the plot
  p <- ggplot(data, aes_string(x = taxon_z_col, y = "MeHg_z", color = "site")) +  
    # Add points  
    geom_point(size = 2, alpha = 0.7) +  
    # Add regression lines  
    geom_smooth(method = "lm", se = FALSE, linetype = "dashed", size = 0.8) +  
    # Add correlation text at bottom right corner (only for valid correlations)
    {if(nrow(taxon_correlations) > 0) {
      geom_text(  
        data = taxon_correlations,  
        aes(  
          x = Inf,
          y = -Inf,
          label = paste("ρ =", round(spearman_correlation, 3),  
                        "\np =", round(spearman_p_values, 3)),  
          color = "black"  
        ),  
        hjust = 1,
        vjust = -0.5,
        size = 2.5,
        show.legend = FALSE,
        inherit.aes = FALSE
      )
    }} +
    # Create separate panels for each site and type combination
    facet_grid(type ~ site) +  
    # Apply your custom color scheme  
    scale_color_manual(values = site_colors) +  
    # Add labels and theming  
    labs(  
      title = paste("MeHg vs", taxon_name),
      x = paste(taxon_name, "abundance (z-score)"),  
      y = "MeHg concentration (z-score)",  
      color = "Site"  
    ) +  
    theme_minimal() +  
    theme(  
      panel.border = element_rect(colour = "black", fill = NA, size = 0.8),  
      legend.position = "bottom",  
      strip.background = element_rect(fill = "lightgray", color = "black"),  
      strip.text = element_text(face = "bold", size = 8),
      panel.grid.minor = element_blank(),
      panel.grid.major = element_line(color = "gray90"),
      plot.title = element_text(size = 10, face = "bold"),
      axis.title = element_text(size = 9),
      axis.text = element_text(size = 8),
      legend.text = element_text(size = 8),
      legend.title = element_text(size = 9)
    )
  
  return(p)
}

# Create individual plots for each taxon
individual_plots <- list()
for(i in seq_along(methanotroph_mbnT_taxa)) {
  individual_plots[[i]] <- create_taxon_plot(methanotroph_mbnT_taxa[i])
}
names(individual_plots) <- methanotroph_mbnT_taxa

# Display individual plots
for(i in seq_along(individual_plots)) {
  print(individual_plots[[i]])
}

# Create a combined plot using grid.arrange
combined_plot <- do.call(grid.arrange, c(individual_plots, ncol = 2))

# Save individual plots
for(taxon in methanotroph_mbnT_taxa) {
  filename <- paste0("output/MeHg_", gsub("[^A-Za-z0-9]", "_", taxon), "_correlation.pdf")
  ggsave(filename, individual_plots[[taxon]], width = 8, height = 4, units = "in")
}

# Save the combined plot
ggsave("output/MeHg_methanotroph_mbnT_taxa_combined.pdf", combined_plot, width = 16, height = 18, units = "in")

# Create a summary table of correlations (only valid ones)
correlation_summary <- all_correlations[!is.na(all_correlations$spearman_correlation), ]

if(nrow(correlation_summary) > 0) {
  correlation_summary$correlation_strength <- ifelse(abs(correlation_summary$spearman_correlation) >= 0.7, "Strong",
                                            ifelse(abs(correlation_summary$spearman_correlation) >= 0.5, "Moderate",
                                            ifelse(abs(correlation_summary$spearman_correlation) >= 0.3, "Weak", "Very weak")))
  
  correlation_summary$significance <- ifelse(correlation_summary$spearman_p_values < 0.001, "***",
                                   ifelse(correlation_summary$spearman_p_values < 0.01, "**",
                                   ifelse(correlation_summary$spearman_p_values < 0.05, "*", "ns")))
  
  correlation_summary <- correlation_summary[order(correlation_summary$taxon, correlation_summary$site, correlation_summary$type), ]
  
  print("Summary of valid correlations:")
  print(correlation_summary)
  
  # Save correlation summary
  write.csv(correlation_summary, "output/methanotroph_mbnT_MeHg_correlation_summary.csv", row.names = FALSE)
} else {
  print("No valid correlations found!")
}
```

## correlation between MeHg/THg ratio and aerobic methanotroph mbnT between sites and type (z-score transformation)
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses_modified2.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Create standardized variables using z-scores
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_THg_ratio_z = scale(MeHg_THg_ratio),  
    mbnT_z = scale(overall_aerobic_methanotroph_mbnT)  
  ) %>%  
  ungroup()

# Perform correlation using standardized variables
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Spearman correlation for standardized variables
    spearman_correlation = cor.test(  
      MeHg_THg_ratio_z,
      mbnT_z,
      method = "spearman"  
    )$estimate,
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_THg_ratio_z,
      mbnT_z,
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables
mbnT_MeHg_ratio_plot <- ggplot(data, aes(x = mbnT_z, y = MeHg_THg_ratio_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = comprehensive_correlations %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,
      y = -Inf,
      label = paste("rho =", round(spearman_correlation, 3),  
                    "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1,
    vjust = -0.5,
    size = 3  
  ) +  
  # Create separate panels for each site and type combination  
  # Remove scales="free" since z-scores are standardized
  facet_grid(type ~ site) +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized Methanotroph mbnT and MeHg/THg ratio",
    x = "Aerobic methanotroph mbnT abundance (z-score)",  
    y = "MeHg/THg ratio (z-score)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90")
  )  

# Display the plot  
print(mbnT_MeHg_ratio_plot)

# Save the plot
ggsave("output/mbnT_MeHg_ratio_standardized_plot.pdf", mbnT_MeHg_ratio_plot, width = 8, height = 4, unit = "in")

```

## correlation between MeHg/THg ratio and aerobic methanotroph mbnT (TIGRFAM) between sites and type (z-score transformation)
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)

# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses_modified2.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# Create standardized variables using z-scores
data <- data %>%  
  group_by(site, type) %>%  
  mutate(  
    MeHg_THg_ratio_z = scale(MeHg_THg_ratio),  
    mbnT_z = scale(overall_mbnT_TIGRFAM)  
  ) %>%  
  ungroup()

# Perform correlation using standardized variables
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Spearman correlation for standardized variables
    spearman_correlation = cor.test(  
      MeHg_THg_ratio_z,
      mbnT_z,
      method = "spearman"  
    )$estimate,
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg_THg_ratio_z,
      mbnT_z,
      method = "spearman"  
    )$p.value  
  )  

# print the correlation coefficient and significance
print(comprehensive_correlations) 

# Specify your color palette  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# Create the faceted plot with standardized variables
mbnT_MeHg_ratio_plot <- ggplot(data, aes(x = mbnT_z, y = MeHg_THg_ratio_z, color = site)) +  
  # Add points  
  geom_point(size = 3, alpha = 0.7) +  
  # Add regression lines  
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +  
  # Add correlation text at bottom right corner  
  geom_text(  
    data = comprehensive_correlations %>% filter(!is.na(spearman_correlation)),  
    aes(  
      x = Inf,
      y = -Inf,
      label = paste("rho =", round(spearman_correlation, 3),  
                    "\np =", round(spearman_p_values, 3)),  
      color = "black"  
    ),  
    hjust = 1,
    vjust = -0.5,
    size = 3  
  ) +  
  # Create separate panels for each site and type combination  
  # Remove scales="free" since z-scores are standardized
  facet_grid(type ~ site) +  
  # Apply your custom color scheme  
  scale_color_manual(values = site_colors) +  
  # Add labels and theming  
  labs(  
    title = "Correlation Between Standardized Methanotroph mbnT and MeHg/THg ratio",
    x = "Aerobic methanotroph mbnT abundance (z-score)",  
    y = "MeHg/THg ratio (z-score)",  
    color = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),  
    legend.position = "bottom",  
    strip.background = element_rect(fill = "lightgray", color = "black"),  
    strip.text = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90")
  )  

# Display the plot  
print(mbnT_MeHg_ratio_plot)

# Save the plot
# ggsave("output/mbnT_TIGRFAM_MeHg_ratio_standardized_plot.pdf", mbnT_MeHg_ratio_plot, width = 8, height = 4, unit = "in")

```




## composite figures for mcrA, pmoA, mbnT MeHg correlation
```r
library("patchwork")
# Remove the legend from the top and middle plots  
mcrA_MeHg_plot <- mcrA_MeHg_plot + theme(legend.position = "none")  
pmoA_MeHg_plot <- pmoA_MeHg_plot + theme(legend.position = "none")  
# Keep the legend in the bottom plot  
mbnT_MeHg_plot <- mbnT_MeHg_plot + theme(legend.position = "bottom")  

# Create the composite figure with plots arranged in one column  
composite_figure <- mcrA_MeHg_plot / pmoA_MeHg_plot / mbnT_MeHg_plot +  
  # Add common plot labels if needed  
  plot_annotation(  
    tag_levels = 'A'  # Add A, B, C labels to the plots  
  ) +  
  # Adjust the layout to give equal space to each plot  
  plot_layout(ncol = 1, heights = c(1, 1, 1.2))  # Slightly more height for bottom plot with legend  

# Print or save the composite figure  
print(composite_figure) 

ggsave("output/mcrA_pmoA_mbnT_MeHg_correlation.pdf", composite_figure, width = 8, height = 10,unit = "in")  


```

## composite figures for mcrA, pmoA, mbnT MeHg correlation (flooded period only)
```r
library("patchwork")
# Remove the legend from the top and middle plots  
mcrA_MeHg_plot_flooded <- mcrA_MeHg_plot_flooded + theme(legend.position = "none")  
pmoA_MeHg_plot_flooded <- pmoA_MeHg_plot_flooded + theme(legend.position = "none")  
# Keep the legend in the bottom plot  
mbnT_MeHg_plot_flooded <- mbnT_MeHg_plot_flooded + theme(legend.position = "bottom")  

# Create the composite figure with plots arranged in one column  
composite_figure <- mcrA_MeHg_plot_flooded / pmoA_MeHg_plot_flooded / mbnT_MeHg_plot_flooded +  
  # Add common plot labels if needed  
  plot_annotation(  
    tag_levels = 'A'  # Add A, B, C labels to the plots  
  ) +  
  # Adjust the layout to give equal space to each plot  
  plot_layout(ncol = 1, heights = c(1, 1, 1.2))  # Slightly more height for bottom plot with legend  

# Print or save the composite figure  
print(composite_figure) 

ggsave("output/mcrA_pmoA_mbnT_MeHg_correlation_flooded.pdf", composite_figure, width = 8, height = 10,unit = "in")  


```

## composite figures for mcrA, pmoA, mbnT MeHg/THg ratio correlation
```r
library("patchwork")
# Remove the legend from the top and middle plots  
mcrA_MeHg_ratio_plot <- mcrA_MeHg_ratio_plot + theme(legend.position = "none")  
pmoA_MeHg_ratio_plot <- pmoA_MeHg_ratio_plot + theme(legend.position = "none")  
# Keep the legend in the bottom plot  
mbnT_MeHg_ratio_plot <- mbnT_MeHg_ratio_plot + theme(legend.position = "bottom")  

# Create the composite figure with plots arranged in one column  
composite_figure <- mcrA_MeHg_ratio_plot / pmoA_MeHg_ratio_plot / mbnT_MeHg_ratio_plot +  
  # Add common plot labels if needed  
  plot_annotation(  
    tag_levels = 'A'  # Add A, B, C labels to the plots  
  ) +  
  # Adjust the layout to give equal space to each plot  
  plot_layout(ncol = 1, heights = c(1, 1, 1.2))  # Slightly more height for bottom plot with legend  

# Print or save the composite figure  
print(composite_figure) 

ggsave("output/mcrA_pmoA_mbnT_MeHg_ratio_correlation.pdf", composite_figure, width = 8, height = 10,unit = "in")  


```

## correlation between MeHg and modified SRB, IRB and methanogen hgcA, and plot
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)  
library(patchwork)
library(forcats) # For factor reordering  


# Read the CSV  
data <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# applying library size correction (optional)
#data$overall_hgcA = data$overall_hgcA * data$library_correction_value
#data$overall_SRB_hgcA = data$overall_SRB_hgcA * data$library_correction_value
#data$overall_IRB_hgcA = data$overall_IRB_hgcA * data$library_correction_value
#data$overall_methanogen_hgcA = data$overall_methanogen_hgcA * data$library_correction_value


# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and overall_hgcA  
    spearman_correlation = cor.test(  
      MeHg,   # Dependent variable (Mercury concentration)  
      overall_hgcA,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg,   
      overall_hgcA,   
      method = "spearman"  
    )$p.value  
  )  


# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and overall_hgcA  
    spearman_correlation = cor.test(  
      MeHg,   # Dependent variable (Mercury concentration)  
      overall_SRB_hgcA,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg,   
      overall_hgcA,   
      method = "spearman"  
    )$p.value  
  )  


# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and overall_hgcA  
    spearman_correlation = cor.test(  
      MeHg,   # Dependent variable (Mercury concentration)  
      overall_IRB_hgcA,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg,   
      overall_hgcA,   
      method = "spearman"  
    )$p.value  
  )  

# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and overall_hgcA  
    spearman_correlation = cor.test(  
      MeHg,   # Dependent variable (Mercury concentration)  
      overall_methanogen_hgcA,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg,   
      overall_hgcA,   
      method = "spearman"  
    )$p.value  
  )  


# Calculate correlations between MeHg and each gene type  
correlation_data <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Overall hgcA  
    overall_hgcA_cor = cor.test(MeHg, overall_hgcA, method = "spearman")$estimate,  
    overall_hgcA_pval = cor.test(MeHg, overall_hgcA, method = "spearman")$p.value,  
    
    # SRB hgcA  
    SRB_hgcA_cor = cor.test(MeHg, overall_SRB_hgcA, method = "spearman")$estimate,  
    SRB_hgcA_pval = cor.test(MeHg, overall_SRB_hgcA, method = "spearman")$p.value,  
    
    # IRB hgcA  
    IRB_hgcA_cor = cor.test(MeHg, overall_IRB_hgcA, method = "spearman")$estimate,  
    IRB_hgcA_pval = cor.test(MeHg, overall_IRB_hgcA, method = "spearman")$p.value,  
    
    # Methanogen hgcA  
    methanogen_hgcA_cor = cor.test(MeHg, overall_methanogen_hgcA, method = "spearman")$estimate,  
    methanogen_hgcA_pval = cor.test(MeHg, overall_methanogen_hgcA, method = "spearman")$p.value  
  )  

# Reshape the data for plotting  
correlation_long <- correlation_data %>%  
  pivot_longer(  
    cols = contains("_cor"),  
    names_to = "gene_type",  
    values_to = "correlation"  
  ) %>%  
  mutate(  
    gene_type = case_when(  
      gene_type == "overall_hgcA_cor" ~ "Overall hgcA",  
      gene_type == "SRB_hgcA_cor" ~ "SRB hgcA",  
      gene_type == "IRB_hgcA_cor" ~ "IRB hgcA",  
      gene_type == "methanogen_hgcA_cor" ~ "Methanogen hgcA"  
    )  
  )  

# Get corresponding p-values  
p_values_long <- correlation_data %>%  
  pivot_longer(  
    cols = contains("_pval"),  
    names_to = "gene_type",  
    values_to = "p_value"  
  ) %>%  
  mutate(  
    gene_type = case_when(  
      gene_type == "overall_hgcA_pval" ~ "Overall hgcA",  
      gene_type == "SRB_hgcA_pval" ~ "SRB hgcA",  
      gene_type == "IRB_hgcA_pval" ~ "IRB hgcA",  
      gene_type == "methanogen_hgcA_pval" ~ "Methanogen hgcA"  
    )  
  )  

# Combine correlation and p-values  
plot_data <- left_join(correlation_long, p_values_long, by = c("site", "type", "gene_type"))  

# Add significance indicators  
plot_data <- plot_data %>%  
  mutate(significance = case_when(  
    p_value < 0.001 ~ "***",  
    p_value < 0.01 ~ "**",  
    p_value < 0.05 ~ "*",  
    TRUE ~ "ns"  
  ))  

# Set the specific order for gene_type  
plot_data$gene_type <- factor(plot_data$gene_type,   
                             levels = c("Overall hgcA", "SRB hgcA", "IRB hgcA", "Methanogen hgcA"))  

# Create bar plot of correlations - vertical layout (top to bottom)  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

hgcA_MeHg_correlation_bar_plot <- ggplot(plot_data, aes(x = site, y = correlation, fill = site)) +  
  geom_bar(stat = "identity", position = position_dodge()) +  
  geom_text(aes(label = significance, y = correlation + 0.05 * sign(correlation)),  
            position = position_dodge(width = 0.9)) +  
  facet_grid(gene_type ~ type) +  # gene_type on rows, type on columns  
  scale_fill_manual(values = site_colors) +  
  labs(  
    x = "Site",   
    y = "Correlation Coefficient",   
    fill = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),   # Remove major grid lines  
    axis.text.x = element_text(  
      angle = 90,   
      size = 10,   
      colour = "black",   
      vjust = 0.5,   
      hjust = 0.5  
    ),   
    axis.title.x = element_text(size = 10),   
    axis.title.y = element_text(size = 10),   
    legend.title = element_text(size = 10, face="bold"),   
    legend.text = element_text(size = 10, colour = "black"),   
    axis.text.y = element_text(colour = "black", size = 10),  
    legend.key.size = unit(0.25, 'cm'),  
    strip.text.y = element_text(angle = 270, size = 10, hjust = 0.5, vjust = 0.5),  # Rotated y-axis strip text  
    strip.text.x = element_text(size = 10),  
    legend.position = "bottom"  
  )

hgcA_MeHg_correlation_bar_plot

```

## combined plot between hgcA taxonomic distribution and correlation coefficient (see chunk above)
```r
# Load patchwork for combining plots  
library(patchwork)  
library(ggplot2)

# Customize themes for better appearance  
base_theme <- theme(  
  text = element_text(family = "Helvetica", size = 12), 
  plot.title = element_blank(),  # Remove plot title  
  panel.grid.minor = element_blank(),  
  panel.grid.major = element_line(size = 0.1, linetype = 'dotted'),  
  panel.border = element_rect(color = "gray", fill = NA, size = 0.5),  
  axis.ticks = element_line(color = "black"),  
  axis.text = element_text(size = 11, color = "black"),  
  legend.title = element_text(face = "bold"),  
  legend.text = element_text(size = 11),  
  strip.background = element_rect(fill = "lightgray", color = "gray")  
)  

# Apply the base theme to the existing ggplot themes  
gy21_hgcA_barplot <- gy21_hgcA_barplot + base_theme  
hgcA_MeHg_correlation_bar_plot <- hgcA_MeHg_correlation_bar_plot + base_theme  

# Combine plots with patchwork  
combined_plot <- (gy21_hgcA_barplot | hgcA_MeHg_correlation_bar_plot) +   
  plot_layout(widths = c(0.7, 0.3)) +  # Make first plot narrower  
  plot_annotation(tag_levels = "A")     # Add A, B labels to plots  

combined_plot

ggsave("output/hgcA_taxonomy_MeHg_correlation_combined.pdf",   
       plot = combined_plot,   
       width = 10,   
       height = 6 ,   
       units = "in")

```

## correlation between total methanogen and total methanotroph abundance
```r
library(lme4)
library(lmerTest)
library(broom.mixed)
library(dplyr)


data <- read.csv("data/gy21_geochemical/correlation_analyses_modified2.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

# First, let's examine the data and scale appropriately
cat("Data Summary:\n")
cat("=============\n")
summary(data[, c("overall_methanogen", "overall_aerobic_methanotroph", "site", "type")])

# Check for missing values
cat("\nMissing values:\n")
cat("Overall methanogen:", sum(is.na(data$overall_methanogen)), "\n")
cat("Overall methanotroph:", sum(is.na(data$overall_aerobic_methanotroph)), "\n")

# Scale the variables to address the scaling warning
data_scaled <- data %>%
  mutate(
    methanogen_scaled = scale(overall_methanogen)[,1],
    methanotroph_scaled = scale(overall_aerobic_methanotroph)[,1]
  ) %>%
  filter(!is.na(methanogen_scaled) & !is.na(methanotroph_scaled))

# Check sample sizes per group
cat("\nSample sizes per group:\n")
print(table(data_scaled$site, data_scaled$type))

# Fit models with different random effect structures
cat("\nFitting mixed-effects models...\n")

# Model 1: Site and Type as separate random intercepts
model1 <- lmer(methanotroph_scaled ~ methanogen_scaled + (1|site) + (1|type), 
               data = data_scaled)

# Model 2: Site and Type as crossed random effects (if you have both factors for each observation)
model2 <- lmer(methanotroph_scaled ~ methanogen_scaled + (1|site/type), 
               data = data_scaled)

# Model 3: Only site as random effect
model3 <- lmer(methanotroph_scaled ~ methanogen_scaled + (1|site), 
               data = data_scaled)

# Model 4: Fixed effects only (for comparison)
model4 <- lm(methanotroph_scaled ~ methanogen_scaled + site + type, 
             data = data_scaled)

# Check for singularity issues
cat("\nModel diagnostics:\n")
cat("Model 1 singular:", isSingular(model1), "\n")
cat("Model 2 singular:", isSingular(model2), "\n") 
cat("Model 3 singular:", isSingular(model3), "\n")

# Select the best non-singular model
if(!isSingular(model1)) {
  best_model <- model1
  model_name <- "Site and Type as separate random effects"
} else if(!isSingular(model2)) {
  best_model <- model2
  model_name <- "Site/Type nested random effects"
} else if(!isSingular(model3)) {
  best_model <- model3
  model_name <- "Site as random effect only"
} else {
  best_model <- model4
  model_name <- "Fixed effects only"
}

cat("\nBest model:", model_name, "\n")

# Get results from best model
if(class(best_model)[1] == "lmerMod") {
  mixed_results <- tidy(best_model, effects = "fixed")
  
  # Calculate R-squared
  library(MuMIn)
  r2_values <- r.squaredGLMM(best_model)
  
  # Random effects
  random_effects <- tidy(best_model, effects = "ran_pars")
  
} else {
  # For lm model
  mixed_results <- tidy(best_model)
  r2_values <- c(summary(best_model)$r.squared, summary(best_model)$adj.r.squared)
  names(r2_values) <- c("R2m", "R2c")
}

# Print comprehensive results
cat("\n" , rep("=", 50), "\n")
cat("FINAL RESULTS\n")
cat(rep("=", 50), "\n")

print(mixed_results)

# Extract methanogen effect
methanogen_effect <- mixed_results[mixed_results$term == "methanogen_scaled", ]

cat("\nMethanogen effect on methanotroph abundance:\n")
cat("Standardized Effect (β):", round(methanogen_effect$estimate, 4), "\n")
cat("Standard Error:", round(methanogen_effect$std.error, 4), "\n")
cat("P-value:", format(methanogen_effect$p.value, scientific = TRUE), "\n")
cat("95% CI: [", round(methanogen_effect$estimate - 1.96*methanogen_effect$std.error, 4), 
    ", ", round(methanogen_effect$estimate + 1.96*methanogen_effect$std.error, 4), "]\n")

if(exists("r2_values")) {
  cat("Marginal R² (fixed effects):", round(r2_values["R2m"], 4), "\n")
  cat("Conditional R² (fixed + random):", round(r2_values["R2c"], 4), "\n")
}

# Interpretation
effect_size <- abs(methanogen_effect$estimate)
correlation_strength <- ifelse(effect_size >= 0.7, "Strong",
                              ifelse(effect_size >= 0.5, "Moderate",
                              ifelse(effect_size >= 0.3, "Weak", "Very weak")))

significance <- ifelse(methanogen_effect$p.value < 0.001, "***",
                      ifelse(methanogen_effect$p.value < 0.01, "**",
                      ifelse(methanogen_effect$p.value < 0.05, "*", "ns")))

cat("Effect size interpretation:", correlation_strength, "\n")
cat("Significance:", significance, "\n")

# Plot the relationship
library(ggplot2)


# Create plots
p1 <- ggplot(data_scaled, aes(x = methanogen_scaled, y = methanotroph_scaled)) +
  geom_point(aes(color = site, shape = type), alpha = 0.7, size = 3) +
  geom_smooth(method = "lm", se = TRUE, color = "black", linetype = "dashed") +
  labs(
    title = "Scaled Methanogen vs Methanotroph Relationship",
    subtitle = paste("Standardized Regression Coefficient =", round(methanogen_effect$estimate, 3), 
                     ", p =", format(methanogen_effect$p.value, digits = 3)),
    x = "Total Methanogen (z-score)",
    y = "Total Aerobic Methanotroph (z-score)"
  ) +
  scale_color_manual(values = site_colors) +  
  theme_minimal() +
  theme(legend.position = "bottom")


# Faceted plot by site and type
p2 <- ggplot(data_scaled, aes(x = methanogen_scaled, y = methanotroph_scaled)) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(method = "lm", se = TRUE, color = "red", linetype = "dashed") +
  facet_grid(type ~ site) +
  labs(
    title = "Methanogen vs Methanotroph by Site and Type",
    x = "Overall Methanogen (z-score)",
    y = "Overall Aerobic Methanotroph (z-score)"
  ) +
  theme_minimal()

print(p1)
print(p2)

# Save plots
ggsave("output/methanogen_methanotroph_scaled.pdf", p1, width = 8, height = 6)
ggsave("output/methanogen_methanotroph_faceted.pdf", p2, width = 10, height = 6)

# Additional: Group-wise correlations for comparison
cat("\nGroup-wise correlations for comparison:\n")
group_correlations <- data_scaled %>%
  group_by(site, type) %>%
  summarise(
    n = n(),
    correlation = ifelse(n >= 3, 
                        cor(methanogen_scaled, methanotroph_scaled, method = "spearman"),
                        NA),
    p_value = ifelse(n >= 3, 
                    cor.test(methanogen_scaled, methanotroph_scaled, method = "spearman")$p.value,
                    NA),
    .groups = "drop"
  )

print(group_correlations)
```



## methanotroph mbnT (TIBRFAM) - selected genus taxonomic distribution
```r
library(tidyr)  
library(reshape2)  

# Read data  
methanotroph_mbnT_taxonomic <- read.csv("data/gy21_geochemical/methanotroph_mbnT_TIGRFAM_selected_genus.csv", header = TRUE)  

# Remove specified columns  
methanotroph_mbnT_taxonomic <- methanotroph_mbnT_taxonomic[, -c(1, 3, 5, 10)]  

methanotroph_mbnT_taxonomic$site <- factor(methanotroph_mbnT_taxonomic$site, levels = c("HX", "GX", "SK"))
methanotroph_mbnT_taxonomic$type <- factor(methanotroph_mbnT_taxonomic$type, levels = c("Surface", "Rhizosphere"))

# melt
methanotroph_mbnT_taxonomic.m <- methanotroph_mbnT_taxonomic %>%  
  pivot_longer(  
    cols = -c(day, site, type),  # All columns except these  
    names_to = "variable",   
    values_to = "value"  
  )  

# Factor ordering (more concise method)  
methanotroph_mbnT_taxonomic.m <- methanotroph_mbnT_taxonomic.m %>%  
  mutate(  
    day = factor(day, levels = unique(day)),  
    site = factor(site, levels = unique(site)),  
    variable = factor(variable, levels = unique(variable))  ,
    type = factor(type, levels = c("Surface", "Rhizosphere"))
  )  


methylotroph_colors <- c(  
  "Methylosinus"   = "#c7eae5",  
  "Methylomicrobium"    = "#80cdc1",  
  "Methylocystis"    = "#9eecb2")  


# Enhanced ggplot with more customization  
gy21_methanotroph_barplot <-   
  ggplot(methanotroph_mbnT_taxonomic.m, aes(x = day, fill = variable, y = value)) +   
  geom_bar(stat = "identity",   
           color = "transparent",  # Black border for all bars  
           width = 0.75,   
           size = 0.3) +  
  geom_smooth(  
    data = methanotroph_mbnT_taxonomic.m %>%   
      group_by(day, site, type) %>%   
      summarize(total = sum(value), .groups = "drop"),  
    aes(x = day, y = total, group = interaction(site, type)),  
    inherit.aes = FALSE,  
    method = "loess", # or "lm" for a straight line  
    se = FALSE,       # no confidence interval  
    color = "grey60",  # black trend line  
    linewidth = 0.6,  # slightly thicker line  
    linetype = "solid"  
  ) +
  scale_fill_manual(values = methylotroph_colors) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),   # Remove major grid lines  
    axis.text.x = element_text(  
      angle = 90,   
      size = 10,   
      colour = "black",   
      vjust = 0.5,   
      hjust = 0.5  
    ),   
    axis.title.x = element_text(size = 10),   
    axis.title.y = element_text(size = 10),   
    legend.title = element_text(size = 7, face="bold"),   
    legend.text = element_text(size = 10, colour = "black"),   
    axis.text.y = element_text(colour = "black", size = 10),  
    legend.key.size = unit(0.25, 'cm'),  
    strip.text.x = element_text(size = 10),  # Instead, add this to style type labels  
    strip.text.y = element_text(size = 10),  # Style site labels     
    legend.position = "bottom"  
  ) +  
  labs(  
    y = "% total reads normalised by HMM length",   
    x = "Days post rice plantation",   
    fill = "Family"  
  ) +   
  facet_grid(site ~ type, space = "free_x", scales = "free_x") +   
  guides(fill = guide_legend(ncol = 3))  


# Modify the strip labels to show 'Site' only once
gy21_methanotroph_barplot <- gy21_methanotroph_barplot + 
  theme(strip.background = element_rect(colour = "white", fill = "white"))

ggsave("output/methanotroph_mbnT_TIGRFAM_selected_genus_taxonomy_barplot.pdf", width = 6, height=5, units = "in")
```

## correlation between MeHg and mbnT (TIGRFAM) from selected genus, and plot
```r
# Load required libraries  
library(dplyr)  
library(tidyr)  
library(broom)  
library(ggplot2)  
library(patchwork)
library(forcats) # For factor reordering  


# Read the CSV  
data <- read.csv("data/gy21_geochemical/methanotroph_mbnT_TIGRFAM_selected_genus.csv", header = TRUE)

data$site <- factor(data$site, levels = c("HX", "GX", "SK"))
data$type <- factor(data$type, levels = c("Surface", "Rhizosphere"))

# applying library size correction (optional)
#data$overall_hgcA = data$overall_hgcA * data$library_correction_value
#data$overall_SRB_hgcA = data$overall_SRB_hgcA * data$library_correction_value
#data$overall_IRB_hgcA = data$overall_IRB_hgcA * data$library_correction_value
#data$overall_methanogen_hgcA = data$overall_methanogen_hgcA * data$library_correction_value


# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and overall_mbnT from selected genus  
    spearman_correlation = cor.test(  
      MeHg,   # Dependent variable (Mercury concentration)  
      overall,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg,   
      overall,   
      method = "spearman"  
    )$p.value  
  )  

# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and Methylosinus  
    spearman_correlation = cor.test(  
      MeHg,   # Dependent variable (Mercury concentration)  
      Methylosinus,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg,   
      Methylosinus,   
      method = "spearman"  
    )$p.value  
  )  

# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and Methylomicrobium  
    spearman_correlation = cor.test(  
      MeHg,   # Dependent variable (Mercury concentration)  
      Methylomicrobium,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg,   
      Methylomicrobium,   
      method = "spearman"  
    )$p.value  
  )  

# Perform correlation by Site and Soil Type  
comprehensive_correlations <- data %>%  
  group_by(site, type) %>%  # Group by site and type  
  summarise(  
    # Spearman correlation for MeHg and overall_hgcA  
    spearman_correlation = cor.test(  
      MeHg,   # Dependent variable (Mercury concentration)  
      Methylocystis,   # Independent variable (Gene abundance)  
      method = "spearman"  # Non-parametric correlation method  
    )$estimate,  # Extract correlation coefficient  
    
    # P-value for the same correlation  
    spearman_p_values = cor.test(  
      MeHg,   
      Methylocystis,   
      method = "spearman"  
    )$p.value  
  )  

# Calculate correlations between MeHg and each gene type  
correlation_data <- data %>%  
  group_by(site, type) %>%  
  summarise(  
    # Overall hgcA  
    overall_cor = cor.test(MeHg, overall, method = "spearman")$estimate,  
    overall_pval = cor.test(MeHg, overall, method = "spearman")$p.value,  
    
    # SRB hgcA  
    Methylosinus_cor = cor.test(MeHg, Methylosinus, method = "spearman")$estimate,  
    Methylosinus_pval = cor.test(MeHg, Methylosinus, method = "spearman")$p.value,  
    
    # IRB hgcA  
    Methylomicrobium_cor = cor.test(MeHg, Methylomicrobium, method = "spearman")$estimate,  
    Methylomicrobium_pval = cor.test(MeHg, Methylomicrobium, method = "spearman")$p.value,  
    
    # Methanogen hgcA  
    Methylocystis_cor = cor.test(MeHg, Methylocystis, method = "spearman")$estimate,  
    Methylocystis_pval = cor.test(MeHg, Methylocystis, method = "spearman")$p.value  
  )  

correlation_data

# Reshape the data for plotting  
correlation_long <- correlation_data %>%  
  pivot_longer(  
    cols = contains("_cor"),  
    names_to = "gene_type",  
    values_to = "correlation"  
  ) %>%  
  mutate(  
    gene_type = case_when(  
      gene_type == "overall_cor" ~ "overall",  
      gene_type == "Methylosinus_cor" ~ "Methylosinus",  
      gene_type == "Methylomicrobium_cor" ~ "Methylomicrobium",  
      gene_type == "Methylocystis_cor" ~ "Methylocystis"  
    )  
  )  

# Get corresponding p-values  
p_values_long <- correlation_data %>%  
  pivot_longer(  
    cols = contains("_pval"),  
    names_to = "gene_type",  
    values_to = "p_value"  
  ) %>%  
  mutate(  
    gene_type = case_when(  
      gene_type == "overall_cor" ~ "overall",  
      gene_type == "Methylosinus_cor" ~ "Methylosinus",  
      gene_type == "Methylomicrobium_cor" ~ "Methylomicrobium",  
      gene_type == "Methylocystis_cor" ~ "Methylocystis"  
    )  
  )  

# Combine correlation and p-values  
plot_data <- left_join(correlation_long, p_values_long, by = c("site", "type", "gene_type"))  

# Add significance indicators  
plot_data <- plot_data %>%  
  mutate(significance = case_when(  
    p_value < 0.001 ~ "***",  
    p_value < 0.01 ~ "**",  
    p_value < 0.05 ~ "*",  
    TRUE ~ "ns"  
  ))  

# Set the specific order for gene_type  
plot_data$gene_type <- factor(plot_data$gene_type,   
                             levels = c("overall", "Methylosinus", "Methylomicrobium", "Methylocystis"))  

# Create bar plot of correlations - vertical layout (top to bottom)  
site_colors <- c("HX" = "#f35d36", "GX" = "#ffba1b", "SK" = "#60cfa1")  

mbnT_MeHg_correlation_bar_plot <- ggplot(plot_data, aes(x = site, y = correlation, fill = site)) +  
  geom_bar(stat = "identity", position = position_dodge()) +  
  geom_text(aes(label = significance, y = correlation + 0.05 * sign(correlation)),  
            position = position_dodge(width = 0.9)) +  
  facet_grid(gene_type ~ type) +  # gene_type on rows, type on columns  
  scale_fill_manual(values = site_colors) +  
  labs(  
    title = "Spearman Correlations between MeHg and mbnT",  
    x = "Site",   
    y = "Correlation Coefficient",   
    fill = "Site"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),   # Remove major grid lines  
    axis.text.x = element_text(  
      angle = 90,   
      size = 10,   
      colour = "black",   
      vjust = 0.5,   
      hjust = 0.5  
    ),   
    axis.title.x = element_text(size = 10),   
    axis.title.y = element_text(size = 10),   
    legend.title = element_text(size = 7, face="bold"),   
    legend.text = element_text(size = 7, colour = "black"),   
    axis.text.y = element_text(colour = "black", size = 10),  
    legend.key.size = unit(0.25, 'cm'),  
    strip.text.y = element_text(angle = 270, size = 7, hjust = 0.5, vjust = 0.5),  # Rotated y-axis strip text  
    strip.text.x = element_text(size = 10),  
    legend.position = "bottom"  
  )

mbnT_MeHg_correlation_bar_plot
ggsave("output/mbnT_MeHg_correlation_bar_plot.pdf", plot=mbnT_MeHg_correlation_bar_plot, width=6, height=6)

```
## composite figure of mbnT taxonomy + mbnT/MeHg correlation 
```r


library(patchwork)  

# Customize themes for better appearance  
base_theme <- theme(  
  text = element_text(family = "Helvetica", size = 12), 
  plot.title = element_blank(),  # Remove plot title  
  panel.grid.minor = element_blank(),  
  panel.grid.major = element_line(size = 0.1, linetype = 'dotted'),  
  panel.border = element_rect(color = "gray", fill = NA, size = 0.5),  
  axis.ticks = element_line(color = "black"),  
  axis.text = element_text(size = 10, color = "black"),  
  legend.title = element_text(face = "bold"),  
  legend.text = element_text(size = 8),  
  strip.background = element_rect(fill = "lightgray", color = "gray")  
)  

# Apply the base theme to the existing ggplot themes  
mbnT_MeHg_correlation_bar_plot <- mbnT_MeHg_correlation_bar_plot + base_theme  
gy21_methanotroph_barplot <- gy21_methanotroph_barplot + base_theme  

# Combine plots with patchwork  
combined_plot <- (gy21_methanotroph_barplot | mbnT_MeHg_correlation_bar_plot) +   
  plot_layout(widths = c(0.7, 0.4)) +  # Make first plot narrower  
  plot_annotation(tag_levels = "A")     # Add A, B labels to plots  

combined_plot

ggsave("output/mbnT_selected_genus_taxonomy_MeHg_correlation_combined.pdf",   
       plot = combined_plot,   
       width = 8,   
       height = 6,   
       units = "in")


```




# part 4 
# Random Forest Regression (MeHg as a categorical variable)
```r
# Load required libraries 

install.packages("MLmetrics")

library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

# 2. Convert MeHg to categorical variables with brackets with equal distribution
df$MeHg_factor <- cut(df$MeHg, breaks = 10, labels = paste0("Classs_", 1:10))  

# 2.1 (optional). Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  
df$MeHg_factor <- as.factor(df$MeHg_factor)  

# 3. Split Data into Training and Testing Sets  
train_indices <- createDataPartition(df$MeHg_factor, p = 0.7, list = FALSE)  
train_data <- df[train_indices, ]  
test_data <- df[-train_indices, ]

# 4. fine-tuning hyperparameters
# 4.1 Create a tuning grid  
tuneGrid <- expand.grid(  
  mtry = c(3, 5, 7, 9)  # Number of variables to consider at each split  
)  

# 4.2 Set up train control for cross-validation  
train_control <- trainControl(  
  method = "repeatedcv",  # Repeated cross-validation  
  number = 10,            # 10-fold cross-validation  
  repeats = 3,            # Repeat 3 times  
  search = "grid",        # Use grid search  
  verboseIter = TRUE,     # Print progress  
  classProbs = TRUE,      # Compute class probabilities  
  summaryFunction = multiClassSummary  # For multi-class classification  
)  


# 4.3 tune RF model
rf_tuned <- train(  
  MeHg_factor ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + site + type,  
  data = train_data,  
  method = "rf",  
  metric = "Accuracy",  # Optimization metric  
  tuneGrid = tuneGrid,  
  trControl = train_control,  
  ntree = 2001  
)  

# Best model selection  
print(rf_tuned)

# Get the best parameters  
best_mtry <- rf_tuned$bestTune$mtry  


# 5. Run the RF model
rf_model <- randomForest(  
  MeHg_factor ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + site + type,  
  data = train_data,  
  ntree = 2001,  # Number of trees  
  mtry = 3,     # Number of variables tried at each split  
  importance = TRUE  
)  

# 6. Model Performance Evaluation  
# 6.1 Predictions on Test Set  
predictions <- predict(rf_model, test_data)  

# 6.2 erformance Metrics  
# Confusion Matrix  
conf_matrix <- confusionMatrix(predictions, test_data$MeHg_factor)  

# Performance Metrics for Classification  
performance_metrics <- data.frame(  
  Accuracy = conf_matrix$overall['Accuracy'],  
  Kappa = conf_matrix$overall['Kappa'],  
  Precision = mean(conf_matrix$byClass[, 'Precision'], na.rm = TRUE),  
  Recall = mean(conf_matrix$byClass[, 'Recall'], na.rm = TRUE),  
  F1_Score = mean(conf_matrix$byClass[, 'F1'], na.rm = TRUE)  
)  

performance_metrics

# 7. Cross-Validation  
results <- data.frame(test_data$MeHg_factor, predict(rf_model, test_data[,c(2, 7:14)], type = "response"))

results

# 8. Visualization of Predicted vs Actual  
plot_data <- data.frame(  
  Actual = results$test_data.MeHg,  
  Predicted = results$predict.rf_model..test_data...c.2..7.14....type....response..  
)  

ggplot(plot_data, aes(x = Actual, y = Predicted)) +  
  geom_point() +  
  geom_abline(intercept = 0, slope = 1, color = "red") +  
  labs(title = "Predicted vs Actual MeHg Concentration",  
       x = "Actual Concentration",  
       y = "Predicted Concentration")  












# 4. Random Forest Regression
## run with the previously split training data 
rf_model <- randomForest(  
  MeHg_factor ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB +
         overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + site + type,  
  data = train_data,  
  ntree = 2001,  # Number of trees  
  mtry = 5,     # Number of variables tried at each split  
  importance = TRUE  
)  

rf_model


## run with all data
rf_model <- randomForest(  
  MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB +
         overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + site + type,  
  data = df,  
  ntree = 2001,  # Number of trees  
  mtry = 5,     # Number of variables tried at each split  
  importance = TRUE  
)  


# 5. Model Performance Evaluation  
# Predictions on Test Set  
predictions <- predict(rf_model, test_data)  

# Performance Metrics  
performance_metrics <- data.frame(  
  RMSE = sqrt(mean((test_data$MeHg_factor - predictions)^2)),  
  MAE = mean(abs(test_data$MeHg_factor - predictions)),  
  R_squared = cor(test_data$MeHg_factor, predictions)^2  
)  

performance_metrics


# 6. Variable Importance  
var_importance <- importance(rf_model)  
var_importance_sorted_accuracy <- var_importance[order(var_importance[,"%IncMSE"], decreasing = TRUE), ]  

## check variable importance
var_importance_sorted_accuracy



# 7. Cross-Validation  
results <- data.frame(test_data$MeHg_factor, predict(rf_model, test_data[,c(2, 7:14)], type = "response"))
results



control <- trainControl(method = "repeatedcv",   
                        number = 10,   
                        repeats = 3)  

rf_cv <- train(  
  MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB +
         overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + site + type,   
  data = df,  
  method = "rf",  
  trControl = control,  
  importance = TRUE  
)  

# 8. Visualization of Predicted vs Actual  
plot_data <- data.frame(  
  Actual = results$test_data.MeHg,  
  Predicted = results$predict.rf_model..test_data...c.2..7.14....type....response..  
)  

ggplot(plot_data, aes(x = Actual, y = Predicted)) +  
  geom_point() +  
  geom_abline(intercept = 0, slope = 1, color = "red") +  
  labs(title = "Predicted vs Actual MeHg Concentration",  
       x = "Actual Concentration",  
       y = "Predicted Concentration")  


# Recommended Next Steps

# 1. Recommended Next Steps
# 2. Validate model assumptions
# 3. Check for overfitting
# 4. Consider ensemble methods
# 5.  Perform sensitivity analysis

# Advanced modifications
# Try different mtry values
# Use bootstrap or cross-validation
# Experiment with hyperparameter tuning


```

# Random Forest Regression (MeHg as a continuous variable)
## MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + TH
```r
library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(rfPermute)  
library(reshape2)  

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# 3. Split Data into Training and Testing Sets  
train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
train_data <- df[train_indices, ]  
test_data <- df[-train_indices, ]

# 4. fine-tuning hyperparameters
# 4.1 Create a tuning grid  
tuneGrid <- expand.grid(  
  mtry = c(3, 4, 5, 6, 7, 8)  # Number of variables to consider at each split  
)  

# 4.2 Set up train control for cross-validation  
# For regression, change the metric and summary function  
train_control <- trainControl(  
  method = "repeatedcv",  # Repeated cross-validation  
  number = 10,            # 10-fold cross-validation  
  repeats = 3,            # Repeat 3 times  
  search = "grid",        # Use grid search  
  verboseIter = TRUE     # Print progress  
) 

# 4.3 tune RF model
rf_tuned <- train(  
  MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + THg,  
  data = train_data,  
  method = "rf",  
  metric = "RMSE",  # Optimization metric  
  tuneGrid = tuneGrid,  
  trControl = train_control,  
  ntree = 2001  
)  

# 4.4 Get the best parameters  
best_mtry <- rf_tuned$bestTune$mtry  
best_mtry

# 5. Run the RF model
rf_model <- randomForest(  
  MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT,  
  data = train_data,  
  ntree = 2001,  # Number of trees  
  mtry = 4,     # Number of variables tried at each split  
  importance = TRUE  
)  

# 6. Check Variable Importance  
var_importance <- importance(rf_model)  
var_importance_sorted_accuracy <- var_importance[order(var_importance[,"%IncMSE"], decreasing = TRUE), ]
var_importance_sorted_accuracy

# 7.Performance Metrics  
predictions <- predict(rf_model, newdata = test_data)  
performance_metrics <- data.frame(  
  RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
  MAE = mean(abs(test_data$MeHg - predictions)),  
  R_squared = cor(test_data$MeHg, predictions)^2  
)  
performance_metrics

# 8.Perform RF with Permutation (to get significance score with MSE%)
# 8.1 Perform RF with Permutation  
set.seed(123)  
rp_model <- rfPermute(  
  MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen +   
         overall_methanogen_hgcA + overall_merB +   
         overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + THg,  
  data = train_data,  
  ntree = 2001,  
  mtry = 4,  
  importance = TRUE,  
  num.rep = 1000  # Number of permutations  
)  

# 8.2 Detailed importance summary  
imp_summary <- importance(rp_model, scale = TRUE)  
print(imp_summary)  

# 8.3 Create a  importance plot  
importance_df <- data.frame(  
  Variable = rownames(imp_summary),  
  Importance = imp_summary[, "%IncMSE"],  
  P_Value = imp_summary[, "%IncMSE.pval"]  
)  

importance_df <- importance_df[order(importance_df$Importance, decreasing = TRUE), ]  

# visualization  
ggplot(importance_df, aes(y = reorder(Variable, -Importance), x = Importance)) +  
  geom_bar(stat = "identity", fill = "red4", width = 0.6) +  
  coord_flip(xlim = c(-5, 60)) +  
  geom_text(  
    data = subset(importance_df, P_Value < 0.05),  
    aes(label = "*"),   
    hjust = 0.3,  # Position of the asterisk  
    vjust = -0.2,
    color = "black",  
    size = 5  
  ) +  
  labs(  
    x = "Variable Importance \n (Increase in MSE%)",  
    y = "Variables"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),  # Remove major grid lines  
    panel.grid.minor = element_blank(),  # Remove minor grid lines  
    axis.line.x = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.line.y = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.text.x = element_text(angle = 30, hjust = 1),  # 45-degree rotation for x-axis labels 
    axis.ticks.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black")
  )

# 7.Performance Metrics  
predictions <- predict(rp_model, newdata = test_data) 

performance_metrics <- data.frame(  
  RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
  MAE = mean(abs(test_data$MeHg - predictions)),  
  R_squared = cor(test_data$MeHg, predictions)^2  
)  
performance_metrics

# 7. Cross-Validation (prediction with the test dataset) 
results <- data.frame(test_data$MeHg, predict(rp_model, test_data[,c(8:14, 16)], type = "response"))
results

# 8. Visualization of Predicted vs Actual  
plot_data <- data.frame(  
  Actual = results$test_data.MeHg,
  Predicted = results$predict.rp_model..test_data...c.8.14..16....type....response..
)  

# 8.2 Calculate correlation and R-squared  
cor_value <- cor(plot_data$Actual, plot_data$Predicted)  
r_squared <- summary(lm(Predicted ~ Actual, data = plot_data))$r.squared  


ggplot(plot_data, aes(x = Actual, y = Predicted)) +  
  geom_point() +  
  geom_abline(intercept = 0, slope = 1, color = "grey") +  
   labs(  
    title = "Predicted vs Actual MeHg Concentration",  
    x = "Actual Concentration",  
    y = "Predicted Concentration",  
    caption = paste0("Correlation coefficient: ", round(cor_value, 3),   
                     "\nR-squared: ", round(r_squared, 3))) +  
  theme_minimal()+
    theme(  
    panel.grid.major = element_blank(),  # Remove major grid lines  
    panel.grid.minor = element_blank(),  # Remove minor grid lines  
    axis.line.x = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.line.y = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.ticks.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"))

```


# Random Forest Regression (MeHg as a continuous variable)
## MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT
## including library size correction
```r
library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(rfPermute)  
library(reshape2)  

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# 2.2 implement library size correction values 
df$overall_hgcA_corrected <- df$overall_hgcA * df$library_correction_value  
df$overall_SRB_hgcA_corrected <- df$overall_SRB_hgcA * df$library_correction_value  
df$overall_methanogen_corrected <- df$overall_methanogen * df$library_correction_value  
df$overall_methanogen_hgcA_corrected <- df$overall_methanogen_hgcA * df$library_correction_value  
df$overall_merB_corrected <- df$overall_merB * df$library_correction_value  
df$overall_aerobic_methanotroph_corrected <- df$overall_aerobic_methanotroph * df$library_correction_value  
df$overall_aerobic_methanotroph_mbnT_corrected <- df$overall_aerobic_methanotroph_mbnT * df$library_correction_value 


# 3. Split Data into Training and Testing Sets  
train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
train_data <- df[train_indices, ]  
test_data <- df[-train_indices, ]

# 4. fine-tuning hyperparameters
# 4.1 Create a tuning grid  
tuneGrid <- expand.grid(  
  mtry = c(3, 4, 5, 6, 7, 8)  # Number of variables to consider at each split  
)  


# 5 Run the RF model with library size correction
rf_model <- randomForest(  
  MeHg ~ overall_hgcA_corrected +   
         overall_SRB_hgcA_corrected +   
         overall_methanogen_corrected +   
         overall_methanogen_hgcA_corrected +  
         overall_merB_corrected +   
         overall_aerobic_methanotroph_corrected +   
         overall_aerobic_methanotroph_mbnT_corrected,  
  data = train_data,  
  ntree = 2001,  
  mtry = 4,  
  importance = TRUE  
)

# 6. Check Variable Importance  
var_importance <- importance(rf_model)  
var_importance_sorted_accuracy <- var_importance[order(var_importance[,"%IncMSE"], decreasing = TRUE), ]
var_importance_sorted_accuracy

# 7.Performance Metrics  
predictions <- predict(rf_model, newdata = test_data)  
performance_metrics <- data.frame(  
  RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
  MAE = mean(abs(test_data$MeHg - predictions)),  
  R_squared = cor(test_data$MeHg, predictions)^2  
)  
performance_metrics

# 8.Perform RF with Permutation (to get significance score with MSE%)
# 8.1 Perform value corrected RF model with Permutation  
set.seed(123)  
rp_model <- rfPermute(  
  MeHg ~ overall_hgcA_corrected +   
         overall_SRB_hgcA_corrected +   
         overall_methanogen_corrected +   
         overall_methanogen_hgcA_corrected +  
         overall_merB_corrected +   
         overall_aerobic_methanotroph_corrected +   
         overall_aerobic_methanotroph_mbnT_corrected, 
  data = train_data,  
  ntree = 2001,  
  mtry = 4,  
  importance = TRUE,  
  num.rep = 1000  # Number of permutations  
)  

# 8.2 Detailed importance summary  
imp_summary <- importance(rp_model, scale = TRUE)  
print(imp_summary)  

# 8.3 Create a  importance plot  
importance_df <- data.frame(  
  Variable = rownames(imp_summary),  
  Importance = imp_summary[, "%IncMSE"],  
  P_Value = imp_summary[, "%IncMSE.pval"]  
)  

importance_df <- importance_df[order(importance_df$Importance, decreasing = TRUE), ]  

# visualization  
ggplot(importance_df, aes(y = reorder(Variable, -Importance), x = Importance)) +  
  geom_bar(stat = "identity", fill = "red4", width = 0.6) +  
  coord_flip(xlim = c(-5, 60)) +  
  geom_text(  
    data = subset(importance_df, P_Value < 0.05),  
    aes(label = "*"),   
    hjust = 0.3,  # Position of the asterisk  
    vjust = -0.2,
    color = "black",  
    size = 5  
  ) +  
  labs(  
    x = "Variable Importance \n (Increase in MSE%)",  
    y = "Variables"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),  # Remove major grid lines  
    panel.grid.minor = element_blank(),  # Remove minor grid lines  
    axis.line.x = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.line.y = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.text.x = element_text(angle = 30, hjust = 1),  # 45-degree rotation for x-axis labels 
    axis.ticks.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black")
  )

# 7.Performance Metrics  
predictions <- predict(rp_model, newdata = test_data) 

performance_metrics <- data.frame(  
  RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
  MAE = mean(abs(test_data$MeHg - predictions)),  
  R_squared = cor(test_data$MeHg, predictions)^2  
)  
performance_metrics

# 7. Cross-Validation (prediction with the test dataset) 
# 7.1 Cross-Validation with the corrected values (prediction with the test dataset) 
results <- data.frame(test_data$MeHg, predict(rp_model, test_data[,c(19:25)], type = "response"))
results

# 8.1. Visualization of Predicted vs Actual  (with corrected values)
plot_data <- data.frame(  
  Actual = results$test_data.MeHg,
  Predicted = results$predict.rp_model..test_data...c.19.25....type....response..
)  

# 8.2 Calculate correlation and R-squared  
cor_value <- cor(plot_data$Actual, plot_data$Predicted)  
r_squared <- summary(lm(Predicted ~ Actual, data = plot_data))$r.squared  


ggplot(plot_data, aes(x = Actual, y = Predicted)) +  
  geom_point() +  
  geom_abline(intercept = 0, slope = 1, color = "grey") +  
   labs(  
    title = "Predicted vs Actual MeHg Concentration",  
    x = "Actual Concentration",  
    y = "Predicted Concentration",  
    caption = paste0("Correlation coefficient: ", round(cor_value, 3),   
                     "\nR-squared: ", round(r_squared, 3))) +  
  theme_minimal()+
    theme(  
    panel.grid.major = element_blank(),  # Remove major grid lines  
    panel.grid.minor = element_blank(),  # Remove minor grid lines  
    axis.line.x = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.line.y = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.ticks.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"))



```


# Random Forest Regression (MeHg as a continuous variable)
## MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + F1-Hg
```r
library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(rfPermute)  
library(reshape2)  

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

# remove rows with NA
df <- na.omit(df)  

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# 3. Split Data into Training and Testing Sets  
# Set a seed for reproducibility  
set.seed(123)
train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
train_data <- df[train_indices, ]  
test_data <- df[-train_indices, ]

# 4. fine-tuning hyperparameters
# 4.1 Create a tuning grid  
tuneGrid <- expand.grid(  
  mtry = c(3, 4, 5, 6, 7, 8)  # Number of variables to consider at each split  
)  

# 4.2 Set up train control for cross-validation  
# For regression, change the metric and summary function  
train_control <- trainControl(  
  method = "repeatedcv",  # Repeated cross-validation  
  number = 10,            # 10-fold cross-validation  
  repeats = 3,            # Repeat 3 times  
  search = "grid",        # Use grid search  
  verboseIter = TRUE     # Print progress  
) 

# 4.3 tune RF model
rf_tuned <- train(  
  MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + F1Hg,  
  data = train_data,  
  method = "rf",  
  metric = "RMSE",  # Optimization metric  
  tuneGrid = tuneGrid,  
  trControl = train_control,  
  ntree = 2001  
)  

# 4.4 Get the best parameters  
best_mtry <- rf_tuned$bestTune$mtry  
best_mtry


# 5. Run the RF model
rf_model <- randomForest(  
  MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + F1Hg,  
  data = train_data,  
  ntree = 2001,  # Number of trees  
  mtry = 4,     # Number of variables tried at each split  
  importance = TRUE  
)  

# 6. Check Variable Importance  
var_importance <- importance(rf_model)  
var_importance_sorted_accuracy <- var_importance[order(var_importance[,"%IncMSE"], decreasing = TRUE), ]
var_importance_sorted_accuracy

# 7.Performance Metrics  
predictions <- predict(rf_model, newdata = test_data)  
performance_metrics <- data.frame(  
  RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
  MAE = mean(abs(test_data$MeHg - predictions)),  
  R_squared = cor(test_data$MeHg, predictions)^2  
)  
performance_metrics


# 8.Perform RF with Permutation (to get significance score with MSE%)
# 8.1 Perform RF with Permutation  
set.seed(123)  
rp_model <- rfPermute(  
  MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen +   
         overall_methanogen_hgcA + overall_merB +   
         overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + F1Hg,  
  data = train_data,  
  ntree = 2001,  
  mtry = 4,  
  importance = TRUE,  
  num.rep = 1000  # Number of permutations  
)  

# 8.2 Detailed importance summary  
imp_summary <- importance(rp_model, scale = TRUE)  
print(imp_summary)  

# 8.3 Create a  importance plot  
importance_df <- data.frame(  
  Variable = rownames(imp_summary),  
  Importance = imp_summary[, "%IncMSE"],  
  P_Value = imp_summary[, "%IncMSE.pval"]  
)  

importance_df <- importance_df[order(importance_df$Importance, decreasing = TRUE), ]  
importance_df


# visualization  
ggplot(importance_df, aes(y = reorder(Variable, -Importance), x = Importance)) +  
  geom_bar(stat = "identity", fill = "red4", width = 0.6) +  
  coord_flip(xlim = c(-5, 50)) +  
  geom_text(  
    data = subset(importance_df, P_Value < 0.05),  
    aes(label = "*"),   
    hjust = 0.3,  # Position of the asterisk  
    vjust = -0.2,
    color = "black",  
    size = 5  
  ) +  
  labs(  
    x = "Variable Importance \n (Increase in MSE%)",  
    y = "Variables"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),  # Remove major grid lines  
    panel.grid.minor = element_blank(),  # Remove minor grid lines  
    axis.line.x = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.line.y = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.text.x = element_text(angle = 30, hjust = 1),  # 45-degree rotation for x-axis labels 
    axis.ticks.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black")
  )

# 9.Performance Metrics  
predictions <- predict(rp_model, newdata = test_data) 

performance_metrics <- data.frame(  
  RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
  MAE = mean(abs(test_data$MeHg - predictions)),  
  R_squared = cor(test_data$MeHg, predictions)^2  
)  
performance_metrics

# 7. Cross-Validation (prediction with the test dataset) 
results <- data.frame(test_data$MeHg, predict(rp_model, test_data[,c(8:14, 17)], type = "response"))
results

# 8. Visualization of Predicted vs Actual  
plot_data <- data.frame(  
  Actual = results$test_data.MeHg,
  Predicted = results$predict.rp_model..test_data...c.8.14..17....type....response..
)  

# Calculate correlation and R-squared  
cor_value <- cor(plot_data$Actual, plot_data$Predicted)  
r_squared <- summary(lm(Predicted ~ Actual, data = plot_data))$r.squared  


ggplot(plot_data, aes(x = Actual, y = Predicted)) +  
  geom_point() +  
  geom_abline(intercept = 0, slope = 1, color = "grey") +  
   labs(  
    title = "Predicted vs Actual MeHg Concentration",  
    x = "Actual Concentration",  
    y = "Predicted Concentration",  
    caption = paste0("Correlation coefficient: ", round(cor_value, 3),   
                     "\nR-squared: ", round(r_squared, 3))) +  
  theme_minimal()+
    theme(  
    panel.grid.major = element_blank(),  # Remove major grid lines  
    panel.grid.minor = element_blank(),  # Remove minor grid lines  
    axis.line.x = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.line.y = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.ticks.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"))

ggsave("output/RF_model_cross-validation.pdf", width = 10, height = 10, units = "cm")


```


# Random Forest Regression (MeHg as a continuous variable)
## MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + F1-Hg
## including library size correction
```r
library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(rfPermute)  
library(reshape2)  

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

# 1.1 remove rows with NA
df <- na.omit(df)  

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# 2.2 implement library size correction values 
df$overall_hgcA_corrected <- df$overall_hgcA * df$library_correction_value  
df$overall_SRB_hgcA_corrected <- df$overall_SRB_hgcA * df$library_correction_value  
df$overall_methanogen_corrected <- df$overall_methanogen * df$library_correction_value  
df$overall_methanogen_hgcA_corrected <- df$overall_methanogen_hgcA * df$library_correction_value  
df$overall_merB_corrected <- df$overall_merB * df$library_correction_value  
df$overall_aerobic_methanotroph_corrected <- df$overall_aerobic_methanotroph * df$library_correction_value  
df$overall_aerobic_methanotroph_mbnT_corrected <- df$overall_aerobic_methanotroph_mbnT * df$library_correction_value 

# 3. Split Data into Training and Testing Sets  
train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
train_data <- df[train_indices, ]  
test_data <- df[-train_indices, ]

# 4. fine-tuning hyperparameters
# skipped

# 5 Run the RF model with library size correction
rf_model <- randomForest(  
  MeHg ~ overall_hgcA_corrected +   
         overall_SRB_hgcA_corrected +   
         overall_methanogen_corrected +   
         overall_methanogen_hgcA_corrected +  
         overall_merB_corrected +   
         overall_aerobic_methanotroph_corrected +   
         overall_aerobic_methanotroph_mbnT_corrected +
         F1Hg,  
  data = train_data,  
  ntree = 2001,  
  mtry = 3,  
  importance = TRUE  
)

# 6. Check Variable Importance  
var_importance <- importance(rf_model)  
var_importance_sorted_accuracy <- var_importance[order(var_importance[,"%IncMSE"], decreasing = TRUE), ]
var_importance_sorted_accuracy

# 7.Performance Metrics  
predictions <- predict(rf_model, newdata = test_data)  
performance_metrics <- data.frame(  
  RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
  MAE = mean(abs(test_data$MeHg - predictions)),  
  R_squared = cor(test_data$MeHg, predictions)^2  
)  
performance_metrics

# 8.Perform RF with Permutation (to get significance score with MSE%)
# 8.1 Perform value corrected RF model with Permutation  
set.seed(123)  
rp_model <- rfPermute(  
  MeHg ~ overall_hgcA_corrected +   
         overall_SRB_hgcA_corrected +   
         overall_methanogen_corrected +   
         overall_methanogen_hgcA_corrected +  
         overall_merB_corrected +   
         overall_aerobic_methanotroph_corrected +   
         overall_aerobic_methanotroph_mbnT_corrected +
         F1Hg, 
  data = train_data,  
  ntree = 2001,  
  mtry = 3,  
  importance = TRUE,  
  num.rep = 1000  # Number of permutations  
)  

# 8.2 Detailed importance summary  
imp_summary <- importance(rp_model, scale = TRUE)  
print(imp_summary)  

# 8.3 Create a  importance plot  
importance_df <- data.frame(  
  Variable = rownames(imp_summary),  
  Importance = imp_summary[, "%IncMSE"],  
  P_Value = imp_summary[, "%IncMSE.pval"]  
)  

importance_df <- importance_df[order(importance_df$Importance, decreasing = TRUE), ]  

# visualization  
ggplot(importance_df, aes(y = reorder(Variable, -Importance), x = Importance)) +  
  geom_bar(stat = "identity", fill = "red4", width = 0.6) +  
  coord_flip(xlim = c(-5, 60)) +  
  geom_text(  
    data = subset(importance_df, P_Value < 0.05),  
    aes(label = "*"),   
    hjust = 0.3,  # Position of the asterisk  
    vjust = -0.2,
    color = "black",  
    size = 5  
  ) +  
  labs(  
    x = "Variable Importance \n (Increase in MSE%)",  
    y = "Variables"  
  ) +  
  theme_minimal() +  
  theme(  
    panel.grid.major = element_blank(),  # Remove major grid lines  
    panel.grid.minor = element_blank(),  # Remove minor grid lines  
    axis.line.x = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.line.y = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.text.x = element_text(angle = 30, hjust = 1),  # 45-degree rotation for x-axis labels 
    axis.ticks.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black")
  )

# 7.Performance Metrics  
predictions <- predict(rp_model, newdata = test_data) 

performance_metrics <- data.frame(  
  RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
  MAE = mean(abs(test_data$MeHg - predictions)),  
  R_squared = cor(test_data$MeHg, predictions)^2  
)  
performance_metrics

# 7. Cross-Validation (prediction with the test dataset) 
# 7.1 Cross-Validation with the corrected values (prediction with the test dataset) 
results <- data.frame(test_data$MeHg, predict(rp_model, test_data[,c(19:25, 17)], type = "response"))
results

# 8.1. Visualization of Predicted vs Actual  (with corrected values)
plot_data <- data.frame(  
  Actual = results$test_data.MeHg,
  Predicted = results$predict.rp_model..test_data...c.19.25..17....type....response..
)  

# 8.2 Calculate correlation and R-squared  
cor_value <- cor(plot_data$Actual, plot_data$Predicted)  
r_squared <- summary(lm(Predicted ~ Actual, data = plot_data))$r.squared  


ggplot(plot_data, aes(x = Actual, y = Predicted)) +  
  geom_point() +  
  geom_abline(intercept = 0, slope = 1, color = "grey") +  
   labs(  
    title = "Predicted vs Actual MeHg Concentration",  
    x = "Actual Concentration",  
    y = "Predicted Concentration",  
    caption = paste0("Correlation coefficient: ", round(cor_value, 3),   
                     "\nR-squared: ", round(r_squared, 3))) +  
  theme_minimal()+
    theme(  
    panel.grid.major = element_blank(),  # Remove major grid lines  
    panel.grid.minor = element_blank(),  # Remove minor grid lines  
    axis.line.x = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.line.y = element_line(color = "black", linewidth = 0.3),  # Add x-axis line  
    axis.ticks.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"))



```

# Random Forest Regression (MeHg as a continuous variable)
## MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + F1-Hg
## including a permutation step for data splitting, because I realized the importance would change when you do different splits of data
```r
library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(rfPermute)  
library(reshape2)  

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

# remove rows with NA
df <- na.omit(df)  

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# Number of data split permutations  
n_splits <- 100

# Create storage for importance metrics across different splits  
importance_results <- list()  
pvalue_results <- list()  
performance_metrics <- list()  
correlation_results <- list()  

# 3. Split Data into Training and Testing Sets  
# Set a seed for reproducibility
# Run models with different random splits  
for (i in 1:n_splits) {  
  # Set a different seed for each data split  
  set.seed(i)  
  
  # Split data  
  train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
  train_data <- df[train_indices, ]  
  test_data <- df[-train_indices, ]  
  
  # Set a seed for rfPermute  
  set.seed(123)  
  
  # Train the rfPermute model  
  rp_model <- rfPermute(  
    MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen +   
           overall_methanogen_hgcA + overall_merB +   
           overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + F1Hg,  
    data = train_data,  
    ntree = 2001,  
    mtry = 4,  
    importance = TRUE,  
    num.rep = 100  # Reduced to 100 for computational efficiency  
  )  
  
  # Store the importance values  
  importance_results[[i]] <- importance(rp_model)  
  
  # Store the p-values  
  pvalue_results[[i]] <- rp_model$pval  
  
  # Get predictions on test data  
  predictions <- predict(rp_model, newdata = test_data)  
  
  # Calculate and store performance metrics  
  performance_metrics[[i]] <- data.frame(  
    Split = i,  
    RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
    MAE = mean(abs(test_data$MeHg - predictions)),  
    R_squared = cor(test_data$MeHg, predictions)^2  
  )
  # Store correlation results  
  correlation_results[[i]] <- data.frame(  
    Split = i,  
    Pearson_r = cor(test_data$MeHg, predictions, method = "pearson"),  
    Spearman_rho = cor(test_data$MeHg, predictions, method = "spearman"),  
    R_squared = cor(test_data$MeHg, predictions)^2,  
    R_squared_lm = summary(lm(predictions ~ test_data$MeHg))$r.squared
  )  
} 

# Get variable names (predictors from your model)  
var_names <- c("overall_hgcA", "overall_SRB_hgcA", "overall_methanogen",   
               "overall_methanogen_hgcA", "overall_merB",   
               "overall_aerobic_methanotroph", "overall_aerobic_methanotroph_mbnT", "F1Hg")  

# Create a data frame to store summary statistics  
importance_summary <- data.frame(  
  Variable = var_names,  
  Mean_IncMSE = numeric(length(var_names)),  
  Lower_CI_IncMSE = numeric(length(var_names)),  
  Upper_CI_IncMSE = numeric(length(var_names)),  
  Mean_pvalue = numeric(length(var_names)),  
  Significant_Splits = numeric(length(var_names)),  
  stringsAsFactors = FALSE  
)  

# Process each variable  
for (j in 1:length(var_names)) {  
  v <- var_names[j]  
  
  # Collect %IncMSE values across all splits  
  inc_mse_values <- sapply(importance_results, function(x) x[v, "%IncMSE"])  
  
  # Collect p-values across all splits  
  p_values <- sapply(importance_results, function(x) x[v, "%IncMSE.pval"])  
  
  # Calculate mean and 95% confidence intervals  
  importance_summary$Mean_IncMSE[j] <- mean(inc_mse_values)  
  importance_summary$Lower_CI_IncMSE[j] <- quantile(inc_mse_values, 0.025)  
  importance_summary$Upper_CI_IncMSE[j] <- quantile(inc_mse_values, 0.975)  
  
  # Calculate mean p-value and count of significant splits (p < 0.05)  
  importance_summary$Mean_pvalue[j] <- mean(p_values)  
  importance_summary$Significant_Splits[j] <- sum(p_values < 0.05)  
} 

# Calculate percentage of splits where variable was significant  
importance_summary$Significance_Rate <- (importance_summary$Significant_Splits / length(importance_results)) * 100  

# Sort by mean importance  
importance_summary <- importance_summary[order(importance_summary$Mean_IncMSE, decreasing = TRUE), ]  


importance_summary


# Combine performance metrics  
all_performance <- do.call(rbind, performance_metrics)  
all_correlations <- do.call(rbind, correlation_results)  


# Summarize performance across all splits  
performance_summary <- data.frame(  
  Metric = c("RMSE", "MAE", "R_squared"),  
  Mean = c(  
    mean(all_performance$RMSE),  
    mean(all_performance$MAE),  
    mean(all_performance$R_squared)  
  ),  
  Median = c(  
    median(all_performance$RMSE),  
    median(all_performance$MAE),  
    median(all_performance$R_squared)  
  ),  
  StdDev = c(  
    sd(all_performance$RMSE),  
    sd(all_performance$MAE),  
    sd(all_performance$R_squared)  
  ),  
  Min = c(  
    min(all_performance$RMSE),  
    min(all_performance$MAE),  
    min(all_performance$R_squared)  
  ),  
  Max = c(  
    max(all_performance$RMSE),  
    max(all_performance$MAE),  
    max(all_performance$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_performance$RMSE, 0.025),  
    quantile(all_performance$MAE, 0.025),  
    quantile(all_performance$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_performance$RMSE, 0.975),  
    quantile(all_performance$MAE, 0.975),  
    quantile(all_performance$R_squared, 0.975)  
  )  
)  

# Summarize correlation metrics  
correlation_summary <- data.frame(  
  Metric = c("Pearson_r", "Spearman_rho", "R_squared"),  
  Mean = c(  
    mean(all_correlations$Pearson_r),  
    mean(all_correlations$Spearman_rho),  
    mean(all_correlations$R_squared)  
  ),  
  Median = c(  
    median(all_correlations$Pearson_r),  
    median(all_correlations$Spearman_rho),  
    median(all_correlations$R_squared)  
  ),  
  StdDev = c(  
    sd(all_correlations$Pearson_r),  
    sd(all_correlations$Spearman_rho),  
    sd(all_correlations$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_correlations$Pearson_r, 0.025),  
    quantile(all_correlations$Spearman_rho, 0.025),  
    quantile(all_correlations$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_correlations$Pearson_r, 0.975),  
    quantile(all_correlations$Spearman_rho, 0.975),  
    quantile(all_correlations$R_squared, 0.975)  
  )  
)  

# Print performance summaries  
cat("\nPerformance Metrics Summary:\n")  
print(performance_summary)  

cat("\nCorrelation Metrics Summary:\n")  
print(correlation_summary)



# 1. Variable importance plot with confidence intervals  
# Add significance indicators to the data with correct logic  
importance_summary$Significance <- ifelse(importance_summary$Significance_Rate >= 90,   
                                         "Consistently Significant (p<0.05 in ≥90% of splits)",  
                                         ifelse(importance_summary$Significance_Rate >= 10,  
                                                "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                "Rarely Significant (p<0.05 in <10% of splits)"))  

# Convert to factor with specific order  
importance_summary$Significance <- factor(importance_summary$Significance,   
                                          levels = c("Consistently Significant (p<0.05 in ≥90% of splits)",  
                                                    "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                    "Rarely Significant (p<0.05 in <10% of splits)"))  

# Add percentage value to show in the plot  
importance_summary$label_text <- sprintf("%.1f%% (p=%.3f)",   
                                        importance_summary$Significance_Rate,   
                                        importance_summary$Mean_pvalue)  


importance_plot <- ggplot(importance_summary, aes(x = reorder(Variable, Mean_IncMSE), y = Mean_IncMSE)) +  
  geom_point(aes(size = Significance_Rate, color = Significance), alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower_CI_IncMSE, ymax = Upper_CI_IncMSE,   
                    color = Significance), width = 0.4, linewidth = 1) +  
  geom_text(aes(label = label_text), hjust = -0.2, size = 3, vjust = -0.5) +  
  coord_flip() +  
  scale_color_manual(values = c("Consistently Significant (p<0.05 in ≥90% of splits)" = "#1a9850",  
                               "Sometimes Significant (p<0.05 in 10-89% of splits)" = "#d9ef8b",  
                               "Rarely Significant (p<0.05 in <10% of splits)" = "#fee08b")) +  
  scale_size_continuous(range = c(3, 6)) +  
  labs(x = "Predictor Variable",   
       y = "Mean Percent Increase in Mean Squared Error (%IncMSE)",  
       title = "Variable Importance in Random Forest Model with 95% Confidence Intervals",  
       subtitle = paste("Based on", length(importance_results), "different data splits with permutation tests"),  
       caption = "Error bars show 95% confidence intervals across data splits.\nPercentage values indicate the proportion of data splits where the variable was significant (p<0.05).\nLarger point size indicates higher significance rate across splits.") +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    plot.caption = element_text(hjust = 0, size = 9, color = "darkgrey"),  
    legend.title = element_text(face = "bold", size = 10),  
    legend.position = "bottom",  
    legend.box = "vertical",  
    panel.grid.major.y = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.grid.major.x = element_line(color = "lightgrey", linetype = "dotted"),  
    axis.title = element_text(face = "bold"),  
    axis.text.y = element_text(size = 11)  
  ) +  
  guides(size = "none") +  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")  





# 2. Create a performance metrics visualization using your summary data  
# Convert performance_summary to long format for plotting  
performance_long <- rbind(  
  data.frame(Metric = "RMSE",   
             Value = performance_summary$Mean[performance_summary$Metric == "RMSE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "RMSE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "RMSE"]),  
  data.frame(Metric = "MAE",   
             Value = performance_summary$Mean[performance_summary$Metric == "MAE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "MAE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "MAE"]),  
  data.frame(Metric = "R²",   
             Value = performance_summary$Mean[performance_summary$Metric == "R_squared"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "R_squared"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "R_squared"]),  
  data.frame(Metric = "Pearson r",   
             Value = correlation_summary$Mean[correlation_summary$Metric == "Pearson_r"],  
             Lower = correlation_summary$CI_Lower[correlation_summary$Metric == "Pearson_r"],  
             Upper = correlation_summary$CI_Upper[correlation_summary$Metric == "Pearson_r"]) 
)  

# Add labels  
performance_long$Label <- sprintf("%.3f\n(95%% CI: %.3f-%.3f)",   
                                 performance_long$Value,   
                                 performance_long$Lower,   
                                 performance_long$Upper)  

# Order the metrics in a logical way  
performance_long$Metric <- factor(performance_long$Metric,   
                                 levels = c("R²", "Pearson r", "RMSE", "MAE"))  

# Create bar chart for performance metrics  
performance_plot <- ggplot(performance_long, aes(x = Metric, y = Value, fill = Metric)) +  
  geom_bar(stat = "identity", width = 0.6, alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.3, linewidth = 1, color="grey70") +  
  geom_text(aes(label = Label, y = Upper + (max(Upper) * 0.05)),   
            vjust = 0, size = 3.5) +  
  scale_fill_brewer(palette = "Blues") +  
  labs(title = "Model Performance Metrics",  
       subtitle = "Mean values with 95% confidence intervals across all data splits",  
       y = "Value",  
       x = NULL) +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    legend.position = "none",  
    panel.grid.major.x = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.text.x = element_text(size = 11, face = "bold"),  
    axis.title = element_text(face = "bold")  
  ) +  
  coord_cartesian(ylim = c(0, max(performance_long$Upper) * 1.15))  

# 3. Create a custom annotation plot to explain the metrics  
annotation_text <- data.frame(  
  x = 1,  
  y = 1,  
  label = paste(  
    "Performance Metrics Explained:\n",  
    "• R² (Coefficient of determination): Amount of variance explained by the model (higher is better)\n",  
    "• Pearson r: Linear correlation between predicted and actual values (higher is better)\n",  
    "• Spearman ρ: Rank correlation between predicted and actual values (higher is better)\n",  
    "• RMSE (Root Mean Squared Error): Average magnitude of prediction errors (lower is better)\n",  
    "• MAE (Mean Absolute Error): Average absolute prediction error (lower is better)\n\n",  
    "Model Summary:\n",  
    "• Random Forest with rfPermute (2001 trees, mtry=4)\n",  
    "• 100 permutation tests for variable importance\n",  
    "• Cross-validation with random 70/30 train/test splits\n",  
    "• Response variable: MeHg concentration"  
  )  
)  

annotation_plot <- ggplot(annotation_text, aes(x = x, y = y, label = label)) +  
  geom_text(hjust = 0, vjust = 1, size = 3.5) +  
  theme_void() +  
  coord_cartesian(xlim = c(0, 10), ylim = c(0, 2))  


# 4. Now combine the plots using patchwork  
# Side-by-side importance plot and performance metrics  
combined_plot1 <- importance_plot + performance_plot +   
  plot_layout(widths = c(3, 2)) +  
  plot_annotation(  
    title = "Random Forest Model for MeHg Prediction: Variable Importance and Performance",  
    theme = theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))  
  )  +
  plot_annotation(tag_levels = 'A')

combined_plot1

# Save the importance plot in PDF format with dimensions in centimeters  
ggsave("output/rf_model.pdf",   
       plot = combined_plot1,   
       width = 50,   
       height = 20,   
       units = "cm")

```

# Random Forest Regression (MeHg as a continuous variable)
## MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + F1-Hg
## applying library size correction
## including a permutation step for data splitting, because I realized the importance would change when you do different splits of data
```r
library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(rfPermute)  
library(reshape2)  

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses.csv", header = TRUE)

# remove rows with NA
df <- na.omit(df)  

# implement library size correction values 
df$overall_hgcA_ <- df$overall_hgcA * df$library_correction_value  
df$overall_SRB_hgcA <- df$overall_SRB_hgcA * df$library_correction_value  
df$overall_methanogen <- df$overall_methanogen * df$library_correction_value  
df$overall_methanogen_hgcA <- df$overall_methanogen_hgcA * df$library_correction_value  
df$overall_merB <- df$overall_merB * df$library_correction_value  
df$overall_aerobic_methanotroph <- df$overall_aerobic_methanotroph * df$library_correction_value  
df$overall_aerobic_methanotroph_mbnT <- df$overall_aerobic_methanotroph_mbnT * df$library_correction_value 

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# Number of data split permutations  
n_splits <- 100

# Create storage for importance metrics across different splits  
importance_results <- list()  
pvalue_results <- list()  
performance_metrics <- list()  
correlation_results <- list()  

# 3. Split Data into Training and Testing Sets  
# Set a seed for reproducibility
# Run models with different random splits  
for (i in 1:n_splits) {  
  # Set a different seed for each data split  
  set.seed(i)  
  
  # Split data  
  train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
  train_data <- df[train_indices, ]  
  test_data <- df[-train_indices, ]  
  
  # Set a seed for rfPermute  
  set.seed(123)  
  
  # Train the rfPermute model  
  rp_model <- rfPermute(  
    MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen +   
           overall_methanogen_hgcA + overall_merB +   
           overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + F1Hg,  
    data = train_data,  
    ntree = 2001,  
    mtry = 4,  
    importance = TRUE,  
    num.rep = 100  # Reduced to 100 for computational efficiency  
  )  
  
  # Store the importance values  
  importance_results[[i]] <- importance(rp_model)  
  
  # Store the p-values  
  pvalue_results[[i]] <- rp_model$pval  
  
  # Get predictions on test data  
  predictions <- predict(rp_model, newdata = test_data)  
  
  # Calculate and store performance metrics  
  performance_metrics[[i]] <- data.frame(  
    Split = i,  
    RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
    MAE = mean(abs(test_data$MeHg - predictions)),  
    R_squared = cor(test_data$MeHg, predictions)^2  
  )
  # Store correlation results  
  correlation_results[[i]] <- data.frame(  
    Split = i,  
    Pearson_r = cor(test_data$MeHg, predictions, method = "pearson"),  
    Spearman_rho = cor(test_data$MeHg, predictions, method = "spearman"),  
    R_squared = cor(test_data$MeHg, predictions)^2,  
    R_squared_lm = summary(lm(predictions ~ test_data$MeHg))$r.squared
  )  
} 

# Get variable names (predictors from your model)  
var_names <- c("overall_hgcA", "overall_SRB_hgcA", "overall_methanogen",   
               "overall_methanogen_hgcA", "overall_merB",   
               "overall_aerobic_methanotroph", "overall_aerobic_methanotroph_mbnT", "F1Hg")  

# Create a data frame to store summary statistics  
importance_summary <- data.frame(  
  Variable = var_names,  
  Mean_IncMSE = numeric(length(var_names)),  
  Lower_CI_IncMSE = numeric(length(var_names)),  
  Upper_CI_IncMSE = numeric(length(var_names)),  
  Mean_pvalue = numeric(length(var_names)),  
  Significant_Splits = numeric(length(var_names)),  
  stringsAsFactors = FALSE  
)  

# Process each variable  
for (j in 1:length(var_names)) {  
  v <- var_names[j]  
  
  # Collect %IncMSE values across all splits  
  inc_mse_values <- sapply(importance_results, function(x) x[v, "%IncMSE"])  
  
  # Collect p-values across all splits  
  p_values <- sapply(importance_results, function(x) x[v, "%IncMSE.pval"])  
  
  # Calculate mean and 95% confidence intervals  
  importance_summary$Mean_IncMSE[j] <- mean(inc_mse_values)  
  importance_summary$Lower_CI_IncMSE[j] <- quantile(inc_mse_values, 0.025)  
  importance_summary$Upper_CI_IncMSE[j] <- quantile(inc_mse_values, 0.975)  
  
  # Calculate mean p-value and count of significant splits (p < 0.05)  
  importance_summary$Mean_pvalue[j] <- mean(p_values)  
  importance_summary$Significant_Splits[j] <- sum(p_values < 0.05)  
} 

# Calculate percentage of splits where variable was significant  
importance_summary$Significance_Rate <- (importance_summary$Significant_Splits / length(importance_results)) * 100  

# Sort by mean importance  
importance_summary <- importance_summary[order(importance_summary$Mean_IncMSE, decreasing = TRUE), ]  


importance_summary


# Combine performance metrics  
all_performance <- do.call(rbind, performance_metrics)  
all_correlations <- do.call(rbind, correlation_results)  


# Summarize performance across all splits  
performance_summary <- data.frame(  
  Metric = c("RMSE", "MAE", "R_squared"),  
  Mean = c(  
    mean(all_performance$RMSE),  
    mean(all_performance$MAE),  
    mean(all_performance$R_squared)  
  ),  
  Median = c(  
    median(all_performance$RMSE),  
    median(all_performance$MAE),  
    median(all_performance$R_squared)  
  ),  
  StdDev = c(  
    sd(all_performance$RMSE),  
    sd(all_performance$MAE),  
    sd(all_performance$R_squared)  
  ),  
  Min = c(  
    min(all_performance$RMSE),  
    min(all_performance$MAE),  
    min(all_performance$R_squared)  
  ),  
  Max = c(  
    max(all_performance$RMSE),  
    max(all_performance$MAE),  
    max(all_performance$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_performance$RMSE, 0.025),  
    quantile(all_performance$MAE, 0.025),  
    quantile(all_performance$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_performance$RMSE, 0.975),  
    quantile(all_performance$MAE, 0.975),  
    quantile(all_performance$R_squared, 0.975)  
  )  
)  

# Summarize correlation metrics  
correlation_summary <- data.frame(  
  Metric = c("Pearson_r", "Spearman_rho", "R_squared"),  
  Mean = c(  
    mean(all_correlations$Pearson_r),  
    mean(all_correlations$Spearman_rho),  
    mean(all_correlations$R_squared)  
  ),  
  Median = c(  
    median(all_correlations$Pearson_r),  
    median(all_correlations$Spearman_rho),  
    median(all_correlations$R_squared)  
  ),  
  StdDev = c(  
    sd(all_correlations$Pearson_r),  
    sd(all_correlations$Spearman_rho),  
    sd(all_correlations$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_correlations$Pearson_r, 0.025),  
    quantile(all_correlations$Spearman_rho, 0.025),  
    quantile(all_correlations$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_correlations$Pearson_r, 0.975),  
    quantile(all_correlations$Spearman_rho, 0.975),  
    quantile(all_correlations$R_squared, 0.975)  
  )  
)  

# Print performance summaries  
cat("\nPerformance Metrics Summary:\n")  
print(performance_summary)  

cat("\nCorrelation Metrics Summary:\n")  
print(correlation_summary)



# 1. Variable importance plot with confidence intervals  
# Add significance indicators to the data with correct logic  
importance_summary$Significance <- ifelse(importance_summary$Significance_Rate >= 90,   
                                         "Consistently Significant (p<0.05 in ≥90% of splits)",  
                                         ifelse(importance_summary$Significance_Rate >= 10,  
                                                "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                "Rarely Significant (p<0.05 in <10% of splits)"))  

# Convert to factor with specific order  
importance_summary$Significance <- factor(importance_summary$Significance,   
                                          levels = c("Consistently Significant (p<0.05 in ≥90% of splits)",  
                                                    "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                    "Rarely Significant (p<0.05 in <10% of splits)"))  

# Add percentage value to show in the plot  
importance_summary$label_text <- sprintf("%.1f%% (p=%.3f)",   
                                        importance_summary$Significance_Rate,   
                                        importance_summary$Mean_pvalue)  


importance_plot <- ggplot(importance_summary, aes(x = reorder(Variable, Mean_IncMSE), y = Mean_IncMSE)) +  
  geom_point(aes(size = Significance_Rate, color = Significance), alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower_CI_IncMSE, ymax = Upper_CI_IncMSE,   
                    color = Significance), width = 0.4, linewidth = 1) +  
  geom_text(aes(label = label_text), hjust = -0.2, size = 3, vjust = -0.5) +  
  coord_flip() +  
  scale_color_manual(values = c("Consistently Significant (p<0.05 in ≥90% of splits)" = "#1a9850",  
                               "Sometimes Significant (p<0.05 in 10-89% of splits)" = "#d9ef8b",  
                               "Rarely Significant (p<0.05 in <10% of splits)" = "#fee08b")) +  
  scale_size_continuous(range = c(3, 6)) +  
  labs(x = "Predictor Variable",   
       y = "Mean Percent Increase in Mean Squared Error (%IncMSE)",  
       title = "Variable Importance in Random Forest Model with 95% Confidence Intervals",  
       subtitle = paste("Based on", length(importance_results), "different data splits with permutation tests"),  
       caption = "Error bars show 95% confidence intervals across data splits.\nPercentage values indicate the proportion of data splits where the variable was significant (p<0.05).\nLarger point size indicates higher significance rate across splits.") +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    plot.caption = element_text(hjust = 0, size = 9, color = "darkgrey"),  
    legend.title = element_text(face = "bold", size = 10),  
    legend.position = "bottom",  
    legend.box = "vertical",  
    panel.grid.major.y = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.grid.major.x = element_line(color = "lightgrey", linetype = "dotted"),  
    axis.title = element_text(face = "bold"),  
    axis.text.y = element_text(size = 11)  
  ) +  
  guides(size = "none") +  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")  





# 2. Create a performance metrics visualization using your summary data  
# Convert performance_summary to long format for plotting  
performance_long <- rbind(  
  data.frame(Metric = "RMSE",   
             Value = performance_summary$Mean[performance_summary$Metric == "RMSE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "RMSE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "RMSE"]),  
  data.frame(Metric = "MAE",   
             Value = performance_summary$Mean[performance_summary$Metric == "MAE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "MAE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "MAE"]),  
  data.frame(Metric = "R²",   
             Value = performance_summary$Mean[performance_summary$Metric == "R_squared"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "R_squared"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "R_squared"]),  
  data.frame(Metric = "Pearson r",   
             Value = correlation_summary$Mean[correlation_summary$Metric == "Pearson_r"],  
             Lower = correlation_summary$CI_Lower[correlation_summary$Metric == "Pearson_r"],  
             Upper = correlation_summary$CI_Upper[correlation_summary$Metric == "Pearson_r"]) 
)  

# Add labels  
performance_long$Label <- sprintf("%.3f\n(95%% CI: %.3f-%.3f)",   
                                 performance_long$Value,   
                                 performance_long$Lower,   
                                 performance_long$Upper)  

# Order the metrics in a logical way  
performance_long$Metric <- factor(performance_long$Metric,   
                                 levels = c("R²", "Pearson r", "RMSE", "MAE"))  

# Create bar chart for performance metrics  
performance_plot <- ggplot(performance_long, aes(x = Metric, y = Value, fill = Metric)) +  
  geom_bar(stat = "identity", width = 0.6, alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.3, linewidth = 1, color="grey70") +  
  geom_text(aes(label = Label, y = Upper + (max(Upper) * 0.05)),   
            vjust = 0, size = 3.5) +  
  scale_fill_brewer(palette = "Blues") +  
  labs(title = "Model Performance Metrics",  
       subtitle = "Mean values with 95% confidence intervals across all data splits",  
       y = "Value",  
       x = NULL) +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    legend.position = "none",  
    panel.grid.major.x = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.text.x = element_text(size = 11, face = "bold"),  
    axis.title = element_text(face = "bold")  
  ) +  
  coord_cartesian(ylim = c(0, max(performance_long$Upper) * 1.15))  

# 3. Create a custom annotation plot to explain the metrics  
annotation_text <- data.frame(  
  x = 1,  
  y = 1,  
  label = paste(  
    "Performance Metrics Explained:\n",  
    "• R² (Coefficient of determination): Amount of variance explained by the model (higher is better)\n",  
    "• Pearson r: Linear correlation between predicted and actual values (higher is better)\n",  
    "• Spearman ρ: Rank correlation between predicted and actual values (higher is better)\n",  
    "• RMSE (Root Mean Squared Error): Average magnitude of prediction errors (lower is better)\n",  
    "• MAE (Mean Absolute Error): Average absolute prediction error (lower is better)\n\n",  
    "Model Summary:\n",  
    "• Random Forest with rfPermute (2001 trees, mtry=4)\n",  
    "• 100 permutation tests for variable importance\n",  
    "• Cross-validation with random 70/30 train/test splits\n",  
    "• Response variable: MeHg concentration"  
  )  
)  

annotation_plot <- ggplot(annotation_text, aes(x = x, y = y, label = label)) +  
  geom_text(hjust = 0, vjust = 1, size = 3.5) +  
  theme_void() +  
  coord_cartesian(xlim = c(0, 10), ylim = c(0, 2))  


# 4. Now combine the plots using patchwork  
# Side-by-side importance plot and performance metrics  
combined_plot1 <- importance_plot + performance_plot +   
  plot_layout(widths = c(3, 2)) +  
  plot_annotation(  
    title = "Random Forest Model for MeHg Prediction: Variable Importance and Performance",  
    theme = theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))  
  )  +
  plot_annotation(tag_levels = 'A')

combined_plot1

# Save the importance plot in PDF format with dimensions in centimeters  
ggsave("output/rf_model_library_size_adjusted.pdf",   
       plot = combined_plot1,   
       width = 50,   
       height = 20,   
       units = "cm")

```


# Random Forest Regression (MeHg as a continuous variable)
## MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + F1-Hg
## including a permutation step for data splitting, because I realized the importance would change when you do different splits of data
## using the latest SRB,IRB, methanogen data
```r 
library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(rfPermute)  
library(reshape2)  

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

# remove rows with NA
df <- na.omit(df)  

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# Number of data split permutations, adjust this number to change the number of permutations, change to 100 in final run
n_splits <- 100

# Create storage for importance metrics across different splits  
importance_results <- list()  
pvalue_results <- list()  
performance_metrics <- list()  
correlation_results <- list()  

# 3. Split Data into Training and Testing Sets  
# Set a seed for reproducibility
# Run models with different random splits  
for (i in 1:n_splits) {  
  # Set a different seed for each data split  
  set.seed(i)  
  
  # Split data  
  train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
  train_data <- df[train_indices, ]  
  test_data <- df[-train_indices, ]  
  
  # Set a seed for rfPermute  
  set.seed(123)  
  
  # Train the rfPermute model  
  rp_model <- rfPermute(  
    MeHg ~ overall_hgcA + 
           overall_SRB_hgcA +
           overall_IRB_hgcA + 
           overall_methanogen_hgcA + 
           overall_methanogen +   
           overall_merB +   
           overall_aerobic_methanotroph + 
           overall_aerobic_methanotroph_mbnT + 
           F1Hg,  
    data = train_data,  
    ntree = 2001,  
    mtry = 4,  
    importance = TRUE,  
    num.rep = 100  # Reduced to 100 for computational efficiency  
  )  
  
  # Store the importance values  
  importance_results[[i]] <- importance(rp_model)  
  
  # Store the p-values  
  pvalue_results[[i]] <- rp_model$pval  
  
  # Get predictions on test data  
  predictions <- predict(rp_model, newdata = test_data)  
  
  # Calculate and store performance metrics  
  performance_metrics[[i]] <- data.frame(  
    Split = i,  
    RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
    MAE = mean(abs(test_data$MeHg - predictions)),  
    R_squared = cor(test_data$MeHg, predictions)^2  
  )
  # Store correlation results  
  correlation_results[[i]] <- data.frame(  
    Split = i,  
    Pearson_r = cor(test_data$MeHg, predictions, method = "pearson"),  
    Spearman_rho = cor(test_data$MeHg, predictions, method = "spearman"),  
    R_squared = cor(test_data$MeHg, predictions)^2,  
    R_squared_lm = summary(lm(predictions ~ test_data$MeHg))$r.squared
  )  
} 

# Get variable names (predictors from your model)  
var_names <- c("overall_hgcA", 
               "overall_SRB_hgcA", 
               "overall_IRB_hgcA",   
               "overall_methanogen_hgcA", 
               "overall_methanogen", 
               "overall_merB",   
               "overall_aerobic_methanotroph", 
               "overall_aerobic_methanotroph_mbnT", 
               "F1Hg")  

# Create a data frame to store summary statistics  
importance_summary <- data.frame(  
  Variable = var_names,  
  Mean_IncMSE = numeric(length(var_names)),  
  Lower_CI_IncMSE = numeric(length(var_names)),  
  Upper_CI_IncMSE = numeric(length(var_names)),  
  Mean_pvalue = numeric(length(var_names)),  
  Significant_Splits = numeric(length(var_names)),  
  stringsAsFactors = FALSE  
)  

# Process each variable  
for (j in 1:length(var_names)) {  
  v <- var_names[j]  
  
  # Collect %IncMSE values across all splits  
  inc_mse_values <- sapply(importance_results, function(x) x[v, "%IncMSE"])  
  
  # Collect p-values across all splits  
  p_values <- sapply(importance_results, function(x) x[v, "%IncMSE.pval"])  
  
  # Calculate mean and 95% confidence intervals  
  importance_summary$Mean_IncMSE[j] <- mean(inc_mse_values)  
  importance_summary$Lower_CI_IncMSE[j] <- quantile(inc_mse_values, 0.025)  
  importance_summary$Upper_CI_IncMSE[j] <- quantile(inc_mse_values, 0.975)  
  
  # Calculate mean p-value and count of significant splits (p < 0.05)  
  importance_summary$Mean_pvalue[j] <- mean(p_values)  
  importance_summary$Significant_Splits[j] <- sum(p_values < 0.05)  
} 

# Calculate percentage of splits where variable was significant  
importance_summary$Significance_Rate <- (importance_summary$Significant_Splits / length(importance_results)) * 100  

# Sort by mean importance  
importance_summary <- importance_summary[order(importance_summary$Mean_IncMSE, decreasing = TRUE), ]  


importance_summary


# Combine performance metrics  
all_performance <- do.call(rbind, performance_metrics)  
all_correlations <- do.call(rbind, correlation_results)  


# Summarize performance across all splits  
performance_summary <- data.frame(  
  Metric = c("RMSE", "MAE", "R_squared"),  
  Mean = c(  
    mean(all_performance$RMSE),  
    mean(all_performance$MAE),  
    mean(all_performance$R_squared)  
  ),  
  Median = c(  
    median(all_performance$RMSE),  
    median(all_performance$MAE),  
    median(all_performance$R_squared)  
  ),  
  StdDev = c(  
    sd(all_performance$RMSE),  
    sd(all_performance$MAE),  
    sd(all_performance$R_squared)  
  ),  
  Min = c(  
    min(all_performance$RMSE),  
    min(all_performance$MAE),  
    min(all_performance$R_squared)  
  ),  
  Max = c(  
    max(all_performance$RMSE),  
    max(all_performance$MAE),  
    max(all_performance$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_performance$RMSE, 0.025),  
    quantile(all_performance$MAE, 0.025),  
    quantile(all_performance$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_performance$RMSE, 0.975),  
    quantile(all_performance$MAE, 0.975),  
    quantile(all_performance$R_squared, 0.975)  
  )  
)  

# Summarize correlation metrics  
correlation_summary <- data.frame(  
  Metric = c("Pearson_r", "Spearman_rho", "R_squared"),  
  Mean = c(  
    mean(all_correlations$Pearson_r),  
    mean(all_correlations$Spearman_rho),  
    mean(all_correlations$R_squared)  
  ),  
  Median = c(  
    median(all_correlations$Pearson_r),  
    median(all_correlations$Spearman_rho),  
    median(all_correlations$R_squared)  
  ),  
  StdDev = c(  
    sd(all_correlations$Pearson_r),  
    sd(all_correlations$Spearman_rho),  
    sd(all_correlations$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_correlations$Pearson_r, 0.025),  
    quantile(all_correlations$Spearman_rho, 0.025),  
    quantile(all_correlations$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_correlations$Pearson_r, 0.975),  
    quantile(all_correlations$Spearman_rho, 0.975),  
    quantile(all_correlations$R_squared, 0.975)  
  )  
)  

# Print performance summaries  
cat("\nPerformance Metrics Summary:\n")  
print(performance_summary)  

cat("\nCorrelation Metrics Summary:\n")  
print(correlation_summary)



# 1. Variable importance plot with confidence intervals  
# Add significance indicators to the data with correct logic  
importance_summary$Significance <- ifelse(importance_summary$Significance_Rate >= 90,   
                                         "Consistently Significant (p<0.05 in ≥90% of splits)",  
                                         ifelse(importance_summary$Significance_Rate >= 10,  
                                                "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                "Rarely Significant (p<0.05 in <10% of splits)"))  

# Convert to factor with specific order  
importance_summary$Significance <- factor(importance_summary$Significance,   
                                          levels = c("Consistently Significant (p<0.05 in ≥90% of splits)",  
                                                    "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                    "Rarely Significant (p<0.05 in <10% of splits)"))  

# Add percentage value to show in the plot  
importance_summary$label_text <- sprintf("%.1f%% (p=%.3f)",   
                                        importance_summary$Significance_Rate,   
                                        importance_summary$Mean_pvalue)  


importance_plot <- ggplot(importance_summary, aes(x = reorder(Variable, Mean_IncMSE), y = Mean_IncMSE)) +  
  geom_point(aes(size = Significance_Rate, color = Significance), alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower_CI_IncMSE, ymax = Upper_CI_IncMSE,   
                    color = Significance), width = 0.4, linewidth = 1) +  
  geom_text(aes(label = label_text), hjust = -0.2, size = 3, vjust = -0.5) +  
  coord_flip() +  
  scale_color_manual(values = c("Consistently Significant (p<0.05 in ≥90% of splits)" = "#1a9850",  
                               "Sometimes Significant (p<0.05 in 10-89% of splits)" = "#d9ef8b",  
                               "Rarely Significant (p<0.05 in <10% of splits)" = "#fee08b")) +  
  scale_size_continuous(range = c(3, 6)) +  
  labs(x = "Predictor Variable",   
       y = "Mean Percent Increase in Mean Squared Error (%IncMSE)",  
       title = "Variable Importance in Random Forest Model with 95% Confidence Intervals",  
       subtitle = paste("Based on", length(importance_results), "different data splits with permutation tests"),  
       caption = "Error bars show 95% confidence intervals across data splits.\nPercentage values indicate the proportion of data splits where the variable was significant (p<0.05).\nLarger point size indicates higher significance rate across splits.") +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    plot.caption = element_text(hjust = 0, size = 9, color = "darkgrey"),  
    legend.title = element_text(face = "bold", size = 10),  
    legend.position = "bottom",  
    legend.box = "vertical",  
    panel.grid.major.y = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.grid.major.x = element_line(color = "lightgrey", linetype = "dotted"),  
    axis.title = element_text(face = "bold"),  
    axis.text.y = element_text(size = 11)  
  ) +  
  guides(size = "none") +  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")  


# 2. Create a performance metrics visualization using your summary data  
# Convert performance_summary to long format for plotting  
performance_long <- rbind(  
  data.frame(Metric = "RMSE",   
             Value = performance_summary$Mean[performance_summary$Metric == "RMSE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "RMSE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "RMSE"]),  
  data.frame(Metric = "MAE",   
             Value = performance_summary$Mean[performance_summary$Metric == "MAE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "MAE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "MAE"]),  
  data.frame(Metric = "R²",   
             Value = performance_summary$Mean[performance_summary$Metric == "R_squared"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "R_squared"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "R_squared"]),  
  data.frame(Metric = "Pearson r",   
             Value = correlation_summary$Mean[correlation_summary$Metric == "Pearson_r"],  
             Lower = correlation_summary$CI_Lower[correlation_summary$Metric == "Pearson_r"],  
             Upper = correlation_summary$CI_Upper[correlation_summary$Metric == "Pearson_r"]) 
)  

# Add labels  
performance_long$Label <- sprintf("%.3f\n(95%% CI: %.3f-%.3f)",   
                                 performance_long$Value,   
                                 performance_long$Lower,   
                                 performance_long$Upper)  

# Order the metrics in a logical way  
performance_long$Metric <- factor(performance_long$Metric,   
                                 levels = c("R²", "Pearson r", "RMSE", "MAE"))  

# Create bar chart for performance metrics  
performance_plot <- ggplot(performance_long, aes(x = Metric, y = Value, fill = Metric)) +  
  geom_bar(stat = "identity", width = 0.6, alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.3, linewidth = 1, color="grey70") +  
  geom_text(aes(label = Label, y = Upper + (max(Upper) * 0.05)),   
            vjust = 0, size = 3.5) +  
  scale_fill_brewer(palette = "Blues") +  
  labs(title = "Model Performance Metrics",  
       subtitle = "Mean values with 95% confidence intervals across all data splits",  
       y = "Value",  
       x = NULL) +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    legend.position = "none",  
    panel.grid.major.x = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.text.x = element_text(size = 11, face = "bold"),  
    axis.title = element_text(face = "bold")  
  ) +  
  coord_cartesian(ylim = c(0, max(performance_long$Upper) * 1.15))  

# 3. Create a custom annotation plot to explain the metrics  
annotation_text <- data.frame(  
  x = 1,  
  y = 1,  
  label = paste(  
    "Performance Metrics Explained:\n",  
    "• R² (Coefficient of determination): Amount of variance explained by the model (higher is better)\n",  
    "• Pearson r: Linear correlation between predicted and actual values (higher is better)\n",  
    "• Spearman ρ: Rank correlation between predicted and actual values (higher is better)\n",  
    "• RMSE (Root Mean Squared Error): Average magnitude of prediction errors (lower is better)\n",  
    "• MAE (Mean Absolute Error): Average absolute prediction error (lower is better)\n\n",  
    "Model Summary:\n",  
    "• Random Forest with rfPermute (2001 trees, mtry=4)\n",  
    "• 100 permutation tests for variable importance\n",  
    "• Cross-validation with random 70/30 train/test splits\n",  
    "• Response variable: MeHg concentration"  
  )  
)  

annotation_plot <- ggplot(annotation_text, aes(x = x, y = y, label = label)) +  
  geom_text(hjust = 0, vjust = 1, size = 3.5) +  
  theme_void() +  
  coord_cartesian(xlim = c(0, 10), ylim = c(0, 2))  


# 4. Now combine the plots using patchwork  
# Side-by-side importance plot and performance metrics  
combined_plot1 <- importance_plot + performance_plot +   
  plot_layout(widths = c(3, 2)) +  
  plot_annotation(  
    title = "Random Forest Model for MeHg Prediction: Variable Importance and Performance",  
    theme = theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))  
  )  +
  plot_annotation(tag_levels = 'A')

combined_plot1

# Save the importance plot in PDF format with dimensions in centimeters  
 ggsave("output/rf_model_SRBIRB_updated_test.pdf",   
       plot = combined_plot1,   
       width = 50,   
       height = 20,   
       units = "cm")

```

# Random Forest Regression (MeHg as a continuous variable)
## MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + overall_aerobic_methanotroph_mbnT + F1-Hg + DOM + DOM_SUVA254
## including a permutation step for data splitting, because I realized the importance would change when you do different splits of data
## using the latest SRB,IRB, methanogen data
## All sites full model 
```r 
library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(rfPermute)  
library(reshape2)  

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

# remove rows with NA
df <- na.omit(df)  

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# Number of data split permutations, adjust this number to change the number of permutations, change to 100 in final run
n_splits <- 100

# Create storage for importance metrics across different splits  
importance_results <- list()  
pvalue_results <- list()  
performance_metrics <- list()  
correlation_results <- list()  

# 3. Split Data into Training and Testing Sets  
# Set a seed for reproducibility
# Run models with different random splits  
for (i in 1:n_splits) {  
  # Set a different seed for each data split  
  set.seed(i)  
  
  # Split data  
  train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
  train_data <- df[train_indices, ]  
  test_data <- df[-train_indices, ]  
  
  # Set a seed for rfPermute  
  set.seed(123)  
  
  # Train the rfPermute model  
  rp_model <- rfPermute(  
    MeHg ~ overall_hgcA + 
           overall_SRB_hgcA +
           overall_IRB_hgcA + 
           overall_methanogen_hgcA + 
           overall_methanogen +   
           overall_merB +   
           overall_aerobic_methanotroph + 
           overall_aerobic_methanotroph_mbnT + 
           F1Hg +
           DOM + 
           DOM_SUVA254,  
    data = train_data,  
    ntree = 2001,  
    mtry = 4,  
    importance = TRUE,  
    num.rep = 100  # Reduced to 100 for computational efficiency  
  )  
  
  # Store the importance values  
  importance_results[[i]] <- importance(rp_model)  
  
  # Store the p-values  
  pvalue_results[[i]] <- rp_model$pval  
  
  # Get predictions on test data  
  predictions <- predict(rp_model, newdata = test_data)  
  
  # Calculate and store performance metrics  
  performance_metrics[[i]] <- data.frame(  
    Split = i,  
    RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
    MAE = mean(abs(test_data$MeHg - predictions)),  
    R_squared = cor(test_data$MeHg, predictions)^2  
  )
  # Store correlation results  
  correlation_results[[i]] <- data.frame(  
    Split = i,  
    Pearson_r = cor(test_data$MeHg, predictions, method = "pearson"),  
    Spearman_rho = cor(test_data$MeHg, predictions, method = "spearman"),  
    R_squared = cor(test_data$MeHg, predictions)^2,  
    R_squared_lm = summary(lm(predictions ~ test_data$MeHg))$r.squared
  )  
} 

# Get variable names (predictors from your model)  
var_names <- c("overall_hgcA", 
               "overall_SRB_hgcA", 
               "overall_IRB_hgcA",   
               "overall_methanogen_hgcA", 
               "overall_methanogen", 
               "overall_merB",   
               "overall_aerobic_methanotroph", 
               "overall_aerobic_methanotroph_mbnT", 
               "F1Hg",
               "DOM",
               "DOM_SUVA254")  

# Create a data frame to store summary statistics  
importance_summary <- data.frame(  
  Variable = var_names,  
  Mean_IncMSE = numeric(length(var_names)),  
  Lower_CI_IncMSE = numeric(length(var_names)),  
  Upper_CI_IncMSE = numeric(length(var_names)),  
  Mean_pvalue = numeric(length(var_names)),  
  Significant_Splits = numeric(length(var_names)),  
  stringsAsFactors = FALSE  
)  

# Process each variable  
for (j in 1:length(var_names)) {  
  v <- var_names[j]  
  
  # Collect %IncMSE values across all splits  
  inc_mse_values <- sapply(importance_results, function(x) x[v, "%IncMSE"])  
  
  # Collect p-values across all splits  
  p_values <- sapply(importance_results, function(x) x[v, "%IncMSE.pval"])  
  
  # Calculate mean and 95% confidence intervals  
  importance_summary$Mean_IncMSE[j] <- mean(inc_mse_values)  
  importance_summary$Lower_CI_IncMSE[j] <- quantile(inc_mse_values, 0.025)  
  importance_summary$Upper_CI_IncMSE[j] <- quantile(inc_mse_values, 0.975)  
  
  # Calculate mean p-value and count of significant splits (p < 0.05)  
  importance_summary$Mean_pvalue[j] <- mean(p_values)  
  importance_summary$Significant_Splits[j] <- sum(p_values < 0.05)  
} 

# Calculate percentage of splits where variable was significant  
importance_summary$Significance_Rate <- (importance_summary$Significant_Splits / length(importance_results)) * 100  

# Sort by mean importance  
importance_summary <- importance_summary[order(importance_summary$Mean_IncMSE, decreasing = TRUE), ]  


importance_summary


# Combine performance metrics  
all_performance <- do.call(rbind, performance_metrics)  
all_correlations <- do.call(rbind, correlation_results)  


# Summarize performance across all splits  
performance_summary <- data.frame(  
  Metric = c("RMSE", "MAE", "R_squared"),  
  Mean = c(  
    mean(all_performance$RMSE),  
    mean(all_performance$MAE),  
    mean(all_performance$R_squared)  
  ),  
  Median = c(  
    median(all_performance$RMSE),  
    median(all_performance$MAE),  
    median(all_performance$R_squared)  
  ),  
  StdDev = c(  
    sd(all_performance$RMSE),  
    sd(all_performance$MAE),  
    sd(all_performance$R_squared)  
  ),  
  Min = c(  
    min(all_performance$RMSE),  
    min(all_performance$MAE),  
    min(all_performance$R_squared)  
  ),  
  Max = c(  
    max(all_performance$RMSE),  
    max(all_performance$MAE),  
    max(all_performance$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_performance$RMSE, 0.025),  
    quantile(all_performance$MAE, 0.025),  
    quantile(all_performance$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_performance$RMSE, 0.975),  
    quantile(all_performance$MAE, 0.975),  
    quantile(all_performance$R_squared, 0.975)  
  )  
)  

# Summarize correlation metrics  
correlation_summary <- data.frame(  
  Metric = c("Pearson_r", "Spearman_rho", "R_squared"),  
  Mean = c(  
    mean(all_correlations$Pearson_r),  
    mean(all_correlations$Spearman_rho),  
    mean(all_correlations$R_squared)  
  ),  
  Median = c(  
    median(all_correlations$Pearson_r),  
    median(all_correlations$Spearman_rho),  
    median(all_correlations$R_squared)  
  ),  
  StdDev = c(  
    sd(all_correlations$Pearson_r),  
    sd(all_correlations$Spearman_rho),  
    sd(all_correlations$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_correlations$Pearson_r, 0.025),  
    quantile(all_correlations$Spearman_rho, 0.025),  
    quantile(all_correlations$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_correlations$Pearson_r, 0.975),  
    quantile(all_correlations$Spearman_rho, 0.975),  
    quantile(all_correlations$R_squared, 0.975)  
  )  
)  

# Print performance summaries  
cat("\nPerformance Metrics Summary:\n")  
print(performance_summary)  

cat("\nCorrelation Metrics Summary:\n")  
print(correlation_summary)



# 1. Variable importance plot with confidence intervals  
# Add significance indicators to the data with correct logic  
importance_summary$Significance <- ifelse(importance_summary$Significance_Rate >= 90,   
                                         "Consistently Significant (p<0.05 in ≥90% of splits)",  
                                         ifelse(importance_summary$Significance_Rate >= 10,  
                                                "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                "Rarely Significant (p<0.05 in <10% of splits)"))  

# Convert to factor with specific order  
importance_summary$Significance <- factor(importance_summary$Significance,   
                                          levels = c("Consistently Significant (p<0.05 in ≥90% of splits)",  
                                                    "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                    "Rarely Significant (p<0.05 in <10% of splits)"))  

# Add percentage value to show in the plot  
importance_summary$label_text <- sprintf("%.1f%% (p=%.3f)",   
                                        importance_summary$Significance_Rate,   
                                        importance_summary$Mean_pvalue)  


importance_plot <- ggplot(importance_summary, aes(x = reorder(Variable, Mean_IncMSE), y = Mean_IncMSE)) +  
  geom_point(aes(size = Significance_Rate, color = Significance), alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower_CI_IncMSE, ymax = Upper_CI_IncMSE,   
                    color = Significance), width = 0.4, linewidth = 1) +  
  geom_text(aes(label = label_text), hjust = -0.2, size = 3, vjust = -0.5) +  
  coord_flip() +  
  scale_color_manual(values = c("Consistently Significant (p<0.05 in ≥90% of splits)" = "#1a9850",  
                               "Sometimes Significant (p<0.05 in 10-89% of splits)" = "#d9ef8b",  
                               "Rarely Significant (p<0.05 in <10% of splits)" = "#fee08b")) +  
  scale_size_continuous(range = c(3, 6)) +  
  labs(x = "Predictor Variable",   
       y = "Mean Percent Increase in Mean Squared Error (%IncMSE)",  
       title = "Variable Importance in Random Forest Model with 95% Confidence Intervals",  
       subtitle = paste("Based on", length(importance_results), "different data splits with permutation tests"),  
       caption = "Error bars show 95% confidence intervals across data splits.\nPercentage values indicate the proportion of data splits where the variable was significant (p<0.05).\nLarger point size indicates higher significance rate across splits.") +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    plot.caption = element_text(hjust = 0, size = 9, color = "darkgrey"),  
    legend.title = element_text(face = "bold", size = 10),  
    legend.position = "bottom",  
    legend.box = "vertical",  
    panel.grid.major.y = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.grid.major.x = element_line(color = "lightgrey", linetype = "dotted"),  
    axis.title = element_text(face = "bold"),  
    axis.text.y = element_text(size = 11)  
  ) +  
  guides(size = "none") +  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")  


# 2. Create a performance metrics visualization using your summary data  
# Convert performance_summary to long format for plotting  
performance_long <- rbind(  
  data.frame(Metric = "RMSE",   
             Value = performance_summary$Mean[performance_summary$Metric == "RMSE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "RMSE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "RMSE"]),  
  data.frame(Metric = "MAE",   
             Value = performance_summary$Mean[performance_summary$Metric == "MAE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "MAE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "MAE"]),  
  data.frame(Metric = "R²",   
             Value = performance_summary$Mean[performance_summary$Metric == "R_squared"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "R_squared"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "R_squared"]),  
  data.frame(Metric = "Pearson r",   
             Value = correlation_summary$Mean[correlation_summary$Metric == "Pearson_r"],  
             Lower = correlation_summary$CI_Lower[correlation_summary$Metric == "Pearson_r"],  
             Upper = correlation_summary$CI_Upper[correlation_summary$Metric == "Pearson_r"]) 
)  

# Add labels  
performance_long$Label <- sprintf("%.3f\n(95%% CI: %.3f-%.3f)",   
                                 performance_long$Value,   
                                 performance_long$Lower,   
                                 performance_long$Upper)  

# Order the metrics in a logical way  
performance_long$Metric <- factor(performance_long$Metric,   
                                 levels = c("R²", "Pearson r", "RMSE", "MAE"))  

# Create bar chart for performance metrics  
performance_plot <- ggplot(performance_long, aes(x = Metric, y = Value, fill = Metric)) +  
  geom_bar(stat = "identity", width = 0.6, alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.3, linewidth = 1, color="grey70") +  
  geom_text(aes(label = Label, y = Upper + (max(Upper) * 0.05)),   
            vjust = 0, size = 3.5) +  
  scale_fill_brewer(palette = "Blues") +  
  labs(title = "Model Performance Metrics",  
       subtitle = "Mean values with 95% confidence intervals across all data splits",  
       y = "Value",  
       x = NULL) +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    legend.position = "none",  
    panel.grid.major.x = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.text.x = element_text(size = 11, face = "bold"),  
    axis.title = element_text(face = "bold")  
  ) +  
  coord_cartesian(ylim = c(0, max(performance_long$Upper) * 1.15))  

# 3. Create a custom annotation plot to explain the metrics  
annotation_text <- data.frame(  
  x = 1,  
  y = 1,  
  label = paste(  
    "Performance Metrics Explained:\n",  
    "• R² (Coefficient of determination): Amount of variance explained by the model (higher is better)\n",  
    "• Pearson r: Linear correlation between predicted and actual values (higher is better)\n",  
    "• Spearman ρ: Rank correlation between predicted and actual values (higher is better)\n",  
    "• RMSE (Root Mean Squared Error): Average magnitude of prediction errors (lower is better)\n",  
    "• MAE (Mean Absolute Error): Average absolute prediction error (lower is better)\n\n",  
    "Model Summary:\n",  
    "• Random Forest with rfPermute (2001 trees, mtry=4)\n",  
    "• 100 permutation tests for variable importance\n",  
    "• Cross-validation with random 70/30 train/test splits\n",  
    "• Response variable: MeHg concentration"  
  )  
)  

annotation_plot <- ggplot(annotation_text, aes(x = x, y = y, label = label)) +  
  geom_text(hjust = 0, vjust = 1, size = 3.5) +  
  theme_void() +  
  coord_cartesian(xlim = c(0, 10), ylim = c(0, 2))  


# 4. Now combine the plots using patchwork  
# Side-by-side importance plot and performance metrics  
combined_plot1 <- importance_plot + performance_plot +   
  plot_layout(widths = c(3, 2)) +  
  plot_annotation(  
    title = "Random Forest Model for MeHg Prediction: Variable Importance and Performance",  
    theme = theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))  
  )  +
  plot_annotation(tag_levels = 'A')

combined_plot1

# Save the importance plot in PDF format with dimensions in centimeters  
ggsave("output/rf_model_comparisons/rf_model_full.pdf",   
       plot = combined_plot1,   
       width = 45,   
       height = 20,   
       units = "cm")

```

## All sites reduced model 
```r 
library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(rfPermute)  
library(reshape2)  

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

# remove rows with NA
df <- na.omit(df)  

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# Number of data split permutations, adjust this number to change the number of permutations, change to 100 in final run
n_splits <- 100

# Create storage for importance metrics across different splits  
importance_results <- list()  
pvalue_results <- list()  
performance_metrics <- list()  
correlation_results <- list()  

# 3. Split Data into Training and Testing Sets  
# Set a seed for reproducibility
# Run models with different random splits  
for (i in 1:n_splits) {  
  # Set a different seed for each data split  
  set.seed(i)  
  
  # Split data  
  train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
  train_data <- df[train_indices, ]  
  test_data <- df[-train_indices, ]  
  
  # Set a seed for rfPermute  
  set.seed(123)  
  
  # Train the rfPermute model  
  rp_model <- rfPermute(  
    MeHg ~ 
           overall_methanogen_hgcA + 
           overall_methanogen +   
           overall_aerobic_methanotroph + 
           F1Hg +
           DOM_SUVA254,  
    data = train_data,  
    ntree = 2001,  
    mtry = 4,  
    importance = TRUE,  
    num.rep = 100  # Reduced to 100 for computational efficiency  
  )  
  
  # Store the importance values  
  importance_results[[i]] <- importance(rp_model)  
  
  # Store the p-values  
  pvalue_results[[i]] <- rp_model$pval  
  
  # Get predictions on test data  
  predictions <- predict(rp_model, newdata = test_data)  
  
  # Calculate and store performance metrics  
  performance_metrics[[i]] <- data.frame(  
    Split = i,  
    RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
    MAE = mean(abs(test_data$MeHg - predictions)),  
    R_squared = cor(test_data$MeHg, predictions)^2  
  )
  # Store correlation results  
  correlation_results[[i]] <- data.frame(  
    Split = i,  
    Pearson_r = cor(test_data$MeHg, predictions, method = "pearson"),  
    Spearman_rho = cor(test_data$MeHg, predictions, method = "spearman"),  
    R_squared = cor(test_data$MeHg, predictions)^2,  
    R_squared_lm = summary(lm(predictions ~ test_data$MeHg))$r.squared
  )  
} 

# Get variable names (predictors from your model)  
var_names <- c(
               "overall_methanogen_hgcA", 
               "overall_methanogen", 
               "overall_aerobic_methanotroph", 
               "F1Hg",
               "DOM_SUVA254")  

# Create a data frame to store summary statistics  
importance_summary <- data.frame(  
  Variable = var_names,  
  Mean_IncMSE = numeric(length(var_names)),  
  Lower_CI_IncMSE = numeric(length(var_names)),  
  Upper_CI_IncMSE = numeric(length(var_names)),  
  Mean_pvalue = numeric(length(var_names)),  
  Significant_Splits = numeric(length(var_names)),  
  stringsAsFactors = FALSE  
)  

# Process each variable  
for (j in 1:length(var_names)) {  
  v <- var_names[j]  
  
  # Collect %IncMSE values across all splits  
  inc_mse_values <- sapply(importance_results, function(x) x[v, "%IncMSE"])  
  
  # Collect p-values across all splits  
  p_values <- sapply(importance_results, function(x) x[v, "%IncMSE.pval"])  
  
  # Calculate mean and 95% confidence intervals  
  importance_summary$Mean_IncMSE[j] <- mean(inc_mse_values)  
  importance_summary$Lower_CI_IncMSE[j] <- quantile(inc_mse_values, 0.025)  
  importance_summary$Upper_CI_IncMSE[j] <- quantile(inc_mse_values, 0.975)  
  
  # Calculate mean p-value and count of significant splits (p < 0.05)  
  importance_summary$Mean_pvalue[j] <- mean(p_values)  
  importance_summary$Significant_Splits[j] <- sum(p_values < 0.05)  
} 

# Calculate percentage of splits where variable was significant  
importance_summary$Significance_Rate <- (importance_summary$Significant_Splits / length(importance_results)) * 100  

# Sort by mean importance  
importance_summary <- importance_summary[order(importance_summary$Mean_IncMSE, decreasing = TRUE), ]  


importance_summary


# Combine performance metrics  
all_performance <- do.call(rbind, performance_metrics)  
all_correlations <- do.call(rbind, correlation_results)  


# Summarize performance across all splits  
performance_summary <- data.frame(  
  Metric = c("RMSE", "MAE", "R_squared"),  
  Mean = c(  
    mean(all_performance$RMSE),  
    mean(all_performance$MAE),  
    mean(all_performance$R_squared)  
  ),  
  Median = c(  
    median(all_performance$RMSE),  
    median(all_performance$MAE),  
    median(all_performance$R_squared)  
  ),  
  StdDev = c(  
    sd(all_performance$RMSE),  
    sd(all_performance$MAE),  
    sd(all_performance$R_squared)  
  ),  
  Min = c(  
    min(all_performance$RMSE),  
    min(all_performance$MAE),  
    min(all_performance$R_squared)  
  ),  
  Max = c(  
    max(all_performance$RMSE),  
    max(all_performance$MAE),  
    max(all_performance$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_performance$RMSE, 0.025),  
    quantile(all_performance$MAE, 0.025),  
    quantile(all_performance$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_performance$RMSE, 0.975),  
    quantile(all_performance$MAE, 0.975),  
    quantile(all_performance$R_squared, 0.975)  
  )  
)  

# Summarize correlation metrics  
correlation_summary <- data.frame(  
  Metric = c("Pearson_r", "Spearman_rho", "R_squared"),  
  Mean = c(  
    mean(all_correlations$Pearson_r),  
    mean(all_correlations$Spearman_rho),  
    mean(all_correlations$R_squared)  
  ),  
  Median = c(  
    median(all_correlations$Pearson_r),  
    median(all_correlations$Spearman_rho),  
    median(all_correlations$R_squared)  
  ),  
  StdDev = c(  
    sd(all_correlations$Pearson_r),  
    sd(all_correlations$Spearman_rho),  
    sd(all_correlations$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_correlations$Pearson_r, 0.025),  
    quantile(all_correlations$Spearman_rho, 0.025),  
    quantile(all_correlations$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_correlations$Pearson_r, 0.975),  
    quantile(all_correlations$Spearman_rho, 0.975),  
    quantile(all_correlations$R_squared, 0.975)  
  )  
)  

# Print performance summaries  
cat("\nPerformance Metrics Summary:\n")  
print(performance_summary)  

cat("\nCorrelation Metrics Summary:\n")  
print(correlation_summary)



# 1. Variable importance plot with confidence intervals  
# Add significance indicators to the data with correct logic  
importance_summary$Significance <- ifelse(importance_summary$Significance_Rate >= 90,   
                                         "Consistently Significant (p<0.05 in ≥90% of splits)",  
                                         ifelse(importance_summary$Significance_Rate >= 10,  
                                                "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                "Rarely Significant (p<0.05 in <10% of splits)"))  

# Convert to factor with specific order  
importance_summary$Significance <- factor(importance_summary$Significance,   
                                          levels = c("Consistently Significant (p<0.05 in ≥90% of splits)",  
                                                    "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                    "Rarely Significant (p<0.05 in <10% of splits)"))  

# Add percentage value to show in the plot  
importance_summary$label_text <- sprintf("%.1f%% (p=%.3f)",   
                                        importance_summary$Significance_Rate,   
                                        importance_summary$Mean_pvalue)  


importance_plot <- ggplot(importance_summary, aes(x = reorder(Variable, Mean_IncMSE), y = Mean_IncMSE)) +  
  geom_point(aes(size = Significance_Rate, color = Significance), alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower_CI_IncMSE, ymax = Upper_CI_IncMSE,   
                    color = Significance), width = 0.4, linewidth = 1) +  
  geom_text(aes(label = label_text), hjust = -0.2, size = 3, vjust = -0.5) +  
  coord_flip() +  
  scale_color_manual(values = c("Consistently Significant (p<0.05 in ≥90% of splits)" = "#1a9850",  
                               "Sometimes Significant (p<0.05 in 10-89% of splits)" = "#d9ef8b",  
                               "Rarely Significant (p<0.05 in <10% of splits)" = "#fee08b")) +  
  scale_size_continuous(range = c(3, 6)) +  
  labs(x = "Predictor Variable",   
       y = "Mean Percent Increase in Mean Squared Error (%IncMSE)",  
       title = "Variable Importance in Random Forest Model with 95% Confidence Intervals",  
       subtitle = paste("Based on", length(importance_results), "different data splits with permutation tests"),  
       caption = "Error bars show 95% confidence intervals across data splits.\nPercentage values indicate the proportion of data splits where the variable was significant (p<0.05).\nLarger point size indicates higher significance rate across splits.") +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    plot.caption = element_text(hjust = 0, size = 9, color = "darkgrey"),  
    legend.title = element_text(face = "bold", size = 10),  
    legend.position = "bottom",  
    legend.box = "vertical",  
    panel.grid.major.y = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.grid.major.x = element_line(color = "lightgrey", linetype = "dotted"),  
    axis.title = element_text(face = "bold"),  
    axis.text.y = element_text(size = 11)  
  ) +  
  guides(size = "none") +  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")  


# 2. Create a performance metrics visualization using your summary data  
# Convert performance_summary to long format for plotting  
performance_long <- rbind(  
  data.frame(Metric = "RMSE",   
             Value = performance_summary$Mean[performance_summary$Metric == "RMSE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "RMSE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "RMSE"]),  
  data.frame(Metric = "MAE",   
             Value = performance_summary$Mean[performance_summary$Metric == "MAE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "MAE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "MAE"]),  
  data.frame(Metric = "R²",   
             Value = performance_summary$Mean[performance_summary$Metric == "R_squared"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "R_squared"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "R_squared"]),  
  data.frame(Metric = "Pearson r",   
             Value = correlation_summary$Mean[correlation_summary$Metric == "Pearson_r"],  
             Lower = correlation_summary$CI_Lower[correlation_summary$Metric == "Pearson_r"],  
             Upper = correlation_summary$CI_Upper[correlation_summary$Metric == "Pearson_r"]) 
)  

# Add labels  
performance_long$Label <- sprintf("%.3f\n(95%% CI: %.3f-%.3f)",   
                                 performance_long$Value,   
                                 performance_long$Lower,   
                                 performance_long$Upper)  

# Order the metrics in a logical way  
performance_long$Metric <- factor(performance_long$Metric,   
                                 levels = c("R²", "Pearson r", "RMSE", "MAE"))  

# Create bar chart for performance metrics  
performance_plot <- ggplot(performance_long, aes(x = Metric, y = Value, fill = Metric)) +  
  geom_bar(stat = "identity", width = 0.6, alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.3, linewidth = 1, color="grey70") +  
  geom_text(aes(label = Label, y = Upper + (max(Upper) * 0.05)),   
            vjust = 0, size = 3.5) +  
  scale_fill_brewer(palette = "Blues") +  
  labs(title = "Model Performance Metrics",  
       subtitle = "Mean values with 95% confidence intervals across all data splits",  
       y = "Value",  
       x = NULL) +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    legend.position = "none",  
    panel.grid.major.x = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.text.x = element_text(size = 11, face = "bold"),  
    axis.title = element_text(face = "bold")  
  ) +  
  coord_cartesian(ylim = c(0, max(performance_long$Upper) * 1.15))  

# 3. Create a custom annotation plot to explain the metrics  
annotation_text <- data.frame(  
  x = 1,  
  y = 1,  
  label = paste(  
    "Performance Metrics Explained:\n",  
    "• R² (Coefficient of determination): Amount of variance explained by the model (higher is better)\n",  
    "• Pearson r: Linear correlation between predicted and actual values (higher is better)\n",  
    "• Spearman ρ: Rank correlation between predicted and actual values (higher is better)\n",  
    "• RMSE (Root Mean Squared Error): Average magnitude of prediction errors (lower is better)\n",  
    "• MAE (Mean Absolute Error): Average absolute prediction error (lower is better)\n\n",  
    "Model Summary:\n",  
    "• Random Forest with rfPermute (2001 trees, mtry=4)\n",  
    "• 100 permutation tests for variable importance\n",  
    "• Cross-validation with random 70/30 train/test splits\n",  
    "• Response variable: MeHg concentration"  
  )  
)  

annotation_plot <- ggplot(annotation_text, aes(x = x, y = y, label = label)) +  
  geom_text(hjust = 0, vjust = 1, size = 3.5) +  
  theme_void() +  
  coord_cartesian(xlim = c(0, 10), ylim = c(0, 2))  


# 4. Now combine the plots using patchwork  
# Side-by-side importance plot and performance metrics  
combined_plot1 <- importance_plot + performance_plot +   
  plot_layout(widths = c(3, 2)) +  
  plot_annotation(  
    title = "Random Forest Model for MeHg Prediction: Variable Importance and Performance",  
    theme = theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))  
  )  +
  plot_annotation(tag_levels = 'A')

combined_plot1

# Save the importance plot in PDF format with dimensions in centimeters  
ggsave("output/rf_model_comparisons/rf_model_reduced.pdf",   
       plot = combined_plot1,   
       width = 45,   
       height = 20,   
       units = "cm")

```

# 20250722 update
# Random Forest Regression (MeHg as a continuous variable)
## MeHg ~ overall_hgcA + overall_SRB_hgcA + overall_methanogen + overall_methanogen_hgcA +  overall_merB + overall_aerobic_methanotroph + F1-Hg + DOM + DOM_SUVA254 + flooding status (removed mbnT and added flooding status)
## including a permutation step for data splitting, because I realized the importance would change when you do different splits of data
## using the latest SRB,IRB, methanogen data
## All sites full model 
```r 
library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(rfPermute)  
library(reshape2)  

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

# remove rows with NA
df <- na.omit(df)  

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

df$water <- as.factor(df$water)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# Number of data split permutations, adjust this number to change the number of permutations, change to 100 in final run
n_splits <- 100 # do 10 for now

# Create storage for importance metrics across different splits  
importance_results <- list()  
pvalue_results <- list()  
performance_metrics <- list()  
correlation_results <- list()  

# 3. Split Data into Training and Testing Sets  
# Set a seed for reproducibility
# Run models with different random splits  
for (i in 1:n_splits) {  
  # Set a different seed for each data split  
  set.seed(i)  
  
  # Split data  
  train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
  train_data <- df[train_indices, ]  
  test_data <- df[-train_indices, ]  
  
  # Set a seed for rfPermute  
  set.seed(123)  
  
  # Train the rfPermute model  
  rp_model <- rfPermute(  
    MeHg ~ overall_hgcA + 
           overall_SRB_hgcA +
           overall_IRB_hgcA + 
           overall_methanogen_hgcA + 
           overall_methanogen +   
           overall_merB +   
           overall_aerobic_methanotroph + 
           F1Hg +
           DOM + 
           DOM_SUVA254, 
    data = train_data,  
    ntree = 2001,  
    mtry = 4,  
    importance = TRUE,  
    num.rep = 100  # Reduced to 100 for computational efficiency
  )  
  
  # Store the importance values  
  importance_results[[i]] <- importance(rp_model)  
  
  # Store the p-values  
  pvalue_results[[i]] <- rp_model$pval  
  
  # Get predictions on test data  
  predictions <- predict(rp_model, newdata = test_data)  
  
  # Calculate and store performance metrics  
  performance_metrics[[i]] <- data.frame(  
    Split = i,  
    RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
    MAE = mean(abs(test_data$MeHg - predictions)),  
    R_squared = cor(test_data$MeHg, predictions)^2  
  )
  # Store correlation results  
  correlation_results[[i]] <- data.frame(  
    Split = i,  
    Pearson_r = cor(test_data$MeHg, predictions, method = "pearson"),  
    Spearman_rho = cor(test_data$MeHg, predictions, method = "spearman"),  
    R_squared = cor(test_data$MeHg, predictions)^2,  
    R_squared_lm = summary(lm(predictions ~ test_data$MeHg))$r.squared
  )  
} 

# Get variable names (predictors from your model)  
var_names <- c("overall_hgcA", 
               "overall_SRB_hgcA", 
               "overall_IRB_hgcA",   
               "overall_methanogen_hgcA", 
               "overall_methanogen", 
               "overall_merB",   
               "overall_aerobic_methanotroph", 
               "F1Hg",
               "DOM",
               "DOM_SUVA254")  

# Create a data frame to store summary statistics  
importance_summary <- data.frame(  
  Variable = var_names,  
  Mean_IncMSE = numeric(length(var_names)),  
  Lower_CI_IncMSE = numeric(length(var_names)),  
  Upper_CI_IncMSE = numeric(length(var_names)),  
  Mean_pvalue = numeric(length(var_names)),  
  Significant_Splits = numeric(length(var_names)),  
  stringsAsFactors = FALSE  
)  

# Process each variable  
for (j in 1:length(var_names)) {  
  v <- var_names[j]  
  
  # Collect %IncMSE values across all splits  
  inc_mse_values <- sapply(importance_results, function(x) x[v, "%IncMSE"])  
  
  # Collect p-values across all splits  
  p_values <- sapply(importance_results, function(x) x[v, "%IncMSE.pval"])  
  
  # Calculate mean and 95% confidence intervals  
  importance_summary$Mean_IncMSE[j] <- mean(inc_mse_values)  
  importance_summary$Lower_CI_IncMSE[j] <- quantile(inc_mse_values, 0.025)  
  importance_summary$Upper_CI_IncMSE[j] <- quantile(inc_mse_values, 0.975)  
  
  # Calculate mean p-value and count of significant splits (p < 0.05)  
  importance_summary$Mean_pvalue[j] <- mean(p_values)  
  importance_summary$Significant_Splits[j] <- sum(p_values < 0.05)  
} 

# Calculate percentage of splits where variable was significant  
importance_summary$Significance_Rate <- (importance_summary$Significant_Splits / length(importance_results)) * 100  

# Sort by mean importance  
importance_summary <- importance_summary[order(importance_summary$Mean_IncMSE, decreasing = TRUE), ]  


importance_summary


# Combine performance metrics  
all_performance <- do.call(rbind, performance_metrics)  
all_correlations <- do.call(rbind, correlation_results)  


# Summarize performance across all splits  
performance_summary <- data.frame(  
  Metric = c("RMSE", "MAE", "R_squared"),  
  Mean = c(  
    mean(all_performance$RMSE),  
    mean(all_performance$MAE),  
    mean(all_performance$R_squared)  
  ),  
  Median = c(  
    median(all_performance$RMSE),  
    median(all_performance$MAE),  
    median(all_performance$R_squared)  
  ),  
  StdDev = c(  
    sd(all_performance$RMSE),  
    sd(all_performance$MAE),  
    sd(all_performance$R_squared)  
  ),  
  Min = c(  
    min(all_performance$RMSE),  
    min(all_performance$MAE),  
    min(all_performance$R_squared)  
  ),  
  Max = c(  
    max(all_performance$RMSE),  
    max(all_performance$MAE),  
    max(all_performance$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_performance$RMSE, 0.025),  
    quantile(all_performance$MAE, 0.025),  
    quantile(all_performance$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_performance$RMSE, 0.975),  
    quantile(all_performance$MAE, 0.975),  
    quantile(all_performance$R_squared, 0.975)  
  )  
)  

# Summarize correlation metrics  
correlation_summary <- data.frame(  
  Metric = c("Pearson_r", "Spearman_rho", "R_squared"),  
  Mean = c(  
    mean(all_correlations$Pearson_r),  
    mean(all_correlations$Spearman_rho),  
    mean(all_correlations$R_squared)  
  ),  
  Median = c(  
    median(all_correlations$Pearson_r),  
    median(all_correlations$Spearman_rho),  
    median(all_correlations$R_squared)  
  ),  
  StdDev = c(  
    sd(all_correlations$Pearson_r),  
    sd(all_correlations$Spearman_rho),  
    sd(all_correlations$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_correlations$Pearson_r, 0.025),  
    quantile(all_correlations$Spearman_rho, 0.025),  
    quantile(all_correlations$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_correlations$Pearson_r, 0.975),  
    quantile(all_correlations$Spearman_rho, 0.975),  
    quantile(all_correlations$R_squared, 0.975)  
  )  
)  

# Print performance summaries  
cat("\nPerformance Metrics Summary:\n")  
print(performance_summary)  

cat("\nCorrelation Metrics Summary:\n")  
print(correlation_summary)



# 1. Variable importance plot with confidence intervals  
# Add significance indicators to the data with correct logic  
importance_summary$Significance <- ifelse(importance_summary$Significance_Rate >= 90,   
                                         "Consistently Significant (p<0.05 in ≥90% of splits)",  
                                         ifelse(importance_summary$Significance_Rate >= 10,  
                                                "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                "Rarely Significant (p<0.05 in <10% of splits)"))  

# Convert to factor with specific order  
importance_summary$Significance <- factor(importance_summary$Significance,   
                                          levels = c("Consistently Significant (p<0.05 in ≥90% of splits)",  
                                                    "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                    "Rarely Significant (p<0.05 in <10% of splits)"))  

# Add percentage value to show in the plot  
importance_summary$label_text <- sprintf("%.1f%% (p=%.3f)",   
                                        importance_summary$Significance_Rate,   
                                        importance_summary$Mean_pvalue)  


importance_plot <- ggplot(importance_summary, aes(x = reorder(Variable, Mean_IncMSE), y = Mean_IncMSE)) +  
  geom_point(aes(size = Significance_Rate, color = Significance), alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower_CI_IncMSE, ymax = Upper_CI_IncMSE,   
                    color = Significance), width = 0.4, linewidth = 1) +  
  geom_text(aes(label = label_text), hjust = -0.2, size = 3, vjust = -0.5) +  
  coord_flip() +  
  scale_color_manual(values = c("Consistently Significant (p<0.05 in ≥90% of splits)" = "#1a9850",  
                               "Sometimes Significant (p<0.05 in 10-89% of splits)" = "#d9ef8b",  
                               "Rarely Significant (p<0.05 in <10% of splits)" = "#fee08b")) +  
  scale_size_continuous(range = c(3, 6)) +  
  labs(x = "Predictor Variable",   
       y = "Mean Percent Increase in Mean Squared Error (%IncMSE)",  
       title = "Variable Importance in Random Forest Model with 95% Confidence Intervals",  
       subtitle = paste("Based on", length(importance_results), "different data splits with permutation tests"),  
       caption = "Error bars show 95% confidence intervals across data splits.\nPercentage values indicate the proportion of data splits where the variable was significant (p<0.05).\nLarger point size indicates higher significance rate across splits.") +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    plot.caption = element_text(hjust = 0, size = 9, color = "darkgrey"),  
    legend.title = element_text(face = "bold", size = 10),  
    legend.position = "bottom",  
    legend.box = "vertical",  
    panel.grid.major.y = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.grid.major.x = element_line(color = "lightgrey", linetype = "dotted"),  
    axis.title = element_text(face = "bold"),  
    axis.text.y = element_text(size = 11)  
  ) +  
  guides(size = "none") +  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")  


# 2. Create a performance metrics visualization using your summary data  
# Convert performance_summary to long format for plotting  
performance_long <- rbind(  
  data.frame(Metric = "RMSE",   
             Value = performance_summary$Mean[performance_summary$Metric == "RMSE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "RMSE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "RMSE"]),  
  data.frame(Metric = "MAE",   
             Value = performance_summary$Mean[performance_summary$Metric == "MAE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "MAE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "MAE"]),  
  data.frame(Metric = "R²",   
             Value = performance_summary$Mean[performance_summary$Metric == "R_squared"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "R_squared"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "R_squared"]),  
  data.frame(Metric = "Pearson r",   
             Value = correlation_summary$Mean[correlation_summary$Metric == "Pearson_r"],  
             Lower = correlation_summary$CI_Lower[correlation_summary$Metric == "Pearson_r"],  
             Upper = correlation_summary$CI_Upper[correlation_summary$Metric == "Pearson_r"]) 
)  

# Add labels  
performance_long$Label <- sprintf("%.3f\n(95%% CI: %.3f-%.3f)",   
                                 performance_long$Value,   
                                 performance_long$Lower,   
                                 performance_long$Upper)  

# Order the metrics in a logical way  
performance_long$Metric <- factor(performance_long$Metric,   
                                 levels = c("R²", "Pearson r", "RMSE", "MAE"))  

# Create bar chart for performance metrics  
performance_plot <- ggplot(performance_long, aes(x = Metric, y = Value, fill = Metric)) +  
  geom_bar(stat = "identity", width = 0.6, alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.3, linewidth = 1, color="grey70") +  
  geom_text(aes(label = Label, y = Upper + (max(Upper) * 0.05)),   
            vjust = 0, size = 3.5) +  
  scale_fill_brewer(palette = "Blues") +  
  labs(title = "Model Performance Metrics",  
       subtitle = "Mean values with 95% confidence intervals across all data splits",  
       y = "Value",  
       x = NULL) +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    legend.position = "none",  
    panel.grid.major.x = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.text.x = element_text(size = 11, face = "bold"),  
    axis.title = element_text(face = "bold")  
  ) +  
  coord_cartesian(ylim = c(0, max(performance_long$Upper) * 1.15))  

# 3. Create a custom annotation plot to explain the metrics  
annotation_text <- data.frame(  
  x = 1,  
  y = 1,  
  label = paste(  
    "Performance Metrics Explained:\n",  
    "• R² (Coefficient of determination): Amount of variance explained by the model (higher is better)\n",  
    "• Pearson r: Linear correlation between predicted and actual values (higher is better)\n",  
    "• Spearman ρ: Rank correlation between predicted and actual values (higher is better)\n",  
    "• RMSE (Root Mean Squared Error): Average magnitude of prediction errors (lower is better)\n",  
    "• MAE (Mean Absolute Error): Average absolute prediction error (lower is better)\n\n",  
    "Model Summary:\n",  
    "• Random Forest with rfPermute (2001 trees, mtry=4)\n",  
    "• 100 permutation tests for variable importance\n",  
    "• Cross-validation with random 70/30 train/test splits\n",  
    "• Response variable: MeHg concentration"  
  )  
)  

annotation_plot <- ggplot(annotation_text, aes(x = x, y = y, label = label)) +  
  geom_text(hjust = 0, vjust = 1, size = 3.5) +  
  theme_void() +  
  coord_cartesian(xlim = c(0, 10), ylim = c(0, 2))  


# 4. Now combine the plots using patchwork  
# Side-by-side importance plot and performance metrics  
combined_plot1 <- importance_plot + performance_plot +   
  plot_layout(widths = c(3, 2)) +  
  plot_annotation(  
    title = "Random Forest Model for MeHg Prediction: Variable Importance and Performance",  
    theme = theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))  
  )  +
  plot_annotation(tag_levels = 'A')

combined_plot1

# Save the importance plot in PDF format with dimensions in centimeters  
ggsave("output/rf_model_comparisons/20250722_rf_model_full.pdf",   
       plot = combined_plot1,   
       width = 45,   
       height = 20,   
       units = "cm")

```

## All sites reduced model 
```r 
library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(rfPermute)  
library(reshape2)  

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

# remove rows with NA
df <- na.omit(df)  

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# Number of data split permutations, adjust this number to change the number of permutations, change to 100 in final run
n_splits <- 100

# Create storage for importance metrics across different splits  
importance_results <- list()  
pvalue_results <- list()  
performance_metrics <- list()  
correlation_results <- list()  

# 3. Split Data into Training and Testing Sets  
# Set a seed for reproducibility
# Run models with different random splits  
for (i in 1:n_splits) {  
  # Set a different seed for each data split  
  set.seed(i)  
  
  # Split data  
  train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
  train_data <- df[train_indices, ]  
  test_data <- df[-train_indices, ]  
  
  # Set a seed for rfPermute  
  set.seed(123)  
  
  # Train the rfPermute model  
  rp_model <- rfPermute(  
    MeHg ~ 
           overall_methanogen_hgcA + 
           overall_methanogen +   
           overall_aerobic_methanotroph + 
           F1Hg +
           DOM_SUVA254,  
    data = train_data,  
    ntree = 2001,  
    mtry = 4,  
    importance = TRUE,  
    num.rep = 100  # Reduced to 100 for computational efficiency  
  )  
  
  # Store the importance values  
  importance_results[[i]] <- importance(rp_model)  
  
  # Store the p-values  
  pvalue_results[[i]] <- rp_model$pval  
  
  # Get predictions on test data  
  predictions <- predict(rp_model, newdata = test_data)  
  
  # Calculate and store performance metrics  
  performance_metrics[[i]] <- data.frame(  
    Split = i,  
    RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
    MAE = mean(abs(test_data$MeHg - predictions)),  
    R_squared = cor(test_data$MeHg, predictions)^2  
  )
  # Store correlation results  
  correlation_results[[i]] <- data.frame(  
    Split = i,  
    Pearson_r = cor(test_data$MeHg, predictions, method = "pearson"),  
    Spearman_rho = cor(test_data$MeHg, predictions, method = "spearman"),  
    R_squared = cor(test_data$MeHg, predictions)^2,  
    R_squared_lm = summary(lm(predictions ~ test_data$MeHg))$r.squared
  )  
} 

# Get variable names (predictors from your model)  
var_names <- c(
               "overall_methanogen_hgcA", 
               "overall_methanogen", 
               "overall_aerobic_methanotroph", 
               "F1Hg",
               "DOM_SUVA254")  

# Create a data frame to store summary statistics  
importance_summary <- data.frame(  
  Variable = var_names,  
  Mean_IncMSE = numeric(length(var_names)),  
  Lower_CI_IncMSE = numeric(length(var_names)),  
  Upper_CI_IncMSE = numeric(length(var_names)),  
  Mean_pvalue = numeric(length(var_names)),  
  Significant_Splits = numeric(length(var_names)),  
  stringsAsFactors = FALSE  
)  

# Process each variable  
for (j in 1:length(var_names)) {  
  v <- var_names[j]  
  
  # Collect %IncMSE values across all splits  
  inc_mse_values <- sapply(importance_results, function(x) x[v, "%IncMSE"])  
  
  # Collect p-values across all splits  
  p_values <- sapply(importance_results, function(x) x[v, "%IncMSE.pval"])  
  
  # Calculate mean and 95% confidence intervals  
  importance_summary$Mean_IncMSE[j] <- mean(inc_mse_values)  
  importance_summary$Lower_CI_IncMSE[j] <- quantile(inc_mse_values, 0.025)  
  importance_summary$Upper_CI_IncMSE[j] <- quantile(inc_mse_values, 0.975)  
  
  # Calculate mean p-value and count of significant splits (p < 0.05)  
  importance_summary$Mean_pvalue[j] <- mean(p_values)  
  importance_summary$Significant_Splits[j] <- sum(p_values < 0.05)  
} 

# Calculate percentage of splits where variable was significant  
importance_summary$Significance_Rate <- (importance_summary$Significant_Splits / length(importance_results)) * 100  

# Sort by mean importance  
importance_summary <- importance_summary[order(importance_summary$Mean_IncMSE, decreasing = TRUE), ]  


importance_summary


# Combine performance metrics  
all_performance <- do.call(rbind, performance_metrics)  
all_correlations <- do.call(rbind, correlation_results)  


# Summarize performance across all splits  
performance_summary <- data.frame(  
  Metric = c("RMSE", "MAE", "R_squared"),  
  Mean = c(  
    mean(all_performance$RMSE),  
    mean(all_performance$MAE),  
    mean(all_performance$R_squared)  
  ),  
  Median = c(  
    median(all_performance$RMSE),  
    median(all_performance$MAE),  
    median(all_performance$R_squared)  
  ),  
  StdDev = c(  
    sd(all_performance$RMSE),  
    sd(all_performance$MAE),  
    sd(all_performance$R_squared)  
  ),  
  Min = c(  
    min(all_performance$RMSE),  
    min(all_performance$MAE),  
    min(all_performance$R_squared)  
  ),  
  Max = c(  
    max(all_performance$RMSE),  
    max(all_performance$MAE),  
    max(all_performance$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_performance$RMSE, 0.025),  
    quantile(all_performance$MAE, 0.025),  
    quantile(all_performance$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_performance$RMSE, 0.975),  
    quantile(all_performance$MAE, 0.975),  
    quantile(all_performance$R_squared, 0.975)  
  )  
)  

# Summarize correlation metrics  
correlation_summary <- data.frame(  
  Metric = c("Pearson_r", "Spearman_rho", "R_squared"),  
  Mean = c(  
    mean(all_correlations$Pearson_r),  
    mean(all_correlations$Spearman_rho),  
    mean(all_correlations$R_squared)  
  ),  
  Median = c(  
    median(all_correlations$Pearson_r),  
    median(all_correlations$Spearman_rho),  
    median(all_correlations$R_squared)  
  ),  
  StdDev = c(  
    sd(all_correlations$Pearson_r),  
    sd(all_correlations$Spearman_rho),  
    sd(all_correlations$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_correlations$Pearson_r, 0.025),  
    quantile(all_correlations$Spearman_rho, 0.025),  
    quantile(all_correlations$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_correlations$Pearson_r, 0.975),  
    quantile(all_correlations$Spearman_rho, 0.975),  
    quantile(all_correlations$R_squared, 0.975)  
  )  
)  

# Print performance summaries  
cat("\nPerformance Metrics Summary:\n")  
print(performance_summary)  

cat("\nCorrelation Metrics Summary:\n")  
print(correlation_summary)



# 1. Variable importance plot with confidence intervals  
# Add significance indicators to the data with correct logic  
importance_summary$Significance <- ifelse(importance_summary$Significance_Rate >= 90,   
                                         "Consistently Significant (p<0.05 in ≥90% of splits)",  
                                         ifelse(importance_summary$Significance_Rate >= 10,  
                                                "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                "Rarely Significant (p<0.05 in <10% of splits)"))  

# Convert to factor with specific order  
importance_summary$Significance <- factor(importance_summary$Significance,   
                                          levels = c("Consistently Significant (p<0.05 in ≥90% of splits)",  
                                                    "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                    "Rarely Significant (p<0.05 in <10% of splits)"))  

# Add percentage value to show in the plot  
importance_summary$label_text <- sprintf("%.1f%% (p=%.3f)",   
                                        importance_summary$Significance_Rate,   
                                        importance_summary$Mean_pvalue)  


importance_plot <- ggplot(importance_summary, aes(x = reorder(Variable, Mean_IncMSE), y = Mean_IncMSE)) +  
  geom_point(aes(size = Significance_Rate, color = Significance), alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower_CI_IncMSE, ymax = Upper_CI_IncMSE,   
                    color = Significance), width = 0.4, linewidth = 1) +  
  geom_text(aes(label = label_text), hjust = -0.2, size = 3, vjust = -0.5) +  
  coord_flip() +  
  scale_color_manual(values = c("Consistently Significant (p<0.05 in ≥90% of splits)" = "#1a9850",  
                               "Sometimes Significant (p<0.05 in 10-89% of splits)" = "#d9ef8b",  
                               "Rarely Significant (p<0.05 in <10% of splits)" = "#fee08b")) +  
  scale_size_continuous(range = c(3, 6)) +  
  labs(x = "Predictor Variable",   
       y = "Mean Percent Increase in Mean Squared Error (%IncMSE)",  
       title = "Variable Importance in Random Forest Model with 95% Confidence Intervals",  
       subtitle = paste("Based on", length(importance_results), "different data splits with permutation tests"),  
       caption = "Error bars show 95% confidence intervals across data splits.\nPercentage values indicate the proportion of data splits where the variable was significant (p<0.05).\nLarger point size indicates higher significance rate across splits.") +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    plot.caption = element_text(hjust = 0, size = 9, color = "darkgrey"),  
    legend.title = element_text(face = "bold", size = 10),  
    legend.position = "bottom",  
    legend.box = "vertical",  
    panel.grid.major.y = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.grid.major.x = element_line(color = "lightgrey", linetype = "dotted"),  
    axis.title = element_text(face = "bold"),  
    axis.text.y = element_text(size = 11)  
  ) +  
  guides(size = "none") +  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")  


# 2. Create a performance metrics visualization using your summary data  
# Convert performance_summary to long format for plotting  
performance_long <- rbind(  
  data.frame(Metric = "RMSE",   
             Value = performance_summary$Mean[performance_summary$Metric == "RMSE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "RMSE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "RMSE"]),  
  data.frame(Metric = "MAE",   
             Value = performance_summary$Mean[performance_summary$Metric == "MAE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "MAE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "MAE"]),  
  data.frame(Metric = "R²",   
             Value = performance_summary$Mean[performance_summary$Metric == "R_squared"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "R_squared"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "R_squared"]),  
  data.frame(Metric = "Pearson r",   
             Value = correlation_summary$Mean[correlation_summary$Metric == "Pearson_r"],  
             Lower = correlation_summary$CI_Lower[correlation_summary$Metric == "Pearson_r"],  
             Upper = correlation_summary$CI_Upper[correlation_summary$Metric == "Pearson_r"]) 
)  

# Add labels  
performance_long$Label <- sprintf("%.3f\n(95%% CI: %.3f-%.3f)",   
                                 performance_long$Value,   
                                 performance_long$Lower,   
                                 performance_long$Upper)  

# Order the metrics in a logical way  
performance_long$Metric <- factor(performance_long$Metric,   
                                 levels = c("R²", "Pearson r", "RMSE", "MAE"))  

# Create bar chart for performance metrics  
performance_plot <- ggplot(performance_long, aes(x = Metric, y = Value, fill = Metric)) +  
  geom_bar(stat = "identity", width = 0.6, alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.3, linewidth = 1, color="grey70") +  
  geom_text(aes(label = Label, y = Upper + (max(Upper) * 0.05)),   
            vjust = 0, size = 3.5) +  
  scale_fill_brewer(palette = "Blues") +  
  labs(title = "Model Performance Metrics",  
       subtitle = "Mean values with 95% confidence intervals across all data splits",  
       y = "Value",  
       x = NULL) +  
  theme_minimal(base_size = 12) +  
  theme(  
    plot.title = element_text(face = "bold", size = 14),  
    plot.subtitle = element_text(size = 11, color = "darkgrey"),  
    legend.position = "none",  
    panel.grid.major.x = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.text.x = element_text(size = 11, face = "bold"),  
    axis.title = element_text(face = "bold")  
  ) +  
  coord_cartesian(ylim = c(0, max(performance_long$Upper) * 1.15))  

# 3. Create a custom annotation plot to explain the metrics  
annotation_text <- data.frame(  
  x = 1,  
  y = 1,  
  label = paste(  
    "Performance Metrics Explained:\n",  
    "• R² (Coefficient of determination): Amount of variance explained by the model (higher is better)\n",  
    "• Pearson r: Linear correlation between predicted and actual values (higher is better)\n",  
    "• Spearman ρ: Rank correlation between predicted and actual values (higher is better)\n",  
    "• RMSE (Root Mean Squared Error): Average magnitude of prediction errors (lower is better)\n",  
    "• MAE (Mean Absolute Error): Average absolute prediction error (lower is better)\n\n",  
    "Model Summary:\n",  
    "• Random Forest with rfPermute (2001 trees, mtry=4)\n",  
    "• 100 permutation tests for variable importance\n",  
    "• Cross-validation with random 70/30 train/test splits\n",  
    "• Response variable: MeHg concentration"  
  )  
)  

annotation_plot <- ggplot(annotation_text, aes(x = x, y = y, label = label)) +  
  geom_text(hjust = 0, vjust = 1, size = 3.5) +  
  theme_void() +  
  coord_cartesian(xlim = c(0, 10), ylim = c(0, 2))  


# 4. Now combine the plots using patchwork  
# Side-by-side importance plot and performance metrics  
combined_plot1 <- importance_plot + performance_plot +   
  plot_layout(widths = c(3, 2)) +  
  plot_annotation(  
    title = "Random Forest Model for MeHg Prediction: Variable Importance and Performance",  
    theme = theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))  
  )  +
  plot_annotation(tag_levels = 'A')

combined_plot1

# Save the importance plot in PDF format with dimensions in centimeters  
ggsave("output/rf_model_comparisons/rf_model_reduced.pdf",   
       plot = combined_plot1,   
       width = 45,   
       height = 20,   
       units = "cm")

```



# Improved Figure asthetis

## Full model
```r
library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(rfPermute)  
library(reshape2)  

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

# remove rows with NA
df <- na.omit(df)  

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

df$water <- as.factor(df$water)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# Number of data split permutations, adjust this number to change the number of permutations, change to 100 in final run
n_splits <- 100

# Create storage for importance metrics across different splits  
importance_results <- list()  
pvalue_results <- list()  
performance_metrics <- list()  
correlation_results <- list()  

# 3. Split Data into Training and Testing Sets  
# Set a seed for reproducibility
# Run models with different random splits  
for (i in 1:n_splits) {  
  # Set a different seed for each data split  
  set.seed(i)  
  
  # Split data  
  train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
  train_data <- df[train_indices, ]  
  test_data <- df[-train_indices, ]  
  
  # Set a seed for rfPermute  
  set.seed(123)  
  
  # Train the rfPermute model  
  rp_model <- rfPermute(  
    MeHg ~ overall_hgcA + 
           overall_SRB_hgcA +
           overall_IRB_hgcA + 
           overall_methanogen_hgcA + 
           overall_methanogen +   
           overall_merB +   
           overall_aerobic_methanotroph + 
           F1Hg +
           DOM + 
           DOM_SUVA254 +
           overall_IRB +
           overall_SRB, 
    data = train_data,  
    ntree = 2001,  
    mtry = 4,  
    importance = TRUE,  
    num.rep = 100  # Reduced to 100 for computational efficiency
  )  
  
  # Store the importance values  
  importance_results[[i]] <- rfPermute::importance(rp_model)
  
  # Store the p-values  
  pvalue_results[[i]] <- rp_model$pval  
  
  # Get predictions on test data  
  predictions <- predict(rp_model, newdata = test_data)  
  
  # Calculate and store performance metrics  
  performance_metrics[[i]] <- data.frame(  
    Split = i,  
    RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
    MAE = mean(abs(test_data$MeHg - predictions)),  
    R_squared = cor(test_data$MeHg, predictions)^2  
  )
  # Store correlation results  
  correlation_results[[i]] <- data.frame(  
    Split = i,  
    Pearson_r = cor(test_data$MeHg, predictions, method = "pearson"),  
    Spearman_rho = cor(test_data$MeHg, predictions, method = "spearman"),  
    R_squared = cor(test_data$MeHg, predictions)^2,  
    R_squared_lm = summary(lm(predictions ~ test_data$MeHg))$r.squared
  )  
} 

# Get variable names (predictors from your model)  
var_names <- c("overall_hgcA", 
               "overall_SRB_hgcA", 
               "overall_IRB_hgcA",   
               "overall_methanogen_hgcA", 
               "overall_methanogen", 
               "overall_merB",   
               "overall_aerobic_methanotroph", 
               "F1Hg",
               "DOM",
               "DOM_SUVA254",
               "overall_IRB",
               "overall_SRB")  

# Create a data frame to store summary statistics  
importance_summary <- data.frame(  
  Variable = var_names,  
  Mean_IncMSE = numeric(length(var_names)),  
  Lower_CI_IncMSE = numeric(length(var_names)),  
  Upper_CI_IncMSE = numeric(length(var_names)),  
  Mean_pvalue = numeric(length(var_names)),  
  Significant_Splits = numeric(length(var_names)),  
  stringsAsFactors = FALSE  
)  

# Process each variable  
for (j in 1:length(var_names)) {  
  v <- var_names[j]  
  
  # Collect %IncMSE values across all splits  
  inc_mse_values <- sapply(importance_results, function(x) x[v, "%IncMSE"])  
  
  # Collect p-values across all splits  
  p_values <- sapply(importance_results, function(x) x[v, "%IncMSE.pval"])  
  
  # Calculate mean and 95% confidence intervals  
  importance_summary$Mean_IncMSE[j] <- mean(inc_mse_values)  
  importance_summary$Lower_CI_IncMSE[j] <- quantile(inc_mse_values, 0.025)  
  importance_summary$Upper_CI_IncMSE[j] <- quantile(inc_mse_values, 0.975)  
  
  # Calculate mean p-value and count of significant splits (p < 0.05)  
  importance_summary$Mean_pvalue[j] <- mean(p_values)  
  importance_summary$Significant_Splits[j] <- sum(p_values < 0.05)  
} 

# Calculate percentage of splits where variable was significant  
importance_summary$Significance_Rate <- (importance_summary$Significant_Splits / length(importance_results)) * 100  

# Sort by mean importance  
importance_summary <- importance_summary[order(importance_summary$Mean_IncMSE, decreasing = TRUE), ]  


importance_summary


# Combine performance metrics  
all_performance <- do.call(rbind, performance_metrics)  
all_correlations <- do.call(rbind, correlation_results)  


# Summarize performance across all splits  
performance_summary <- data.frame(  
  Metric = c("RMSE", "MAE", "R_squared"),  
  Mean = c(  
    mean(all_performance$RMSE),  
    mean(all_performance$MAE),  
    mean(all_performance$R_squared)  
  ),  
  Median = c(  
    median(all_performance$RMSE),  
    median(all_performance$MAE),  
    median(all_performance$R_squared)  
  ),  
  StdDev = c(  
    sd(all_performance$RMSE),  
    sd(all_performance$MAE),  
    sd(all_performance$R_squared)  
  ),  
  Min = c(  
    min(all_performance$RMSE),  
    min(all_performance$MAE),  
    min(all_performance$R_squared)  
  ),  
  Max = c(  
    max(all_performance$RMSE),  
    max(all_performance$MAE),  
    max(all_performance$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_performance$RMSE, 0.025),  
    quantile(all_performance$MAE, 0.025),  
    quantile(all_performance$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_performance$RMSE, 0.975),  
    quantile(all_performance$MAE, 0.975),  
    quantile(all_performance$R_squared, 0.975)  
  )  
)  

# Summarize correlation metrics  
correlation_summary <- data.frame(  
  Metric = c("Pearson_r", "Spearman_rho", "R_squared"),  
  Mean = c(  
    mean(all_correlations$Pearson_r),  
    mean(all_correlations$Spearman_rho),  
    mean(all_correlations$R_squared)  
  ),  
  Median = c(  
    median(all_correlations$Pearson_r),  
    median(all_correlations$Spearman_rho),  
    median(all_correlations$R_squared)  
  ),  
  StdDev = c(  
    sd(all_correlations$Pearson_r),  
    sd(all_correlations$Spearman_rho),  
    sd(all_correlations$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_correlations$Pearson_r, 0.025),  
    quantile(all_correlations$Spearman_rho, 0.025),  
    quantile(all_correlations$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_correlations$Pearson_r, 0.975),  
    quantile(all_correlations$Spearman_rho, 0.975),  
    quantile(all_correlations$R_squared, 0.975)  
  )  
)  


# 1. Variable importance plot with confidence intervals  
# Add significance indicators to the data with correct logic  
importance_summary$Significance <- ifelse(importance_summary$Significance_Rate >= 90,   
                                         "Consistently Significant (p<0.05 in ≥90% of splits)",  
                                         ifelse(importance_summary$Significance_Rate >= 10,  
                                                "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                "Rarely Significant (p<0.05 in <10% of splits)"))  

# Convert to factor with specific order  
importance_summary$Significance <- factor(importance_summary$Significance,   
                                          levels = c("Consistently Significant (p<0.05 in ≥90% of splits)",  
                                                    "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                    "Rarely Significant (p<0.05 in <10% of splits)"))  

# Add percentage value to show in the plot  
importance_summary$label_text <- sprintf("%.1f%% (p=%.3f)",   
                                        importance_summary$Significance_Rate,   
                                        importance_summary$Mean_pvalue)  



# Print performance summaries  
print(performance_summary)  
print(correlation_summary)
print(importance_summary)






# Plotting part
importance_plot <- ggplot(importance_summary, aes(x = reorder(Variable, Mean_IncMSE), y = Mean_IncMSE)) +  
  geom_point(aes(size = Significance_Rate, color = Significance), alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower_CI_IncMSE, ymax = Upper_CI_IncMSE, color = Significance), 
                width = 0.4, linewidth = 1.5) +  
  geom_text(aes(label = label_text), hjust = -0.2, size = 4, vjust = -0.5) +  
  coord_flip() +  
  scale_color_manual(values = c("Consistently Significant (p<0.05 in ≥90% of splits)" = "#06d6a0",  
                                 "Sometimes Significant (p<0.05 in 10-89% of splits)" = "#ffd166",  
                                 "Rarely Significant (p<0.05 in <10% of splits)" = "#ef476f")) +  
  scale_size_continuous(range = c(4, 8)) +  # Increased size range for better visual impact
  labs(x = "Predictor Variable",   
       y = "Mean Percent Increase in Mean Squared Error (%IncMSE)") +  
  theme_minimal(base_size = 14) +  # Increased base font size
  theme(  
    plot.subtitle = element_text(size = 12, color = "darkgrey"),  
    plot.caption = element_text(hjust = 0, size = 11, color = "darkgrey"),  
    legend.title = element_text(face = "bold", size = 13),  
    legend.text = element_text(size = 12),
    legend.position = "bottom",  
    legend.box = "vertical",  
    legend.key.size = unit(1, "cm"),
    panel.grid.major.y = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.grid.major.x = element_line(color = "lightgrey", linetype = "dotted"),  
    axis.title = element_text(face = "bold", size = 14),  
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 12)  
  ) +  
  guides(size = "none") +  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")



# 2. Create a performance metrics visualization using your summary data  
# Convert performance_summary to long format for plotting  
performance_long <- rbind(  
  data.frame(Metric = "RMSE",   
             Value = performance_summary$Mean[performance_summary$Metric == "RMSE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "RMSE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "RMSE"]),  
  data.frame(Metric = "MAE",   
             Value = performance_summary$Mean[performance_summary$Metric == "MAE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "MAE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "MAE"]),  
  data.frame(Metric = "R²",   
             Value = performance_summary$Mean[performance_summary$Metric == "R_squared"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "R_squared"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "R_squared"]),  
  data.frame(Metric = "Pearson r",   
             Value = correlation_summary$Mean[correlation_summary$Metric == "Pearson_r"],  
             Lower = correlation_summary$CI_Lower[correlation_summary$Metric == "Pearson_r"],  
             Upper = correlation_summary$CI_Upper[correlation_summary$Metric == "Pearson_r"]) 
)  

# Add labels  
performance_long$Label <- sprintf("%.3f\n(95%% CI: %.3f-%.3f)",   
                                 performance_long$Value,   
                                 performance_long$Lower,   
                                 performance_long$Upper)  

# Order the metrics in a logical way  
performance_long$Metric <- factor(performance_long$Metric,   
                                 levels = c("R²", "Pearson r", "RMSE", "MAE"))  

performance_plot <- ggplot(performance_long, aes(x = Metric, y = Value, fill = Metric)) +  
  geom_bar(stat = "identity", width = 0.6, alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.3, linewidth = 1.5, color="grey70") +  
  geom_text(aes(label = Label, y = Upper + (max(performance_long$Upper) * 0.05)),   
            vjust = 0, size = 4) +  # Increased label size
  scale_fill_brewer(palette = "Blues") +  
  labs(y = "Value",  
       x = NULL) +  
  theme_minimal(base_size = 14) +  # Increased base font size
  theme(  
    plot.subtitle = element_text(size = 12, color = "darkgrey"),  
    legend.position = "none",  
    panel.grid.major.x = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.text.x = element_text(size = 12, face = "bold"),  
    axis.title = element_text(face = "bold", size = 14)  
  ) +  
  coord_cartesian(ylim = c(0, max(performance_long$Upper) * 1.15))

performance_plot

combined_plot1 <- importance_plot + performance_plot +   
  plot_layout(widths = c(3, 2)) +  
  plot_annotation(  
    theme = theme(plot.title = element_blank(),  # Remove the title
                  plot.subtitle = element_text(size = 16, face = "bold", hjust = 0.5))  
  ) +
  plot_annotation(tag_levels = 'A')

combined_plot1


ggsave("output/rf_model_comparisons/20250725_rf_model_full_200.pdf",   
       plot = combined_plot1,   
       width = 45,   
       height = 20,   
       units = "cm")

```

## Reduced model - top 5 variables
```r

library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(reshape2)
library(rfPermute)  # Load this last

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

# remove rows with NA
df <- na.omit(df)  

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

df$water <- as.factor(df$water)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# Number of data split permutations, adjust this number to change the number of permutations, change to 100 in final run
n_splits <- 100

# Create storage for importance metrics across different splits  
importance_results <- list()  
pvalue_results <- list()  
performance_metrics <- list()  
correlation_results <- list()  

# 3. Split Data into Training and Testing Sets  
# Set a seed for reproducibility
# Run models with different random splits  
for (i in 1:n_splits) {  
  # Set a different seed for each data split  
  set.seed(i)  
  
  # Split data  
  train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
  train_data <- df[train_indices, ]  
  test_data <- df[-train_indices, ]  
  
  # Set a seed for rfPermute  
  set.seed(123)  
  
  # Train the rfPermute model  
  rp_model <- rfPermute(  
    MeHg ~ 
           overall_methanogen_hgcA + 
           overall_methanogen +   
           overall_aerobic_methanotroph + 
           F1Hg +
           DOM_SUVA254,
    data = train_data,  
    ntree = 2001,  
    mtry = 4,  
    importance = TRUE,  
    num.rep = 100  # Reduced to 100 for computational efficiency
  )  
  
  # Store the importance values  
  importance_results[[i]] <- rfPermute::importance(rp_model)
  
  # Store the p-values  
  pvalue_results[[i]] <- rp_model$pval  
  
  # Get predictions on test data  
  predictions <- predict(rp_model, newdata = test_data)  
  
  # Calculate and store performance metrics  
  performance_metrics[[i]] <- data.frame(  
    Split = i,  
    RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
    MAE = mean(abs(test_data$MeHg - predictions)),  
    R_squared = cor(test_data$MeHg, predictions)^2  
  )
  # Store correlation results  
  correlation_results[[i]] <- data.frame(  
    Split = i,  
    Pearson_r = cor(test_data$MeHg, predictions, method = "pearson"),  
    Spearman_rho = cor(test_data$MeHg, predictions, method = "spearman"),  
    R_squared = cor(test_data$MeHg, predictions)^2,  
    R_squared_lm = summary(lm(predictions ~ test_data$MeHg))$r.squared
  )  
} 

# Get variable names (predictors from your model)  
var_names <- c( 
               "overall_methanogen_hgcA", 
               "overall_methanogen", 
               "overall_aerobic_methanotroph", 
               "F1Hg",
               "DOM_SUVA254")  

# Create a data frame to store summary statistics  
importance_summary <- data.frame(  
  Variable = var_names,  
  Mean_IncMSE = numeric(length(var_names)),  
  Lower_CI_IncMSE = numeric(length(var_names)),  
  Upper_CI_IncMSE = numeric(length(var_names)),  
  Mean_pvalue = numeric(length(var_names)),  
  Significant_Splits = numeric(length(var_names)),  
  stringsAsFactors = FALSE  
)  

# Process each variable  
for (j in 1:length(var_names)) {  
  v <- var_names[j]  
  
  # Collect %IncMSE values across all splits  
  inc_mse_values <- sapply(importance_results, function(x) x[v, "%IncMSE"])  
  
  # Collect p-values across all splits  
  p_values <- sapply(importance_results, function(x) x[v, "%IncMSE.pval"])  
  
  # Calculate mean and 95% confidence intervals  
  importance_summary$Mean_IncMSE[j] <- mean(inc_mse_values)  
  importance_summary$Lower_CI_IncMSE[j] <- quantile(inc_mse_values, 0.025)  
  importance_summary$Upper_CI_IncMSE[j] <- quantile(inc_mse_values, 0.975)  
  
  # Calculate mean p-value and count of significant splits (p < 0.05)  
  importance_summary$Mean_pvalue[j] <- mean(p_values)  
  importance_summary$Significant_Splits[j] <- sum(p_values < 0.05)  
} 

# Calculate percentage of splits where variable was significant  
importance_summary$Significance_Rate <- (importance_summary$Significant_Splits / length(importance_results)) * 100  

# Sort by mean importance  
importance_summary <- importance_summary[order(importance_summary$Mean_IncMSE, decreasing = TRUE), ]  

# Combine performance metrics  
all_performance <- do.call(rbind, performance_metrics)  
all_correlations <- do.call(rbind, correlation_results)  


# Summarize performance across all splits  
performance_summary <- data.frame(  
  Metric = c("RMSE", "MAE", "R_squared"),  
  Mean = c(  
    mean(all_performance$RMSE),  
    mean(all_performance$MAE),  
    mean(all_performance$R_squared)  
  ),  
  Median = c(  
    median(all_performance$RMSE),  
    median(all_performance$MAE),  
    median(all_performance$R_squared)  
  ),  
  StdDev = c(  
    sd(all_performance$RMSE),  
    sd(all_performance$MAE),  
    sd(all_performance$R_squared)  
  ),  
  Min = c(  
    min(all_performance$RMSE),  
    min(all_performance$MAE),  
    min(all_performance$R_squared)  
  ),  
  Max = c(  
    max(all_performance$RMSE),  
    max(all_performance$MAE),  
    max(all_performance$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_performance$RMSE, 0.025),  
    quantile(all_performance$MAE, 0.025),  
    quantile(all_performance$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_performance$RMSE, 0.975),  
    quantile(all_performance$MAE, 0.975),  
    quantile(all_performance$R_squared, 0.975)  
  )  
)  

# Summarize correlation metrics  
correlation_summary <- data.frame(  
  Metric = c("Pearson_r", "Spearman_rho", "R_squared"),  
  Mean = c(  
    mean(all_correlations$Pearson_r),  
    mean(all_correlations$Spearman_rho),  
    mean(all_correlations$R_squared)  
  ),  
  Median = c(  
    median(all_correlations$Pearson_r),  
    median(all_correlations$Spearman_rho),  
    median(all_correlations$R_squared)  
  ),  
  StdDev = c(  
    sd(all_correlations$Pearson_r),  
    sd(all_correlations$Spearman_rho),  
    sd(all_correlations$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_correlations$Pearson_r, 0.025),  
    quantile(all_correlations$Spearman_rho, 0.025),  
    quantile(all_correlations$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_correlations$Pearson_r, 0.975),  
    quantile(all_correlations$Spearman_rho, 0.975),  
    quantile(all_correlations$R_squared, 0.975)  
  )  
)  


# Print performance summaries  
cat("\nPerformance Metrics Summary:\n")  
print(performance_summary)  

cat("\nCorrelation Metrics Summary:\n")  
print(correlation_summary)



# 1. Variable importance plot with confidence intervals  
# Add significance indicators to the data with correct logic  
importance_summary$Significance <- ifelse(importance_summary$Significance_Rate >= 90,   
                                         "Consistently Significant (p<0.05 in ≥90% of splits)",  
                                         ifelse(importance_summary$Significance_Rate >= 10,  
                                                "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                "Rarely Significant (p<0.05 in <10% of splits)"))  

# Convert to factor with specific order  
importance_summary$Significance <- factor(importance_summary$Significance,   
                                          levels = c("Consistently Significant (p<0.05 in ≥90% of splits)",  
                                                    "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                    "Rarely Significant (p<0.05 in <10% of splits)"))  

# Add percentage value to show in the plot  
importance_summary$label_text <- sprintf("%.1f%% (p=%.3f)",   
                                        importance_summary$Significance_Rate,   
                                        importance_summary$Mean_pvalue)  

importance_summary

# Plotting part
importance_plot <- ggplot(importance_summary, aes(x = reorder(Variable, Mean_IncMSE), y = Mean_IncMSE)) +  
  geom_point(aes(size = Significance_Rate, color = Significance), alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower_CI_IncMSE, ymax = Upper_CI_IncMSE, color = Significance), 
                width = 0.4, linewidth = 1.5) +  
  geom_text(aes(label = label_text), hjust = -0.2, size = 4, vjust = -0.5) +  
  coord_flip() +  
  scale_color_manual(values = c("Consistently Significant (p<0.05 in ≥90% of splits)" = "#06d6a0",  
                                 "Sometimes Significant (p<0.05 in 10-89% of splits)" = "#ffd166",  
                                 "Rarely Significant (p<0.05 in <10% of splits)" = "#ef476f")) +  
  scale_size_continuous(range = c(4, 8)) +  # Increased size range for better visual impact
  labs(x = "Predictor Variable",   
       y = "Mean Percent Increase in Mean Squared Error (%IncMSE)") +  
  theme_minimal(base_size = 14) +  # Increased base font size
  theme(  
    plot.subtitle = element_text(size = 12, color = "darkgrey"),  
    plot.caption = element_text(hjust = 0, size = 11, color = "darkgrey"),  
    legend.title = element_text(face = "bold", size = 13),  
    legend.text = element_text(size = 12),
    legend.position = "bottom",  
    legend.box = "vertical",  
    legend.key.size = unit(1, "cm"),
    panel.grid.major.y = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.grid.major.x = element_line(color = "lightgrey", linetype = "dotted"),  
    axis.title = element_text(face = "bold", size = 14),  
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 12)  
  ) +  
  guides(size = "none") +  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")



# 2. Create a performance metrics visualization using your summary data  
# Convert performance_summary to long format for plotting  
performance_long <- rbind(  
  data.frame(Metric = "RMSE",   
             Value = performance_summary$Mean[performance_summary$Metric == "RMSE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "RMSE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "RMSE"]),  
  data.frame(Metric = "MAE",   
             Value = performance_summary$Mean[performance_summary$Metric == "MAE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "MAE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "MAE"]),  
  data.frame(Metric = "R²",   
             Value = performance_summary$Mean[performance_summary$Metric == "R_squared"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "R_squared"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "R_squared"]),  
  data.frame(Metric = "Pearson r",   
             Value = correlation_summary$Mean[correlation_summary$Metric == "Pearson_r"],  
             Lower = correlation_summary$CI_Lower[correlation_summary$Metric == "Pearson_r"],  
             Upper = correlation_summary$CI_Upper[correlation_summary$Metric == "Pearson_r"]) 
)  

# Add labels  
performance_long$Label <- sprintf("%.3f\n(95%% CI: %.3f-%.3f)",   
                                 performance_long$Value,   
                                 performance_long$Lower,   
                                 performance_long$Upper)  

# Order the metrics in a logical way  
performance_long$Metric <- factor(performance_long$Metric,   
                                 levels = c("R²", "Pearson r", "RMSE", "MAE"))  

performance_plot <- ggplot(performance_long, aes(x = Metric, y = Value, fill = Metric)) +  
  geom_bar(stat = "identity", width = 0.6, alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.3, linewidth = 1.5, color="grey70") +  
  geom_text(aes(label = Label, y = Upper + (max(performance_long$Upper) * 0.05)),   
            vjust = 0, size = 4) +  # Increased label size
  scale_fill_brewer(palette = "Blues") +  
  labs(y = "Value",  
       x = NULL) +  
  theme_minimal(base_size = 14) +  # Increased base font size
  theme(  
    plot.subtitle = element_text(size = 12, color = "darkgrey"),  
    legend.position = "none",  
    panel.grid.major.x = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.text.x = element_text(size = 12, face = "bold"),  
    axis.title = element_text(face = "bold", size = 14)  
  ) +  
  coord_cartesian(ylim = c(0, max(performance_long$Upper) * 1.15))

performance_plot

combined_plot1 <- importance_plot + performance_plot +   
  plot_layout(widths = c(3, 2)) +  
  plot_annotation(  
    theme = theme(plot.title = element_blank(),  # Remove the title
                  plot.subtitle = element_text(size = 16, face = "bold", hjust = 0.5))  
  ) +
  plot_annotation(tag_levels = 'A')

combined_plot1


ggsave("output/rf_model_comparisons/20250804_rf_model_reduced_100.pdf",   
       plot = combined_plot1,   
       width = 45,   
       height = 20,   
       units = "cm")

```

## Reduced model - top 5 variables - with interaction
```r

library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(reshape2)
library(rfPermute)  # Load this last

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

# remove rows with NA
df <- na.omit(df)  

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  

df$water <- as.factor(df$water)  

# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# Number of data split permutations, adjust this number to change the number of permutations, change to 100 in final run
n_splits <- 10

# Create storage for importance metrics across different splits  
importance_results <- list()  
pvalue_results <- list()  
performance_metrics <- list()  
correlation_results <- list()  

# create intearction term
df$methanogen_x_methanotroph <- df$overall_methanogen * df$overall_aerobic_methanotroph

# 3. Split Data into Training and Testing Sets  
# Set a seed for reproducibility
# Run models with different random splits  
for (i in 1:n_splits) {  
  # Set a different seed for each data split  
  set.seed(i)  
  
  # Split data  
  train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
  train_data <- df[train_indices, ]  
  test_data <- df[-train_indices, ]  
  
  # Set a seed for rfPermute  
  set.seed(123)  
  
  # Train the rfPermute model  
  rp_model <- rfPermute(  
    MeHg ~ 
           overall_methanogen_hgcA + 
           overall_methanogen +   
           overall_aerobic_methanotroph + 
           methanogen_x_methanotroph + 
           F1Hg +
           DOM_SUVA254,
    data = train_data,  
    ntree = 2001,  
    mtry = 4,  
    importance = TRUE,  
    num.rep = 100  # Reduced to 100 for computational efficiency
  )  
  
  # Store the importance values  
  importance_results[[i]] <- rfPermute::importance(rp_model)
  
  # Store the p-values  
  pvalue_results[[i]] <- rp_model$pval  
  
  # Get predictions on test data  
  predictions <- predict(rp_model, newdata = test_data)  
  
  # Calculate and store performance metrics  
  performance_metrics[[i]] <- data.frame(  
    Split = i,  
    RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
    MAE = mean(abs(test_data$MeHg - predictions)),  
    R_squared = cor(test_data$MeHg, predictions)^2  
  )
  # Store correlation results  
  correlation_results[[i]] <- data.frame(  
    Split = i,  
    Pearson_r = cor(test_data$MeHg, predictions, method = "pearson"),  
    Spearman_rho = cor(test_data$MeHg, predictions, method = "spearman"),  
    R_squared = cor(test_data$MeHg, predictions)^2,  
    R_squared_lm = summary(lm(predictions ~ test_data$MeHg))$r.squared
  )  
} 

# Get variable names (predictors from your model)  
var_names <- c( 
               "overall_methanogen_hgcA", 
               "overall_methanogen", 
               "overall_aerobic_methanotroph", 
               "methanogen_x_methanotroph",
               "F1Hg",
               "DOM_SUVA254")  

# Create a data frame to store summary statistics  
importance_summary <- data.frame(  
  Variable = var_names,  
  Mean_IncMSE = numeric(length(var_names)),  
  Lower_CI_IncMSE = numeric(length(var_names)),  
  Upper_CI_IncMSE = numeric(length(var_names)),  
  Mean_pvalue = numeric(length(var_names)),  
  Significant_Splits = numeric(length(var_names)),  
  stringsAsFactors = FALSE  
)  

# Process each variable  
for (j in 1:length(var_names)) {  
  v <- var_names[j]  
  
  # Collect %IncMSE values across all splits  
  inc_mse_values <- sapply(importance_results, function(x) x[v, "%IncMSE"])  
  
  # Collect p-values across all splits  
  p_values <- sapply(importance_results, function(x) x[v, "%IncMSE.pval"])  
  
  # Calculate mean and 95% confidence intervals  
  importance_summary$Mean_IncMSE[j] <- mean(inc_mse_values)  
  importance_summary$Lower_CI_IncMSE[j] <- quantile(inc_mse_values, 0.025)  
  importance_summary$Upper_CI_IncMSE[j] <- quantile(inc_mse_values, 0.975)  
  
  # Calculate mean p-value and count of significant splits (p < 0.05)  
  importance_summary$Mean_pvalue[j] <- mean(p_values)  
  importance_summary$Significant_Splits[j] <- sum(p_values < 0.05)  
} 


# Calculate percentage of splits where variable was significant  
importance_summary$Significance_Rate <- (importance_summary$Significant_Splits / length(importance_results)) * 100  

# Sort by mean importance  
importance_summary <- importance_summary[order(importance_summary$Mean_IncMSE, decreasing = TRUE), ]  

# Combine performance metrics  
all_performance <- do.call(rbind, performance_metrics)  
all_correlations <- do.call(rbind, correlation_results)  


# Summarize performance across all splits  
performance_summary <- data.frame(  
  Metric = c("RMSE", "MAE", "R_squared"),  
  Mean = c(  
    mean(all_performance$RMSE),  
    mean(all_performance$MAE),  
    mean(all_performance$R_squared)  
  ),  
  Median = c(  
    median(all_performance$RMSE),  
    median(all_performance$MAE),  
    median(all_performance$R_squared)  
  ),  
  StdDev = c(  
    sd(all_performance$RMSE),  
    sd(all_performance$MAE),  
    sd(all_performance$R_squared)  
  ),  
  Min = c(  
    min(all_performance$RMSE),  
    min(all_performance$MAE),  
    min(all_performance$R_squared)  
  ),  
  Max = c(  
    max(all_performance$RMSE),  
    max(all_performance$MAE),  
    max(all_performance$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_performance$RMSE, 0.025),  
    quantile(all_performance$MAE, 0.025),  
    quantile(all_performance$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_performance$RMSE, 0.975),  
    quantile(all_performance$MAE, 0.975),  
    quantile(all_performance$R_squared, 0.975)  
  )  
)  

# Summarize correlation metrics  
correlation_summary <- data.frame(  
  Metric = c("Pearson_r", "Spearman_rho", "R_squared"),  
  Mean = c(  
    mean(all_correlations$Pearson_r),  
    mean(all_correlations$Spearman_rho),  
    mean(all_correlations$R_squared)  
  ),  
  Median = c(  
    median(all_correlations$Pearson_r),  
    median(all_correlations$Spearman_rho),  
    median(all_correlations$R_squared)  
  ),  
  StdDev = c(  
    sd(all_correlations$Pearson_r),  
    sd(all_correlations$Spearman_rho),  
    sd(all_correlations$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_correlations$Pearson_r, 0.025),  
    quantile(all_correlations$Spearman_rho, 0.025),  
    quantile(all_correlations$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_correlations$Pearson_r, 0.975),  
    quantile(all_correlations$Spearman_rho, 0.975),  
    quantile(all_correlations$R_squared, 0.975)  
  )  
)  


# Print performance summaries  
cat("\nPerformance Metrics Summary:\n")  
print(performance_summary)  

cat("\nCorrelation Metrics Summary:\n")  
print(correlation_summary)



# 1. Variable importance plot with confidence intervals  
# Add significance indicators to the data with correct logic  
importance_summary$Significance <- ifelse(importance_summary$Significance_Rate >= 90,   
                                         "Consistently Significant (p<0.05 in ≥90% of splits)",  
                                         ifelse(importance_summary$Significance_Rate >= 10,  
                                                "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                "Rarely Significant (p<0.05 in <10% of splits)"))  

# Convert to factor with specific order  
importance_summary$Significance <- factor(importance_summary$Significance,   
                                          levels = c("Consistently Significant (p<0.05 in ≥90% of splits)",  
                                                    "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                    "Rarely Significant (p<0.05 in <10% of splits)"))  

# Add percentage value to show in the plot  
importance_summary$label_text <- sprintf("%.1f%% (p=%.3f)",   
                                        importance_summary$Significance_Rate,   
                                        importance_summary$Mean_pvalue)  

importance_summary

# Plotting part
importance_plot <- ggplot(importance_summary, aes(x = reorder(Variable, Mean_IncMSE), y = Mean_IncMSE)) +  
  geom_point(aes(size = Significance_Rate, color = Significance), alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower_CI_IncMSE, ymax = Upper_CI_IncMSE, color = Significance), 
                width = 0.4, linewidth = 1.5) +  
  geom_text(aes(label = label_text), hjust = -0.2, size = 4, vjust = -0.5) +  
  coord_flip() +  
  scale_color_manual(values = c("Consistently Significant (p<0.05 in ≥90% of splits)" = "#06d6a0",  
                                 "Sometimes Significant (p<0.05 in 10-89% of splits)" = "#ffd166",  
                                 "Rarely Significant (p<0.05 in <10% of splits)" = "#ef476f")) +  
  scale_size_continuous(range = c(4, 8)) +  # Increased size range for better visual impact
  labs(x = "Predictor Variable",   
       y = "Mean Percent Increase in Mean Squared Error (%IncMSE)") +  
  theme_minimal(base_size = 14) +  # Increased base font size
  theme(  
    plot.subtitle = element_text(size = 12, color = "darkgrey"),  
    plot.caption = element_text(hjust = 0, size = 11, color = "darkgrey"),  
    legend.title = element_text(face = "bold", size = 13),  
    legend.text = element_text(size = 12),
    legend.position = "bottom",  
    legend.box = "vertical",  
    legend.key.size = unit(1, "cm"),
    panel.grid.major.y = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.grid.major.x = element_line(color = "lightgrey", linetype = "dotted"),  
    axis.title = element_text(face = "bold", size = 14),  
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 12)  
  ) +  
  guides(size = "none") +  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")


# 2. Create a performance metrics visualization using your summary data  
# Convert performance_summary to long format for plotting  
performance_long <- rbind(  
  data.frame(Metric = "RMSE",   
             Value = performance_summary$Mean[performance_summary$Metric == "RMSE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "RMSE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "RMSE"]),  
  data.frame(Metric = "MAE",   
             Value = performance_summary$Mean[performance_summary$Metric == "MAE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "MAE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "MAE"]),  
  data.frame(Metric = "R²",   
             Value = performance_summary$Mean[performance_summary$Metric == "R_squared"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "R_squared"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "R_squared"]),  
  data.frame(Metric = "Pearson r",   
             Value = correlation_summary$Mean[correlation_summary$Metric == "Pearson_r"],  
             Lower = correlation_summary$CI_Lower[correlation_summary$Metric == "Pearson_r"],  
             Upper = correlation_summary$CI_Upper[correlation_summary$Metric == "Pearson_r"]) 
)  

# Add labels  
performance_long$Label <- sprintf("%.3f\n(95%% CI: %.3f-%.3f)",   
                                 performance_long$Value,   
                                 performance_long$Lower,   
                                 performance_long$Upper)  

# Order the metrics in a logical way  
performance_long$Metric <- factor(performance_long$Metric,   
                                 levels = c("R²", "Pearson r", "RMSE", "MAE"))  

performance_plot <- ggplot(performance_long, aes(x = Metric, y = Value, fill = Metric)) +  
  geom_bar(stat = "identity", width = 0.6, alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.3, linewidth = 1.5, color="grey70") +  
  geom_text(aes(label = Label, y = Upper + (max(performance_long$Upper) * 0.05)),   
            vjust = 0, size = 4) +  # Increased label size
  scale_fill_brewer(palette = "Blues") +  
  labs(y = "Value",  
       x = NULL) +  
  theme_minimal(base_size = 14) +  # Increased base font size
  theme(  
    plot.subtitle = element_text(size = 12, color = "darkgrey"),  
    legend.position = "none",  
    panel.grid.major.x = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.text.x = element_text(size = 12, face = "bold"),  
    axis.title = element_text(face = "bold", size = 14)  
  ) +  
  coord_cartesian(ylim = c(0, max(performance_long$Upper) * 1.15))

performance_plot

combined_plot1 <- importance_plot + performance_plot +   
  plot_layout(widths = c(3, 2)) +  
  plot_annotation(  
    theme = theme(plot.title = element_blank(),  # Remove the title
                  plot.subtitle = element_text(size = 16, face = "bold", hjust = 0.5))  
  ) +
  plot_annotation(tag_levels = 'A')

combined_plot1


ggsave("output/rf_model_comparisons/20250804_rf_model_reduced_interaction_100.pdf",   
       plot = combined_plot1,   
       width = 45,   
       height = 20,   
       units = "cm")

```



## Full model - flooded period
```r
library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(rfPermute)  
library(reshape2)  

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

# remove rows with NA
df <- na.omit(df)  

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  
df$water <- as.factor(df$water)  

df <- df[df$water == "Flooded", ]


# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# Number of data split permutations, adjust this number to change the number of permutations, change to 100 in final run
n_splits <- 100

# Create storage for importance metrics across different splits  
importance_results <- list()  
pvalue_results <- list()  
performance_metrics <- list()  
correlation_results <- list()  

# 3. Split Data into Training and Testing Sets  
# Set a seed for reproducibility
# Run models with different random splits  
for (i in 1:n_splits) {  
  # Set a different seed for each data split  
  set.seed(i)  
  
  # Split data  
  train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
  train_data <- df[train_indices, ]  
  test_data <- df[-train_indices, ]  
  
  # Set a seed for rfPermute  
  set.seed(123)  
  
  # Train the rfPermute model  
  rp_model <- rfPermute(  
    MeHg ~ overall_hgcA + 
           overall_SRB_hgcA +
           overall_IRB_hgcA + 
           overall_methanogen_hgcA + 
           overall_methanogen +   
           overall_merB +   
           overall_aerobic_methanotroph + 
           F1Hg +
           DOM + 
           DOM_SUVA254 +
           overall_IRB +
           overall_SRB, 
    data = train_data,  
    ntree = 2001,  
    mtry = 4,  
    importance = TRUE,  
    num.rep = 100  # Reduced to 100 for computational efficiency
  )  
  
  # Store the importance values  
  importance_results[[i]] <- rfPermute::importance(rp_model)
  
  # Store the p-values  
  pvalue_results[[i]] <- rp_model$pval  
  
  # Get predictions on test data  
  predictions <- predict(rp_model, newdata = test_data)  
  
  # Calculate and store performance metrics  
  performance_metrics[[i]] <- data.frame(  
    Split = i,  
    RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
    MAE = mean(abs(test_data$MeHg - predictions)),  
    R_squared = cor(test_data$MeHg, predictions)^2  
  )
  # Store correlation results  
  correlation_results[[i]] <- data.frame(  
    Split = i,  
    Pearson_r = cor(test_data$MeHg, predictions, method = "pearson"),  
    Spearman_rho = cor(test_data$MeHg, predictions, method = "spearman"),  
    R_squared = cor(test_data$MeHg, predictions)^2,  
    R_squared_lm = summary(lm(predictions ~ test_data$MeHg))$r.squared
  )  
} 

# Get variable names (predictors from your model)  
var_names <- c("overall_hgcA", 
               "overall_SRB_hgcA", 
               "overall_IRB_hgcA",   
               "overall_methanogen_hgcA", 
               "overall_methanogen", 
               "overall_merB",   
               "overall_aerobic_methanotroph", 
               "F1Hg",
               "DOM",
               "DOM_SUVA254",
               "overall_IRB",
               "overall_SRB")  

# Create a data frame to store summary statistics  
importance_summary <- data.frame(  
  Variable = var_names,  
  Mean_IncMSE = numeric(length(var_names)),  
  Lower_CI_IncMSE = numeric(length(var_names)),  
  Upper_CI_IncMSE = numeric(length(var_names)),  
  Mean_pvalue = numeric(length(var_names)),  
  Significant_Splits = numeric(length(var_names)),  
  stringsAsFactors = FALSE  
)  

# Process each variable  
for (j in 1:length(var_names)) {  
  v <- var_names[j]  
  
  # Collect %IncMSE values across all splits  
  inc_mse_values <- sapply(importance_results, function(x) x[v, "%IncMSE"])  
  
  # Collect p-values across all splits  
  p_values <- sapply(importance_results, function(x) x[v, "%IncMSE.pval"])  
  
  # Calculate mean and 95% confidence intervals  
  importance_summary$Mean_IncMSE[j] <- mean(inc_mse_values)  
  importance_summary$Lower_CI_IncMSE[j] <- quantile(inc_mse_values, 0.025)  
  importance_summary$Upper_CI_IncMSE[j] <- quantile(inc_mse_values, 0.975)  
  
  # Calculate mean p-value and count of significant splits (p < 0.05)  
  importance_summary$Mean_pvalue[j] <- mean(p_values)  
  importance_summary$Significant_Splits[j] <- sum(p_values < 0.05)  
} 

# Calculate percentage of splits where variable was significant  
importance_summary$Significance_Rate <- (importance_summary$Significant_Splits / length(importance_results)) * 100  

# Sort by mean importance  
importance_summary <- importance_summary[order(importance_summary$Mean_IncMSE, decreasing = TRUE), ]  


importance_summary


# Combine performance metrics  
all_performance <- do.call(rbind, performance_metrics)  
all_correlations <- do.call(rbind, correlation_results)  


# Summarize performance across all splits  
performance_summary <- data.frame(  
  Metric = c("RMSE", "MAE", "R_squared"),  
  Mean = c(  
    mean(all_performance$RMSE),  
    mean(all_performance$MAE),  
    mean(all_performance$R_squared)  
  ),  
  Median = c(  
    median(all_performance$RMSE),  
    median(all_performance$MAE),  
    median(all_performance$R_squared)  
  ),  
  StdDev = c(  
    sd(all_performance$RMSE),  
    sd(all_performance$MAE),  
    sd(all_performance$R_squared)  
  ),  
  Min = c(  
    min(all_performance$RMSE),  
    min(all_performance$MAE),  
    min(all_performance$R_squared)  
  ),  
  Max = c(  
    max(all_performance$RMSE),  
    max(all_performance$MAE),  
    max(all_performance$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_performance$RMSE, 0.025),  
    quantile(all_performance$MAE, 0.025),  
    quantile(all_performance$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_performance$RMSE, 0.975),  
    quantile(all_performance$MAE, 0.975),  
    quantile(all_performance$R_squared, 0.975)  
  )  
)  

# Summarize correlation metrics  
correlation_summary <- data.frame(  
  Metric = c("Pearson_r", "Spearman_rho", "R_squared"),  
  Mean = c(  
    mean(all_correlations$Pearson_r),  
    mean(all_correlations$Spearman_rho),  
    mean(all_correlations$R_squared)  
  ),  
  Median = c(  
    median(all_correlations$Pearson_r),  
    median(all_correlations$Spearman_rho),  
    median(all_correlations$R_squared)  
  ),  
  StdDev = c(  
    sd(all_correlations$Pearson_r),  
    sd(all_correlations$Spearman_rho),  
    sd(all_correlations$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_correlations$Pearson_r, 0.025),  
    quantile(all_correlations$Spearman_rho, 0.025),  
    quantile(all_correlations$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_correlations$Pearson_r, 0.975),  
    quantile(all_correlations$Spearman_rho, 0.975),  
    quantile(all_correlations$R_squared, 0.975)  
  )  
)  


# 1. Variable importance plot with confidence intervals  
# Add significance indicators to the data with correct logic  
importance_summary$Significance <- ifelse(importance_summary$Significance_Rate >= 90,   
                                         "Consistently Significant (p<0.05 in ≥90% of splits)",  
                                         ifelse(importance_summary$Significance_Rate >= 10,  
                                                "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                "Rarely Significant (p<0.05 in <10% of splits)"))  

# Convert to factor with specific order  
importance_summary$Significance <- factor(importance_summary$Significance,   
                                          levels = c("Consistently Significant (p<0.05 in ≥90% of splits)",  
                                                    "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                    "Rarely Significant (p<0.05 in <10% of splits)"))  

# Add percentage value to show in the plot  
importance_summary$label_text <- sprintf("%.1f%% (p=%.3f)",   
                                        importance_summary$Significance_Rate,   
                                        importance_summary$Mean_pvalue)  



# Print performance summaries  
print(performance_summary)  
print(correlation_summary)
print(importance_summary)






# Plotting part
importance_plot <- ggplot(importance_summary, aes(x = reorder(Variable, Mean_IncMSE), y = Mean_IncMSE)) +  
  geom_point(aes(size = Significance_Rate, color = Significance), alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower_CI_IncMSE, ymax = Upper_CI_IncMSE, color = Significance), 
                width = 0.4, linewidth = 1.5) +  
  geom_text(aes(label = label_text), hjust = -0.2, size = 4, vjust = -0.5) +  
  coord_flip() +  
  scale_color_manual(values = c("Consistently Significant (p<0.05 in ≥90% of splits)" = "#06d6a0",  
                                 "Sometimes Significant (p<0.05 in 10-89% of splits)" = "#ffd166",  
                                 "Rarely Significant (p<0.05 in <10% of splits)" = "#ef476f")) +  
  scale_size_continuous(range = c(4, 8)) +  # Increased size range for better visual impact
  labs(x = "Predictor Variable",   
       y = "Mean Percent Increase in Mean Squared Error (%IncMSE)") +  
  theme_minimal(base_size = 14) +  # Increased base font size
  theme(  
    plot.subtitle = element_text(size = 12, color = "darkgrey"),  
    plot.caption = element_text(hjust = 0, size = 11, color = "darkgrey"),  
    legend.title = element_text(face = "bold", size = 13),  
    legend.text = element_text(size = 12),
    legend.position = "bottom",  
    legend.box = "vertical",  
    legend.key.size = unit(1, "cm"),
    panel.grid.major.y = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.grid.major.x = element_line(color = "lightgrey", linetype = "dotted"),  
    axis.title = element_text(face = "bold", size = 14),  
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 12)  
  ) +  
  guides(size = "none") +  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")



# 2. Create a performance metrics visualization using your summary data  
# Convert performance_summary to long format for plotting  
performance_long <- rbind(  
  data.frame(Metric = "RMSE",   
             Value = performance_summary$Mean[performance_summary$Metric == "RMSE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "RMSE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "RMSE"]),  
  data.frame(Metric = "MAE",   
             Value = performance_summary$Mean[performance_summary$Metric == "MAE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "MAE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "MAE"]),  
  data.frame(Metric = "R²",   
             Value = performance_summary$Mean[performance_summary$Metric == "R_squared"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "R_squared"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "R_squared"]),  
  data.frame(Metric = "Pearson r",   
             Value = correlation_summary$Mean[correlation_summary$Metric == "Pearson_r"],  
             Lower = correlation_summary$CI_Lower[correlation_summary$Metric == "Pearson_r"],  
             Upper = correlation_summary$CI_Upper[correlation_summary$Metric == "Pearson_r"]) 
)  

# Add labels  
performance_long$Label <- sprintf("%.3f\n(95%% CI: %.3f-%.3f)",   
                                 performance_long$Value,   
                                 performance_long$Lower,   
                                 performance_long$Upper)  

# Order the metrics in a logical way  
performance_long$Metric <- factor(performance_long$Metric,   
                                 levels = c("R²", "Pearson r", "RMSE", "MAE"))  

performance_plot <- ggplot(performance_long, aes(x = Metric, y = Value, fill = Metric)) +  
  geom_bar(stat = "identity", width = 0.6, alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.3, linewidth = 1.5, color="grey70") +  
  geom_text(aes(label = Label, y = Upper + (max(performance_long$Upper) * 0.05)),   
            vjust = 0, size = 4) +  # Increased label size
  scale_fill_brewer(palette = "Blues") +  
  labs(y = "Value",  
       x = NULL) +  
  theme_minimal(base_size = 14) +  # Increased base font size
  theme(  
    plot.subtitle = element_text(size = 12, color = "darkgrey"),  
    legend.position = "none",  
    panel.grid.major.x = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.text.x = element_text(size = 12, face = "bold"),  
    axis.title = element_text(face = "bold", size = 14)  
  ) +  
  coord_cartesian(ylim = c(0, max(performance_long$Upper) * 1.15))

performance_plot

combined_plot1 <- importance_plot + performance_plot +   
  plot_layout(widths = c(3, 2)) +  
  plot_annotation(  
    theme = theme(plot.title = element_blank(),  # Remove the title
                  plot.subtitle = element_text(size = 16, face = "bold", hjust = 0.5))  
  ) +
  plot_annotation(tag_levels = 'A')

combined_plot1


ggsave("output/rf_model_comparisons/20250804_rf_model_full_flooded_100.pdf",   
       plot = combined_plot1,   
       width = 45,   
       height = 20,   
       units = "cm")

```

## Reduced model - top 5 variables - flooded period
```r

library(randomForest)  
library(caret)  
library(tidyverse)  
library(ggplot2)  
library(moments)  
library(MLmetrics)
library(boot)
library(reshape2)
library(rfPermute)  # Load this last

# 1. import data
df <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

# remove rows with NA
df <- na.omit(df)  

# 2 Convert Site to a Factor (Important for Random Forest)  
df$site <- as.factor(df$site)  
df$water <- as.factor(df$water)  

df <- df[df$water == "Flooded", ]


# 2.1 (optional) - log transform MeHg values (bad, resulted in higher RMSE and lower R2)
# df$MeHg <- log(df$MeHg)

# Number of data split permutations, adjust this number to change the number of permutations, change to 100 in final run
n_splits <- 100

# Create storage for importance metrics across different splits  
importance_results <- list()  
pvalue_results <- list()  
performance_metrics <- list()  
correlation_results <- list()  

# 3. Split Data into Training and Testing Sets  
# Set a seed for reproducibility
# Run models with different random splits  
for (i in 1:n_splits) {  
  # Set a different seed for each data split  
  set.seed(i)  
  
  # Split data  
  train_indices <- createDataPartition(df$MeHg, p = 0.7, list = FALSE)  
  train_data <- df[train_indices, ]  
  test_data <- df[-train_indices, ]  
  
  # Set a seed for rfPermute  
  set.seed(123)  
  
  # Train the rfPermute model  
  rp_model <- rfPermute(  
    MeHg ~ 
           overall_methanogen_hgcA + 
           overall_methanogen +   
           overall_aerobic_methanotroph + 
           F1Hg +
           DOM_SUVA254,
    data = train_data,  
    ntree = 2001,  
    mtry = 4,  
    importance = TRUE,  
    num.rep = 100  # Reduced to 100 for computational efficiency
  )  
  
  # Store the importance values  
  importance_results[[i]] <- rfPermute::importance(rp_model)
  
  # Store the p-values  
  pvalue_results[[i]] <- rp_model$pval  
  
  # Get predictions on test data  
  predictions <- predict(rp_model, newdata = test_data)  
  
  # Calculate and store performance metrics  
  performance_metrics[[i]] <- data.frame(  
    Split = i,  
    RMSE = sqrt(mean((test_data$MeHg - predictions)^2)),  
    MAE = mean(abs(test_data$MeHg - predictions)),  
    R_squared = cor(test_data$MeHg, predictions)^2  
  )
  # Store correlation results  
  correlation_results[[i]] <- data.frame(  
    Split = i,  
    Pearson_r = cor(test_data$MeHg, predictions, method = "pearson"),  
    Spearman_rho = cor(test_data$MeHg, predictions, method = "spearman"),  
    R_squared = cor(test_data$MeHg, predictions)^2,  
    R_squared_lm = summary(lm(predictions ~ test_data$MeHg))$r.squared
  )  
} 

# Get variable names (predictors from your model)  
var_names <- c( 
               "overall_methanogen_hgcA", 
               "overall_methanogen", 
               "overall_aerobic_methanotroph", 
               "F1Hg",
               "DOM_SUVA254")  

# Create a data frame to store summary statistics  
importance_summary <- data.frame(  
  Variable = var_names,  
  Mean_IncMSE = numeric(length(var_names)),  
  Lower_CI_IncMSE = numeric(length(var_names)),  
  Upper_CI_IncMSE = numeric(length(var_names)),  
  Mean_pvalue = numeric(length(var_names)),  
  Significant_Splits = numeric(length(var_names)),  
  stringsAsFactors = FALSE  
)  

# Process each variable  
for (j in 1:length(var_names)) {  
  v <- var_names[j]  
  
  # Collect %IncMSE values across all splits  
  inc_mse_values <- sapply(importance_results, function(x) x[v, "%IncMSE"])  
  
  # Collect p-values across all splits  
  p_values <- sapply(importance_results, function(x) x[v, "%IncMSE.pval"])  
  
  # Calculate mean and 95% confidence intervals  
  importance_summary$Mean_IncMSE[j] <- mean(inc_mse_values)  
  importance_summary$Lower_CI_IncMSE[j] <- quantile(inc_mse_values, 0.025)  
  importance_summary$Upper_CI_IncMSE[j] <- quantile(inc_mse_values, 0.975)  
  
  # Calculate mean p-value and count of significant splits (p < 0.05)  
  importance_summary$Mean_pvalue[j] <- mean(p_values)  
  importance_summary$Significant_Splits[j] <- sum(p_values < 0.05)  
} 

# Calculate percentage of splits where variable was significant  
importance_summary$Significance_Rate <- (importance_summary$Significant_Splits / length(importance_results)) * 100  

# Sort by mean importance  
importance_summary <- importance_summary[order(importance_summary$Mean_IncMSE, decreasing = TRUE), ]  

# Combine performance metrics  
all_performance <- do.call(rbind, performance_metrics)  
all_correlations <- do.call(rbind, correlation_results)  


# Summarize performance across all splits  
performance_summary <- data.frame(  
  Metric = c("RMSE", "MAE", "R_squared"),  
  Mean = c(  
    mean(all_performance$RMSE),  
    mean(all_performance$MAE),  
    mean(all_performance$R_squared)  
  ),  
  Median = c(  
    median(all_performance$RMSE),  
    median(all_performance$MAE),  
    median(all_performance$R_squared)  
  ),  
  StdDev = c(  
    sd(all_performance$RMSE),  
    sd(all_performance$MAE),  
    sd(all_performance$R_squared)  
  ),  
  Min = c(  
    min(all_performance$RMSE),  
    min(all_performance$MAE),  
    min(all_performance$R_squared)  
  ),  
  Max = c(  
    max(all_performance$RMSE),  
    max(all_performance$MAE),  
    max(all_performance$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_performance$RMSE, 0.025),  
    quantile(all_performance$MAE, 0.025),  
    quantile(all_performance$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_performance$RMSE, 0.975),  
    quantile(all_performance$MAE, 0.975),  
    quantile(all_performance$R_squared, 0.975)  
  )  
)  

# Summarize correlation metrics  
correlation_summary <- data.frame(  
  Metric = c("Pearson_r", "Spearman_rho", "R_squared"),  
  Mean = c(  
    mean(all_correlations$Pearson_r),  
    mean(all_correlations$Spearman_rho),  
    mean(all_correlations$R_squared)  
  ),  
  Median = c(  
    median(all_correlations$Pearson_r),  
    median(all_correlations$Spearman_rho),  
    median(all_correlations$R_squared)  
  ),  
  StdDev = c(  
    sd(all_correlations$Pearson_r),  
    sd(all_correlations$Spearman_rho),  
    sd(all_correlations$R_squared)  
  ),  
  CI_Lower = c(  
    quantile(all_correlations$Pearson_r, 0.025),  
    quantile(all_correlations$Spearman_rho, 0.025),  
    quantile(all_correlations$R_squared, 0.025)  
  ),  
  CI_Upper = c(  
    quantile(all_correlations$Pearson_r, 0.975),  
    quantile(all_correlations$Spearman_rho, 0.975),  
    quantile(all_correlations$R_squared, 0.975)  
  )  
)  


# Print performance summaries  
cat("\nPerformance Metrics Summary:\n")  
print(performance_summary)  

cat("\nCorrelation Metrics Summary:\n")  
print(correlation_summary)



# 1. Variable importance plot with confidence intervals  
# Add significance indicators to the data with correct logic  
importance_summary$Significance <- ifelse(importance_summary$Significance_Rate >= 90,   
                                         "Consistently Significant (p<0.05 in ≥90% of splits)",  
                                         ifelse(importance_summary$Significance_Rate >= 10,  
                                                "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                "Rarely Significant (p<0.05 in <10% of splits)"))  

# Convert to factor with specific order  
importance_summary$Significance <- factor(importance_summary$Significance,   
                                          levels = c("Consistently Significant (p<0.05 in ≥90% of splits)",  
                                                    "Sometimes Significant (p<0.05 in 10-89% of splits)",  
                                                    "Rarely Significant (p<0.05 in <10% of splits)"))  

# Add percentage value to show in the plot  
importance_summary$label_text <- sprintf("%.1f%% (p=%.3f)",   
                                        importance_summary$Significance_Rate,   
                                        importance_summary$Mean_pvalue)  

importance_summary

# Plotting part
importance_plot <- ggplot(importance_summary, aes(x = reorder(Variable, Mean_IncMSE), y = Mean_IncMSE)) +  
  geom_point(aes(size = Significance_Rate, color = Significance), alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower_CI_IncMSE, ymax = Upper_CI_IncMSE, color = Significance), 
                width = 0.4, linewidth = 1.5) +  
  geom_text(aes(label = label_text), hjust = -0.2, size = 4, vjust = -0.5) +  
  coord_flip() +  
  scale_color_manual(values = c("Consistently Significant (p<0.05 in ≥90% of splits)" = "#06d6a0",  
                                 "Sometimes Significant (p<0.05 in 10-89% of splits)" = "#ffd166",  
                                 "Rarely Significant (p<0.05 in <10% of splits)" = "#ef476f")) +  
  scale_size_continuous(range = c(4, 8)) +  # Increased size range for better visual impact
  labs(x = "Predictor Variable",   
       y = "Mean Percent Increase in Mean Squared Error (%IncMSE)") +  
  theme_minimal(base_size = 14) +  # Increased base font size
  theme(  
    plot.subtitle = element_text(size = 12, color = "darkgrey"),  
    plot.caption = element_text(hjust = 0, size = 11, color = "darkgrey"),  
    legend.title = element_text(face = "bold", size = 13),  
    legend.text = element_text(size = 12),
    legend.position = "bottom",  
    legend.box = "vertical",  
    legend.key.size = unit(1, "cm"),
    panel.grid.major.y = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.grid.major.x = element_line(color = "lightgrey", linetype = "dotted"),  
    axis.title = element_text(face = "bold", size = 14),  
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 12)  
  ) +  
  guides(size = "none") +  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")



# 2. Create a performance metrics visualization using your summary data  
# Convert performance_summary to long format for plotting  
performance_long <- rbind(  
  data.frame(Metric = "RMSE",   
             Value = performance_summary$Mean[performance_summary$Metric == "RMSE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "RMSE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "RMSE"]),  
  data.frame(Metric = "MAE",   
             Value = performance_summary$Mean[performance_summary$Metric == "MAE"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "MAE"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "MAE"]),  
  data.frame(Metric = "R²",   
             Value = performance_summary$Mean[performance_summary$Metric == "R_squared"],  
             Lower = performance_summary$CI_Lower[performance_summary$Metric == "R_squared"],  
             Upper = performance_summary$CI_Upper[performance_summary$Metric == "R_squared"]),  
  data.frame(Metric = "Pearson r",   
             Value = correlation_summary$Mean[correlation_summary$Metric == "Pearson_r"],  
             Lower = correlation_summary$CI_Lower[correlation_summary$Metric == "Pearson_r"],  
             Upper = correlation_summary$CI_Upper[correlation_summary$Metric == "Pearson_r"]) 
)  

# Add labels  
performance_long$Label <- sprintf("%.3f\n(95%% CI: %.3f-%.3f)",   
                                 performance_long$Value,   
                                 performance_long$Lower,   
                                 performance_long$Upper)  

# Order the metrics in a logical way  
performance_long$Metric <- factor(performance_long$Metric,   
                                 levels = c("R²", "Pearson r", "RMSE", "MAE"))  

performance_plot <- ggplot(performance_long, aes(x = Metric, y = Value, fill = Metric)) +  
  geom_bar(stat = "identity", width = 0.6, alpha = 0.8) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.3, linewidth = 1.5, color="grey70") +  
  geom_text(aes(label = Label, y = Upper + (max(performance_long$Upper) * 0.05)),   
            vjust = 0, size = 4) +  # Increased label size
  scale_fill_brewer(palette = "Blues") +  
  labs(y = "Value",  
       x = NULL) +  
  theme_minimal(base_size = 14) +  # Increased base font size
  theme(  
    plot.subtitle = element_text(size = 12, color = "darkgrey"),  
    legend.position = "none",  
    panel.grid.major.x = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.text.x = element_text(size = 12, face = "bold"),  
    axis.title = element_text(face = "bold", size = 14)  
  ) +  
  coord_cartesian(ylim = c(0, max(performance_long$Upper) * 1.15))

performance_plot

combined_plot1 <- importance_plot + performance_plot +   
  plot_layout(widths = c(3, 2)) +  
  plot_annotation(  
    theme = theme(plot.title = element_blank(),  # Remove the title
                  plot.subtitle = element_text(size = 16, face = "bold", hjust = 0.5))  
  ) +
  plot_annotation(tag_levels = 'A')

combined_plot1


ggsave("output/rf_model_comparisons/20250804_rf_model_reduced_flooded_100.pdf",   
       plot = combined_plot1,   
       width = 45,   
       height = 20,   
       units = "cm")

```








# part 5 - additional analyses to address reviewer's comments
# eLSA analysis FDR calculation
```r
library(data.table)

# Function to apply FDR correction for each source
apply_fdr_by_source <- function(input_file, output_file, fdr_threshold = 0.05) {
  
  # Read the data
  dt <- fread(input_file, header = TRUE)
  
  # Initialize FDR columns
  dt[, FDR_eLSA := NA_real_]
  dt[, FDR_Spearman := NA_real_]
  
  # Apply FDR correction separately for each source
  unique_sources <- unique(dt$Source)
  
  for (source in unique_sources) {
    # Get indices for this source
    source_indices <- which(dt$Source == source)
    
    # Apply FDR correction for this source's tests
    if (length(source_indices) > 1) {
      # Only apply correction if there are multiple tests for this source
      dt[source_indices, FDR_eLSA := p.adjust(significance, method = "fdr")]
      dt[source_indices, FDR_Spearman := p.adjust(`SpearmanCorrP-value`, method = "fdr")]
    } else {
      # If only one test, FDR = original p-value
      dt[source_indices, FDR_eLSA := significance]
      dt[source_indices, FDR_Spearman := `SpearmanCorrP-value`]
    }
  }
  
  # Filter for significance using FDR threshold
  dt_sig <- dt[FDR_eLSA < fdr_threshold & FDR_Spearman < fdr_threshold]
  
  # Print summary
  cat("File:", input_file, "\n")
  cat("Total associations before FDR correction:", nrow(dt), "\n")
  cat("Significant associations after FDR correction:", nrow(dt_sig), "\n")
  cat("Number of unique sources:", length(unique_sources), "\n")
  cat("FDR threshold:", fdr_threshold, "\n\n")
  
  # Write results as comma-separated CSV
  fwrite(dt_sig, output_file, sep = ",")
  
  return(dt_sig)
}

# Use relative paths from your working directory
input_dir <- "./data/elsa_fdr"  # Current directory
output_dir <- "./data/elsa_fdr"  # Create a subdirectory for output

# Create output directory if it doesn't exist
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
  cat("Created output directory:", output_dir, "\n")
}

# Print directories being used
cat("Current working directory:", getwd(), "\n")
cat("Input directory:", input_dir, "\n")
cat("Output directory:", output_dir, "\n\n")

# List files in current directory to check what's available
cat("Files in current directory:\n")
files_in_dir <- list.files(pattern = "*.csv")
print(files_in_dir)
cat("\n")

# Process all MAGs files
sites <- c("SK_sur", "GX_sur", "HX_sur")

for (site in sites) {
  # Construct relative file paths
  input_file <- file.path(input_dir, paste0("selected_eLSA_all_MAGs_", site, "_results_combined_edge_file.csv"))
  output_file <- file.path(output_dir, paste0("selected_eLSA_all_MAGs_", site, "_results_combined_edge_file_FDR_corrected.csv"))
  
  if (file.exists(input_file)) {
    cat("Processing:", input_file, "\n")
    result <- apply_fdr_by_source(input_file, output_file, fdr_threshold = 0.05)
  } else {
    cat("Warning: File", input_file, "not found\n")
  }
}

cat("FDR correction completed for all sites!\n")

```

# eLSA analysis FDR calculation - modified 
```r
library(data.table)

# Function to apply FDR correction for each source (adds columns only)
apply_fdr_by_source <- function(input_file, output_file, fdr_threshold = 0.05) {
  
  # Read the data
  dt <- fread(input_file, header = TRUE)
  
  # Print column names to verify
  cat("Column names in file:", colnames(dt), "\n")
  
  # Initialize FDR columns
  dt[, FDR_eLSA := NA_real_]
  dt[, FDR_Spearman := NA_real_]
  
  # Apply FDR correction separately for each source
  unique_sources <- unique(dt$source)  # Changed from 'Source' to 'source'
  
  for (source_name in unique_sources) {
    source_indices <- which(dt$source == source_name)
    
    # Apply FDR correction for this source's tests
    if (length(source_indices) > 1) {
      # Only apply correction if there are multiple tests for this source
      dt[source_indices, FDR_eLSA := p.adjust(significance, method = "fdr")]
      dt[source_indices, FDR_Spearman := p.adjust(`SpearmanCorrP-value`, method = "fdr")]
    } else {
      # If only one test, FDR = original p-value
      dt[source_indices, FDR_eLSA := significance]
      dt[source_indices, FDR_Spearman := `SpearmanCorrP-value`]
    }
  }
  
  # Print summary (NO FILTERING - just reporting)
  cat("File:", input_file, "\n")
  cat("Total associations:", nrow(dt), "\n")
  cat("Number of unique sources:", length(unique_sources), "\n")
  
  # Count how many would be significant at different thresholds
  sig_original <- nrow(dt[significance < fdr_threshold & `SpearmanCorrP-value` < fdr_threshold])
  sig_fdr <- nrow(dt[FDR_eLSA < fdr_threshold & FDR_Spearman < fdr_threshold])
  
  cat("Significant associations (original p < 0.05):", sig_original, "\n")
  cat("Significant associations (FDR < 0.05):", sig_fdr, "\n")
  cat("FDR threshold:", fdr_threshold, "\n\n")
  
  # Write ALL results (no filtering) with FDR columns added
  fwrite(dt, output_file, sep = ",")
  
  return(dt)  # Return all data, not filtered
}

# Use relative paths from your working directory
input_dir <- "./data/elsa_fdr"
output_dir <- "./data/elsa_fdr"

# Create output directory if it doesn't exist
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
  cat("Created output directory:", output_dir, "\n")
}

# Print directories being used
cat("Current working directory:", getwd(), "\n")
cat("Input directory:", input_dir, "\n")
cat("Output directory:", output_dir, "\n\n")

# List files in input directory to check what's available
cat("Files in input directory:\n")
files_in_dir <- list.files(input_dir, pattern = "*.csv")
print(files_in_dir)
cat("\n")

# Process the MAGs file
input_file <- file.path(input_dir, "elsa_all_MAGs_results.csv")
output_file <- file.path(output_dir, "elsa_all_MAGs_results_with_FDR.csv")
  
if (file.exists(input_file)) {
  cat("Processing:", input_file, "\n")
  result <- apply_fdr_by_source(input_file, output_file, fdr_threshold = 0.05)
} else {
  cat("Warning: File", input_file, "not found\n")
  cat("Available files:\n")
  print(files_in_dir)
}

cat("FDR correction completed!\n")

```

# MAGs plotting
## methanobactin biosynthesis plot
```r
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(tidyr)
library(viridis)    # For color scales
library(gridExtra)  # For combining plots
library(patchwork)  # For combining plots

# Read the CSV data
data <- read.csv("data/mbn_biosynthesis_MAGs/methanobactin_genes_presence.csv", header = TRUE)

# Prepare data: Convert to long format for gene presence
long_data <- data %>%
  pivot_longer(
    cols = starts_with("mBn"),
    names_to = "Gene",
    values_to = "Presence"
  )

# Create a factor for MAGs to ensure proper ordering
data$MAGs_original_name <- factor(data$MAGs_original_name, levels = unique(data$MAGs_original_name))

# Assign values based on "Presence" using base R
long_data$Presence[long_data$Presence == 0] <- "Absence"
long_data$Presence[long_data$Presence == 1] <- "Presence"


# Create the heatmap plot
heatmap_plot <- ggplot(long_data, aes(x = Gene, y = MAGs_original_name, fill = Presence)) +
  geom_tile(color = "black") +  # Add grid lines
  scale_fill_manual(
    values = c("Presence" = "#2c7fb8", "Absence" = "lightgray"),  # Use discrete colors: light gray for "Absent" (0) and blue for "Present" (1)
    name = "Gene Presence"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(
    title = "Heatmap of Methanobactin Biosynthesis and Transport Genes",
    x = "Methanobactin Genes",
    y = "MAGs"
  ) +
  scale_x_discrete(limits = c(gene_order_biosynthesis, gene_order_transport))  # Sort genes to your requirements

# Prepare a data frame for Completeness
completeness_long <- data %>%
  select(MAGs_original_name, Completeness) %>%
  pivot_longer(
    cols = Completeness,
    names_to = "Metric",
    values_to = "Value"
  )


# Create the completeness plot with defined cut levels and colors
completeness_plot <- ggplot(completeness_long, aes(x = Metric, y = MAGs_original_name)) +
  geom_tile(aes(fill = cut(Value, breaks = c(100, 90, 80, 70, 60), 
                            labels = c("100-90", "90-80", "80-70", "70-60"))), color = "black") +  # Add grid lines
  scale_fill_manual(
    values = c("70-60" = "#E8FFD7", "80-70" = "#93DA97", "90-80" = "#5E936C", "100-90" = "#3E5F44"),  # Define discrete 3E5F44
    name = "Completeness"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5),
    axis.title.x = element_blank(),  # Remove x-axis title
    axis.text.y = element_blank(),    # Hide y-axis text
    axis.title.y = element_blank(),   # Remove y-axis title
    axis.ticks.y = element_blank(),   # Remove y-axis ticks
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )

# Display the completeness plot
print(completeness_plot)


# Prepare a data frame for Redundancy
redundancy_long <- data %>%
  select(MAGs_original_name, Redundancy) %>%
  pivot_longer(
    cols = Redundancy,
    names_to = "Metric",
    values_to = "Value"
  )

# Create the heatmap for Redundancy with discrete colors
redundancy_plot <- ggplot(redundancy_long, aes(x = Metric, y = MAGs_original_name)) +
  geom_tile(aes(fill = cut(Value, breaks = c(10, 7.5, 5, 2.5, 0), 
                            labels = c("10-7.5", "7.5-5", "5-2.5", "2.5-0"))), color = "black") +  # Add grid lines
  scale_fill_manual(
    values = c("2.5-0" = "#E8FFD7", "5-2.5" = "#93DA97", "7.5-5" = "#5E936C", "10-7.5" = "#3E5F44"),  # Define discrete 3E5F44
    name = "Redundancy"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5),
    axis.title.x = element_blank(),  # Remove x-axis title
    axis.text.y = element_blank(),    # Hide y-axis text
    axis.title.y = element_blank(),   # Remove y-axis title
    axis.ticks.y = element_blank(),   # Remove y-axis ticks
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )

print(redundancy_plot)


# Combine plots using patchwork
combined_plot <- (heatmap_plot + 
                  theme(legend.position = "right")) +  # Main heatmap plot
                 (completeness_plot + 
                  theme(legend.position = "right")) +  # Completeness plot
                 (redundancy_plot + 
                  theme(legend.position = "right")) +  # Redundancy plot
                 plot_layout(ncol = 3, widths = c(7, 3, 3))  # Specify layout with widths

# Display the combined plot
print(combined_plot)

# Save the plot to a file
ggsave("./output/methanobactin_genes_plot.pdf", combined_plot, width = 30, height = 12, dpi = 300)
```

## mbnT(TIGRFAM) selected genus DNA/RNA comparison
```r
# Load necessary libraries
library(ggplot2)
library(reshape2)
library(patchwork)

# color palette
color_mapping <- c('Methylosinus' = '#c3a016', 
                   'Methylomicrobium' = '#c3d878', 
                   'Methylocystis' = '#163274' )

# make the stacked bar graphs, showing a comparison of DNA and RNA data/ 
mbnT_dna <- read.csv('data/gene_transcript/mbnT_TIGRFAM_selected_genus_DNA.csv', stringsAsFactors = FALSE)
mbnT_dna$taxa <- factor(mbnT_dna$taxa, levels=unique(mbnT_dna$taxa))

# Melt the data frame to long format
mbnT_dna_long <- melt(mbnT_dna, id.vars = 'taxa', variable.name = 'Sample', value.name = 'Value')
mbnT_dna_long$Sample <- factor(mbnT_dna_long$Sample, levels = rev(levels(mbnT_dna_long$Sample)))

# Create the stacked bar graph
p1 <- ggplot(mbnT_dna_long, aes(x = Sample, y = Value, fill = taxa)) +
  geom_bar(stat = 'identity', width = 0.75, color = "black", size = 0.2) +
  scale_fill_manual(values = color_mapping) +
  theme(axis.text.y = element_blank()) +
  labs(title = "mbnT DNA", y = '% total reads normalised by HMM length', x = '', fill = 'Sample') + 
  coord_flip() # Use this if you want to flip the axes
p1

# mbnT_rna
mbnT_rna <- read.csv('data/gene_transcript/mbnT_TIGRFAM_selected_genus_RNA.csv', stringsAsFactors = FALSE)

# Melt the data frame to long format
mbnT_rna_long <- melt(mbnT_rna, id.vars = 'taxa', variable.name = 'Sample', value.name = 'Value')
mbnT_rna_long$Sample <- factor(mbnT_rna_long$Sample, levels = rev(levels(mbnT_rna_long$Sample)))

# Create the stacked bar graph
p2 <- ggplot(mbnT_rna_long, aes(x = Sample, y = Value, fill = taxa)) +
  geom_bar(stat = 'identity', width = 0.75, color = "black", size = 0.2) +
    scale_fill_manual(values = color_mapping) +
  theme (legend.position = "none") +
  labs(title = "mbnT RNA", y = '% total reads normalised by HMM length', x = '', fill = 'Sample') +
  coord_flip() # Use this if you want to flip the axes

p2

mbnT_combined_plot <- p2 + p1 + plot_layout(ncol = 2, widths = c(1, 1))

mbnT_TIGRFAM_selected_genus_combined_plot <- mbnT_combined_plot +
    theme(
    text = element_text(colour = "black"), # This sets the base text color to black
    axis.title = element_text(colour = "black"), # For axis titles
    axis.text = element_text(colour = "black"), # For axis text
    plot.title = element_text(colour = "black"), # For the plot title
    plot.subtitle = element_text(colour = "black"), # For the plot subtitle if you have one
    plot.caption = element_text(colour = "black"), # For the plot caption if you have one
    legend.text = element_text(colour = "black") # For legend text
  )

mbnT_TIGRFAM_selected_genus_combined_plot

#ggsave("output/MbnT2_rna_plot.pdf", width = 25, height = 6, units = "cm")

```

## metatranscriptomics vs metagenomics comparison plot
```r
library(ggplot2)  
library(reshape2)  
library(patchwork)  

# Universal plot theme (axes text size may be tweaked for your taste)  
univ_theme <- theme_minimal(base_size = 12) +  
  theme(  
    text = element_text(colour = "black"),  
    axis.title = element_text(colour = "black", face = "bold"),  
    axis.text = element_text(colour = "black", size=10),  
    plot.title = element_text(hjust = 0.5, face = "bold", colour = "black"),  
    legend.title = element_text(face = "bold", colour = "black"),  
    legend.text = element_text(colour = "black"),  
    axis.line = element_line(colour = "black"),  
    panel.grid = element_blank(),  
    plot.caption = element_text(colour = "black")
    # axis.text.y = element_blank()  
  )  

make_gene_plot <- function(df, color_map, main_title, ylab, legend_title, show_legend = TRUE) {  
  df_long <- melt(df, id.vars = "taxa", variable.name = "Sample", value.name = "Value")  
  df_long$Sample <- factor(df_long$Sample, levels = rev(unique(df_long$Sample)))  
  df_long$taxa <- factor(df_long$taxa, levels = names(color_map))  
  ggplot(df_long, aes(x = Sample, y = Value, fill = taxa)) +  
    geom_bar(stat = "identity", width = 0.75, color = "black", size = 0.2) +  
    scale_fill_manual(values = color_map) +  
    labs(title = main_title, y = ylab, x = "", fill = legend_title) +  
    coord_flip() +  
    univ_theme +  
    theme(legend.position = if (show_legend) "right" else "none")  
}  


# hgcA
hgcA_color <- c(
  "Deferrimicrobiaceae" = "skyblue", "Geoalkalibacteraceae" = "royalblue", "Geobacteraceae" = "steelblue",
  "Desulfatiglandaceae" = "darkgreen", "Desulfobulbaceae" = "forestgreen", "Desulfocapsaceae" = "limegreen",
  "Desulfomonilaceae" = "seagreen", "Desulfosalsimonadaceae" = "mediumseagreen", "Desulfovibrionaceae" = "olivedrab",
  "Desulfurivibrionaceae" = "yellowgreen", "Methanocellaceae" = "coral", "Methanomassiliicoccaceae" = "tomato",
  "Methanomicrobiaceae" = "orangered", "Methanoperedenaceae" = "darkorange", "Methanoregulaceae" = "salmon",
  "Methanosarcinaceae" = "indianred", "Methanosphaerulaceae" = "lightcoral", "Methanospirillaceae" = "firebrick",
  "Smithellaceae" = "mediumpurple", "Syntrophaceae" = "purple", "Syntrophobacteraceae" = "darkorchid",
  "Others" = "grey80"
)

# merB
merB_color <- c(
  'Nitrospirota' = '#de8e69', 'Actinomycetota' = '#f1be99', 'Halobacteriota' = '#c1bd38',
  'Pseudomonadota' = '#7a9132', 'Chloroflexota' = '#4c849a', 'Methylomirabilota' = '#184363',
  'Desulfobacterota F' = '#a39fc9'
)

mcrA_color <- c(
  'Methanocellaceae' = '#e2d8d6', 'Methanobacteriaceae' = '#AD5A6B', 'Methanotrichaceae' = '#C993A2',
  'Methanoperedenaceae' = '#365C83', 'Methanosphaerulaceae' = '#4D8F8B',
  'Methanoregulaceae' = '#E3C1CB', 'Methanocorpusculaceae' = '#CDD6AD'
)

pmoA_color <- c(
  'Methylomonadaceae' = '#c3a016', 'Beijerinckiaceae' = '#c3d878',
  'Methyloligellaceae' = '#58a787', 'Methylococcaceae' = '#8ebacd',
  'mmoX_Methylomonadaceae' = '#246893'
)

mbnT_color <- c('Methylosinus' = '#c3a016', 'Methylomicrobium' = '#c3d878', 'Methylocystis' = '#163274')



# hgcA  
hgcA_dna <- read.csv("data/gene_transcript/hgcA_methanogen_family_dna.csv", stringsAsFactors = FALSE)  
hgcA_rna <- read.csv("data/gene_transcript/hgcA_methanogen_family_rna.csv", stringsAsFactors = FALSE)  
hgcA_dna_p <- make_gene_plot(hgcA_dna, hgcA_color, "hgcA DNA", "% total reads normalised by HMM length", "Family", TRUE)  
hgcA_rna_p <- make_gene_plot(hgcA_rna, hgcA_color, "hgcA RNA", "% total reads normalised by HMM length", "Family", FALSE)  
hgcA_plot <- hgcA_dna_p + hgcA_rna_p + plot_layout(ncol = 2, widths = c(1,1), guides = 'collect')

# merB  
merB_dna <- read.csv("data/gene_transcript/merB_dna.csv", stringsAsFactors=FALSE)  
merB_rna <- read.csv("data/gene_transcript/merB_rna.csv", stringsAsFactors=FALSE)  
merB_dna_p <- make_gene_plot(merB_dna, merB_color, "merB DNA", "% total reads normalised by HMM length", "Phylum", TRUE)  
merB_rna_p <- make_gene_plot(merB_rna, merB_color, "merB RNA", "% total reads normalised by HMM length", "Phylum", FALSE)  
merB_plot <- merB_dna_p + merB_rna_p + plot_layout(ncol = 2, widths = c(1,1), guides = 'collect')

# mcrA  
mcrA_dna <- read.csv("data/gene_transcript/mcrA_dna.csv", stringsAsFactors=FALSE)  
mcrA_rna <- read.csv("data/gene_transcript/mcrA_rna.csv", stringsAsFactors=FALSE)  
mcrA_dna_p <- make_gene_plot(mcrA_dna, mcrA_color, "mcrA DNA", "% total reads normalised by HMM length", "Family", TRUE)  
mcrA_rna_p <- make_gene_plot(mcrA_rna, mcrA_color, "mcrA RNA", "% total reads normalised by HMM length", "Family", FALSE)  
mcrA_plot <- mcrA_dna_p + mcrA_rna_p + plot_layout(ncol = 2, widths = c(1,1), guides = 'collect') 

# pmoA  
pmoA_dna <- read.csv("data/gene_transcript/pmoA_dna.csv", stringsAsFactors=FALSE)  
pmoA_rna <- read.csv("data/gene_transcript/pmoA_rna.csv", stringsAsFactors=FALSE)  
pmoA_dna_p <- make_gene_plot(pmoA_dna, pmoA_color, "pmoA DNA", "% total reads normalised by HMM length", "Family", TRUE)  
pmoA_rna_p <- make_gene_plot(pmoA_rna, pmoA_color, "pmoA RNA", "% total reads normalised by HMM length", "Family", FALSE)  
pmoA_plot <- pmoA_dna_p + pmoA_rna_p + plot_layout(ncol = 2, widths = c(1,1), guides = 'collect')

# mbnT  
mbnT_dna <- read.csv('data/gene_transcript/mbnT_TIGRFAM_selected_genus_DNA.csv', stringsAsFactors = FALSE)
mbnT_rna <- read.csv('data/gene_transcript/mbnT_TIGRFAM_selected_genus_RNA.csv', stringsAsFactors = FALSE) 
mbnT_dna_p <- make_gene_plot(mbnT_dna, mbnT_color, "mbnT DNA", "% total reads normalised by HMM length", "Family", TRUE)  
mbnT_rna_p <- make_gene_plot(mbnT_rna, mbnT_color, "mbnT RNA", "% total reads normalised by HMM length", "Family", FALSE)  
mbnT_plot <- mbnT_dna_p + mbnT_rna_p + plot_layout(ncol = 2, widths = c(1,1), guides = 'collect')

final_composite_plot <- hgcA_plot / merB_plot / mcrA_plot / pmoA_plot / mbnT_plot +
  plot_layout(ncol = 1, guides = 'collect') # &
#  theme(legend.position = "right")

# To display:
ggsave("output/key_genes_rna_dna_comparison.pdf", final_composite_plot, width = 15, height=15, units = "in")

```

## multiple regression MeHg hgcA
```r
# Load your data
df <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

# Optionally, log-transform MeHg if its distribution is skewed
df$logMeHg <- log10(df$MeHg)

# Fit candidate regression models
model1 <- lm(MeHg ~ overall_hgcA, data = df)
model2 <- lm(MeHg ~ F1Hg, data = df)
model3 <- lm(MeHg ~ overall_hgcA + F1Hg, data = df)
model4 <- lm(MeHg ~ overall_hgcA * F1Hg, data = df) # includes interaction
model5 <- lm(MeHg ~ overall_hgcA + F1Hg + site + type, data = df)
model6 <- lm(MeHg ~ overall_hgcA * F1Hg + site + type, data = df)
model7 <- lm(MeHg ~ overall_hgcA * F1Hg * site + type, data = df) # if you want site-specific interactions


# Summarize models
summary(model1)
summary(model2)
summary(model3)
summary(model4)
summary(model5)
summary(model6)
summary(model7)

# Compare model fit statistics
library(AICcmodavg)

models <- list(model1, model2, model3, model4, model5, model6, model7)
model.names <- c("hgcA only", "F1Hg only", "additive", "interaction", 
                 "additive + site/type", "interaction + site/type", "full interactions")

aictab(models, modnames = model.names)

# Get adjusted R-squared
adj_r2 <- sapply(models, function(mod) summary(mod)$adj.r.squared)
names(adj_r2) <- model.names
print(adj_r2)

```

### Save multiple regression to tabular format (MeHg ~ hgcA)
```r
library(AICcmodavg)

# Fit models and create lists (your existing code)
model1 <- lm(MeHg ~ overall_hgcA, data = df)
model2 <- lm(MeHg ~ F1Hg, data = df)
model3 <- lm(MeHg ~ overall_hgcA + F1Hg, data = df)
model4 <- lm(MeHg ~ overall_hgcA * F1Hg, data = df)
model5 <- lm(MeHg ~ overall_hgcA + F1Hg + site + type, data = df)
model6 <- lm(MeHg ~ overall_hgcA * F1Hg + site + type, data = df)
model7 <- lm(MeHg ~ overall_hgcA * F1Hg * site * type, data = df)

models <- list(model1, model2, model3, model4, model5, model6, model7)
model_names <- c("hgcA only", "F1Hg only", "additive", "interaction", 
                 "additive + site/type", "interaction + site/type", "full interactions")

model_descriptions <- c("hgcA gene abundance only",
                       "Bioavailable Hg(II) only",
                       "Additive effects of hgcA and F1-Hg",
                       "hgcA and F1-Hg with interaction",
                       "Additive effects controlling for site and compartment",
                       "Interaction effects controlling for site and compartment", 
                       "Full interaction model with site-specific effects")

# Get AIC table (this reorders by AICc)
aic_table <- aictab(models, modnames = model_names)

# Extract the order from aictab results
model_order <- match(aic_table$Modnames, model_names)

# Reorder everything to match aictab order
models_reordered <- models[model_order]
model_names_reordered <- model_names[model_order]
model_descriptions_reordered <- model_descriptions[model_order]

# Get model structures in the correct order
model_structures_reordered <- sapply(models_reordered, function(x) deparse(formula(x)))

# Extract statistics in the correct order
extract_all_stats <- function(model) {
  summ <- summary(model)
  list(
    R_squared = summ$r.squared,
    Adj_R_squared = summ$adj.r.squared,
    F_statistic = summ$fstatistic[1],
    F_p_value = pf(summ$fstatistic[1], summ$fstatistic[2], summ$fstatistic[3], lower.tail = FALSE),
    Residual_SE = summ$sigma,
    DF = summ$df[2],
    N_observations = nobs(model)
  )
}

all_stats_reordered <- do.call(rbind, lapply(models_reordered, function(x) data.frame(extract_all_stats(x))))

# Now create the comprehensive table (everything is in the same order)
comprehensive_table <- data.frame(
  Model_Name = model_names_reordered,
  Model_Structure = model_structures_reordered,
  Model_Description = model_descriptions_reordered,
  K = aic_table$K,
  N_observations = all_stats_reordered$N_observations,
  AICc = aic_table$AICc,
  Delta_AICc = aic_table$Delta_AICc,
  AICcWt = aic_table$AICcWt,
  R_squared = all_stats_reordered$R_squared,
  Adj_R_squared = all_stats_reordered$Adj_R_squared,
  Variance_Explained_Percent = all_stats_reordered$Adj_R_squared * 100,
  F_statistic = all_stats_reordered$F_statistic,
  F_p_value = all_stats_reordered$F_p_value,
  Residual_SE = all_stats_reordered$Residual_SE,
  DF = all_stats_reordered$DF
)

# Round numeric columns (your existing code)
comprehensive_table$AICc <- round(comprehensive_table$AICc, 2)
comprehensive_table$Delta_AICc <- round(comprehensive_table$Delta_AICc, 2)
comprehensive_table$AICcWt <- round(comprehensive_table$AICcWt, 3)
comprehensive_table$R_squared <- round(comprehensive_table$R_squared, 4)
comprehensive_table$Adj_R_squared <- round(comprehensive_table$Adj_R_squared, 4)
comprehensive_table$Variance_Explained_Percent <- round(comprehensive_table$Variance_Explained_Percent, 2)
comprehensive_table$F_statistic <- round(comprehensive_table$F_statistic, 2)
comprehensive_table$F_p_value <- format(comprehensive_table$F_p_value, scientific = TRUE, digits = 3)
comprehensive_table$Residual_SE <- round(comprehensive_table$Residual_SE, 4)

# Save the table
write.csv(comprehensive_table, "output/multiple_regression/MeHg_hgcA_comprehensive_model_results.csv", row.names = FALSE)



# test model assumptions
best_model <- lm(MeHg ~ overall_hgcA + F1Hg + site + type, data = df)

# Quick diagnostic plots
par(mfrow = c(2,2))
plot(best_model)

# 1. Normality of residuals
shapiro.test(residuals(best_model))
# 2. Homoscedasticity
library(lmtest)
bptest(best_model)  
# 3. Independence of errors
dwtest(best_model)  
# 4. Multicollinearity
library(car)
vif(best_model)


```

### Save multiple regression to tabular format (log MeHg ~ hgcA)
```r
# Load required library
library(AICcmodavg)

df$logMeHg <- log10(df$MeHg)

# Fit all your models (assuming you already have these)
model1 <- lm(logMeHg ~ overall_hgcA, data = df)
model2 <- lm(logMeHg ~ F1Hg, data = df)
model3 <- lm(logMeHg ~ overall_hgcA + F1Hg, data = df)
model4 <- lm(logMeHg ~ overall_hgcA * F1Hg, data = df)
model5 <- lm(logMeHg ~ overall_hgcA + F1Hg + site + type, data = df)
model6 <- lm(logMeHg ~ overall_hgcA * F1Hg + site + type, data = df)
model7 <- lm(logMeHg ~ overall_hgcA * F1Hg * site + type, data = df)

# Create lists
models <- list(model1, model2, model3, model4, model5, model6, model7)
model_names <- c("hgcA only", "F1Hg only", "additive", "interaction", 
                 "additive + site/type", "interaction + site/type", "full interactions")

# Get model structures automatically
model_structures <- sapply(models, function(x) deparse(formula(x)))

# Get model descriptions
model_descriptions <- c("hgcA gene abundance only",
                       "Bioavailable Hg(II) only",
                       "Additive effects of hgcA and F1-Hg",
                       "hgcA and F1-Hg with interaction",
                       "Additive effects controlling for site and compartment",
                       "Interaction effects controlling for site and compartment", 
                       "Full interaction model with site-specific effects")

# Use aictab to get AIC comparison automatically
aic_table <- aictab(models, modnames = model_names)

# Extract all model statistics automatically
extract_all_stats <- function(model) {
  summ <- summary(model)
  list(
    R_squared = summ$r.squared,
    Adj_R_squared = summ$adj.r.squared,
    F_statistic = summ$fstatistic[1],
    F_p_value = pf(summ$fstatistic[1], summ$fstatistic[2], summ$fstatistic[3], lower.tail = FALSE),
    Residual_SE = summ$sigma,
    DF = summ$df[2],
    N_observations = nobs(model)
  )
}

# Get all statistics
all_stats <- do.call(rbind, lapply(models, function(x) data.frame(extract_all_stats(x))))

# Create the comprehensive table
comprehensive_table <- data.frame(
  Model_Name = model_names,
  Model_Structure = model_structures,
  Model_Description = model_descriptions,
  K = aic_table$K,
  N_observations = all_stats$N_observations,
  AICc = aic_table$AICc,
  Delta_AICc = aic_table$Delta_AICc,
  AICcWt = aic_table$AICcWt,
  R_squared = all_stats$R_squared,
  Adj_R_squared = all_stats$Adj_R_squared,
  Variance_Explained_Percent = all_stats$Adj_R_squared * 100,
  F_statistic = all_stats$F_statistic,
  F_p_value = all_stats$F_p_value,
  Residual_SE = all_stats$Residual_SE,
  DF = all_stats$DF
)

# Round numeric columns for readability
comprehensive_table$AICc <- round(comprehensive_table$AICc, 2)
comprehensive_table$Delta_AICc <- round(comprehensive_table$Delta_AICc, 2)
comprehensive_table$AICcWt <- round(comprehensive_table$AICcWt, 3)
comprehensive_table$R_squared <- round(comprehensive_table$R_squared, 4)
comprehensive_table$Adj_R_squared <- round(comprehensive_table$Adj_R_squared, 4)
comprehensive_table$Variance_Explained_Percent <- round(comprehensive_table$Variance_Explained_Percent, 2)
comprehensive_table$F_statistic <- round(comprehensive_table$F_statistic, 2)
comprehensive_table$F_p_value <- format(comprehensive_table$F_p_value, scientific = TRUE, digits = 3)
comprehensive_table$Residual_SE <- round(comprehensive_table$Residual_SE, 4)

# Save the comprehensive table
write.csv(comprehensive_table, "output/multiple_regression/LogMeHg_hgcA_comprehensive_model_results.csv", row.names = FALSE)

```

## multiple regression MeHg, methanogen and methanotroph
```r
library(ggplot2)

# 1. load full dataframe
df <- read.csv("data/gy21_geochemical/correlation_analyses_modified.csv", header = TRUE)

df$site <- relevel(factor(df$site), ref = "HX")
df$type <- relevel(factor(df$type), ref = "Surface")

# 2. load dataframe for the flooded period only
df_flooded <- df[df$water == "Flooded", ]

df_flooded$site <- relevel(factor(df_flooded$site), ref = "HX")
df_flooded$type <- relevel(factor(df_flooded$type), ref = "Surface")


## Overall relationship
ggplot(df, aes(x = overall_methanogen, y = MeHg)) +
  geom_point() + 
  geom_smooth(method = "lm", color = "red") +  # Linear
  geom_smooth(method = "loess", color = "blue") +  # Non-linear
  labs(title = "Methanogen vs MeHg: Linear (red) vs Non-linear (blue)")

## By site
ggplot(df, aes(x = overall_methanogen, y = MeHg, color = site)) +
  geom_point() + 
  geom_smooth(method = "loess") +
  facet_wrap(~site)

# 2. Test for Non-Linearity
## Add polynomial terms
methanogen_model1_linear <- lm(MeHg ~ overall_methanogen + site + type, data = df)
methanogen_model1_nonlinear <- lm(MeHg ~ poly(overall_methanogen,2) + site + type, data = df)
summary(methanogen_model1_linear)
summary(methanogen_model1_nonlinear)

## Test if non-linear terms significant
anova(methanogen_model1_linear, methanogen_model1_nonlinear)



mbnT_model <- lm(MeHg ~ overall_mbnT_TIGRFAM_genus + site + type, data = df)
summary(mbnT_model)



## Add interaction terms
### methanogen - full dataset 
methanogen_model1_linear_interaction <- lm(MeHg ~ overall_methanogen * site * type, data = df)
summary(methanogen_model1_linear_interaction)

simple_methanogen_model <- lm(MeHg ~ overall_methanogen + site + type, data = df)
summary(simple_methanogen_model)

simple_methanogen_model_flooded <- lm(MeHg ~ overall_methanogen + site + type, data = df_flooded)
summary(simple_methanogen_model_flooded)

simple_methanogen_model_DOM <- lm(MeHg ~ overall_methanogen + DOM + site + type, data = df)
summary(simple_methanogen_model_DOM)

simple_methanogen_model_DOM_SUVA <- lm(MeHg ~ overall_methanogen + DOM_SUVA254 + site + type, data = df)
summary(simple_methanogen_model_DOM_SUVA)

simple_methanogen_model_DOM_SUVA <- lm(MeHg ~ overall_methanogen*DOM_SUVA254 + site + type, data = df)
summary(simple_methanogen_model_DOM_SUVA)


simple_THg_model<- lm(MeHg ~ overall_methanogen*THg + site + type, data = df)
summary(simple_THg_model)




### methanotroph
methanotroph_model1_linear_interaction <- lm(MeHg ~ overall_aerobic_methanotroph * site * type, data = df)
summary(methanotroph_model1_linear_interaction)

simple_methanotroph_model <- lm(MeHg ~ overall_aerobic_methanotroph + site + type, data = df)
summary(simple_methanotroph_model)

Anova(methanotroph_model1_linear_interaction, type = "III")



### flooded period
methanotroph_model1_linear_interaction_flooded <- lm(MeHg ~ overall_aerobic_methanotroph * site * type, data = df_flooded)
summary(methanotroph_model1_linear_interaction_flooded)

simple_methanotroph_model_flooded <- lm(MeHg ~ overall_aerobic_methanotroph + site + type +, data = df_flooded)
summary(simple_methanotroph_model_flooded)

model1 <- lm(MeHg ~ overall_aerobic_methanotroph, data = df_flooded)
summary(model1)

Anova(methanotroph_model1_linear_interaction_flooded, type = "III")

### methanotroph_mbnT
simple_methanotroph_mbnT_model <- lm(MeHg ~ overall_mbnT_TIGRFAM_genus + site + type, data = df)
summary(simple_methanotroph_mbnT_model)


simple_Methylosinus_mbnT_model <- lm(MeHg ~ Methylosinus + site + type, data = df)
summary(simple_Methylosinus_mbnT_model)

simple_Methylomicrobium_mbnT_model <- lm(MeHg ~ Methylomicrobium + site + type, data = df)
summary(simple_Methylomicrobium_mbnT_model)

simple_Methylocystis_mbnT_model <- lm(MeHg ~ Methylocystis + site + type, data = df)
summary(simple_Methylocystis_mbnT_model)

# hgcA
model1 <- lm(MeHg ~ overall_hgcA, data = df)
model2 <- lm(MeHg ~ overall_hgcA + site + type, data = df)
summary(model1)
summary(model2)


```

